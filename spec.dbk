<?xml version="1.0"?>
<!DOCTYPE book
  PUBLIC "-//OASIS//DTD DocBook V4.2//EN"
         "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">

<book>
  <bookinfo>
    <title>
      YAML&nbsp;Ain<q/>t&nbsp;Markup&nbsp;Language&nbsp;(<trademark
      >YAML</trademark>)
      Version&nbsp;1.2
    </title>

    <subtitle>
      3<superscript>rd</superscript>&nbsp;Edition,&nbsp;Patched&nbsp;at&nbsp;YYYY-MM-DD
    </subtitle>

    <authorgroup>
      <author>
        <firstname>Oren</firstname>
        <surname>Ben-Kiki</surname>
        <email>oren@ben-kiki.org</email>
      </author>

      <author>
        <firstname>Clark</firstname>
        <surname>Evans</surname>
        <email>cce@clarkevans.com</email>
      </author>

      <author>
        <firstname>Ingy</firstname>
        <surname>d&ouml;t Net</surname>
        <email>ingy@ingy.net</email>
      </author>

      <mediaobject>
        <imageobject>
          <imagedata fileref="logo.eps" format="eps"/>
        </imageobject>
      </mediaobject>
    </authorgroup>

    <copyright>
      <year>2001-YYYY</year>
      <holder>Oren Ben-Kiki<fo>,&nbsp;</fo></holder>
      <holder>Clark Evans<fo>,&nbsp;</fo></holder>
      <holder>Ingy d&ouml;t Net</holder>
    </copyright>

    <legalnotice>
      <fo>&nbsp;<sbr/>&nbsp;<sbr/></fo>
      This document may be freely copied, provided it is not modified.
    </legalnotice>

    <releaseinfo id="releaseinfo">
      <emphasis>Latest (patched) version:</emphasis><sbr/>
      &nbsp;&nbsp;HTML:
      <ulink url="http://yaml.org/spec/1.2/spec.html"/><sbr/>
      &nbsp;&nbsp;PDF:
      <ulink url="http://yaml.org/spec/1.2/spec.pdf"/><sbr/>
      &nbsp;&nbsp;PS:
      <ulink url="http://yaml.org/spec/1.2/spec.ps"/><sbr/>
      &nbsp;&nbsp;Errata:
      <ulink url="http://yaml.org/spec/1.2/errata.html"/><sbr/>
      <emphasis>Previous (original) version:</emphasis>
      <ulink url="http://yaml.org/spec/1.2/2009-07-21/spec.html"/><sbr/>
    </releaseinfo>

    <abstract>
      <title>Status of this Document</title>

      <para>
        This document reflects the third version of YAML data serialization
        language. The content of the specification was arrived at by consensus
        of its authors and through user feedback on the <ulink
        url="http://lists.sourceforge.net/lists/listinfo/yaml-core">yaml-core</ulink>
        mailing list. We encourage implementers to please update their software
        with support for this version.
      </para>

      <para>
        The primary objective of this revision is to bring YAML into compliance
        with JSON as an official subset. YAML 1.2 is compatible with 1.1 for
        most practical applications - this is a minor revision. An expected
        source of incompatibility with prior versions of YAML, especially the
        syck implementation, is the change in implicit typing rules. We have
        removed unique implicit typing rules and have updated these rules to
        align them with JSON's productions. In this version of YAML, boolean
        values may be serialized as <uquote>true</uquote> or
        <uquote>false</uquote>; the empty scalar as <uquote>null</uquote>.
        Unquoted numeric values are a superset of JSON's numeric production.
        Other changes in the specification were the removal of the Unicode line
        breaks and production bug fixes. We also define 3 built-in implicit
        typing rule sets: untyped, strict JSON, and a more flexible YAML rule
        set that extends JSON typing.
      </para>

      <para>
        The difference between late 1.0 drafts which syck 0.55 implements and
        the 1.1 revision of this specification is much more extensive. We fixed
        usability issues with the tagging syntax. In particular, the single
        exclamation was re-defined for private types and a simple prefixing
        mechanism was introduced. This revision also fixed many production edge
        cases and introduced a type repository. Therefore, there are several
        incompatibilities between syck and this revision as well.
      </para>

      <para>
        The list of known errors in this specification is available at <ulink
        url="http://yaml.org/spec/1.2/errata.html">http://yaml.org/spec/1.2/errata.html</ulink>.
        Please report errors in this document to the <ulink
        href="http://lists.sourceforge.net/lists/listinfo/yaml-core">
        yaml-core</ulink> mailing list. This revision contains fixes for all
        errors known as of YYYY-MM-DD.
      </para>

      <para>
        We wish to thank implementers who have tirelessly tracked earlier
        versions of this specification, and our fabulous user community whose
        feedback has both validated and clarified our direction.
      </para>
    </abstract>

    <abstract>
      <title>Abstract</title>

      <para>
        <trademark>YAML</trademark> (rhymes with <quote>camel</quote>) is a
        human-friendly, cross language, Unicode based data serialization
        language designed around the common native data types of agile
        programming languages. It is broadly useful for programming needs
        ranging from configuration files to Internet messaging to object
        persistence to data auditing. Together with the <ulink
        url="http://www.unicode.org/">Unicode standard for characters</ulink>,
        this specification provides all the information necessary to understand
        YAML Version 1.2 and to create programs that process YAML information.
      </para>
    </abstract>

  </bookinfo>

  <chapter id="Introduction">
    <title>Introduction</title>

    <para>
      <quote>YAML Ain<q/>t Markup Language</quote> (abbreviated YAML) is a data
      serialization language designed to be human-friendly and work well with
      modern programming languages for common everyday tasks. This
      specification is both an introduction to the YAML language and the
      concepts supporting it, and also a complete specification of the
      information needed to develop <refterm
      primary="application">applications</refterm> for processing YAML.
    </para>

    <para>
      Open, interoperable and readily understandable tools have advanced
      computing immensely. YAML was designed from the start to be useful and
      friendly to people working with data. It uses Unicode <refterm
      primary="printable character">printable</refterm> characters, <refterm
      primary="indicator">some</refterm> of which provide structural
      information and the rest containing the data itself. YAML achieves a
      unique cleanness by minimizing the amount of structural characters and
      allowing the data to show itself in a natural and meaningful way. For
      example, <refterm primary="space"
      secondary="indentation">indentation</refterm> may be used for structure,
      <refterm primary=": mapping value">colons</refterm> separate <refterm
      primary="key: value pair" >key:&nbsp;value pairs</refterm>, and <refterm
      primary="- block sequence entry">dashes</refterm> are used to create
      <quote>bullet</quote> <refterm primary="sequence">lists</refterm>.
    </para>

    <para>
      There are myriad flavors of <refterm primary="native data structure">data
      structures</refterm>, but they can all be adequately <refterm
      primary="represent">represented</refterm> with three basic primitives:
      <refterm primary="mapping">mappings</refterm> (hashes/dictionaries),
      <refterm primary="sequence">sequences</refterm> (arrays/lists) and
      <refterm primary="scalar">scalars</refterm> (strings/numbers). YAML
      leverages these primitives, and adds a simple typing system and <refterm
      primary="alias">aliasing</refterm> mechanism to form a complete language
      for <refterm primary="serialize">serializing</refterm> any <refterm
      primary="native data structure">native data structure</refterm>. While
      most programming languages can use YAML for data serialization, YAML
      excels in working with those languages that are fundamentally built
      around the three basic primitives. These include the new wave of agile
      languages such as Perl, Python, PHP, Ruby, and Javascript.
    </para>

    <para>
      There are hundreds of different languages for programming, but only a
      handful of languages for storing and transferring data. Even though its
      potential is virtually boundless, YAML was specifically created to work
      well for common use cases such as: configuration files, log files,
      interprocess messaging, cross-language data sharing, object persistence,
      and debugging of complex data structures. When data is easy to view and
      understand, programming becomes a simpler task.
    </para>

    <sect1>
      <title>Goals</title>

      <para>
        The design goals for YAML are, in decreasing priority:
      </para>

      <orderedlist>
        <listitem>
          YAML is easily readable by humans.
        </listitem>

        <listitem>
          YAML data is portable between programming languages.
        </listitem>

        <listitem>
          YAML matches the <refterm primary="native data structure">native data
          structures</refterm> of agile languages.
        </listitem>

        <listitem>
          YAML has a consistent model to support generic tools.
        </listitem>

        <listitem>
          YAML supports one-pass processing.
        </listitem>

        <listitem>
          YAML is expressive and extensible.
        </listitem>

        <listitem>
          YAML is easy to implement and use.
        </listitem>
      </orderedlist>
    </sect1>

    <sect1>
      <title>Prior Art</title>

      <para>
        YAML<q/>s initial direction was set by the data serialization and
        markup language discussions among <ulink
        url="http://www.docuverse.com/smldev/">SML-DEV members</ulink>. Later
        on, it directly incorporated experience from Ingy d&ouml;t Net<q/>s
        Perl module <ulink
        url="http://search.cpan.org/dist/Data-Denter/"
        >Data::Denter</ulink>. Since then, YAML has matured through ideas and
        support from its user community.
      </para>

      <para>
        YAML integrates and builds upon concepts described by <ulink
        url="http://cm.bell-labs.com/cm/cs/cbook/index.html">C</ulink>, <ulink
        url="http://java.sun.com/">Java</ulink>, <ulink
        url="http://www.perl.org/">Perl</ulink>, <ulink
        url="http://www.python.org/">Python</ulink>, <ulink
        url="http://www.ruby-lang.org/">Ruby</ulink>, <ulink
        url="http://www.ietf.org/rfc/rfc0822.txt">RFC0822</ulink> (MAIL),
        <ulink
        url="http://www.ics.uci.edu/pub/ietf/html/rfc1866.txt">RFC1866</ulink>
        (HTML), <ulink
        url="http://www.ietf.org/rfc/rfc2045.txt">RFC2045</ulink> (MIME),
        <ulink url="http://www.ietf.org/rfc/rfc2396.txt">RFC2396</ulink> (URI),
        <ulink url="http://www.w3.org/TR/REC-xml.html">XML</ulink>, <ulink
        url="http://www.saxproject.org/">SAX</ulink>, <ulink
        url="http://www.w3.org/TR/SOAP">SOAP</ulink>, and <ulink
        url="http://www.json.org/">JSON</ulink>.
      </para>

      <para>
        The syntax of YAML was motivated by Internet Mail (RFC0822) and remains
        partially compatible with that standard. Further, borrowing from MIME
        (RFC2045), YAML<q/>s top-level production is a <refterm
        primary="stream">stream</refterm> of independent <refterm
        primary="document">documents</refterm>, ideal for message-based
        distributed processing systems.
      </para>

      <para>
        YAML<q/>s <refterm primary="space"
        secondary="indentation">indentation</refterm>-based scoping is similar
        to Python<q/>s (without the ambiguities caused by <refterm
        primary="tab">tabs</refterm>). <refterm primary="style"
        secondary="block">Indented blocks</refterm> facilitate easy inspection
        of the data<q/>s structure. YAML<q/>s <refterm primary="style"
        secondary="block" tertiary="literal">literal style</refterm> leverages
        this by enabling formatted text to be cleanly mixed within an <refterm
        primary="space" secondary="indentation">indented</refterm> structure
        without troublesome <refterm primary="escaping" secondary="in
        double-quoted scalars">escaping</refterm>. YAML also allows the use of
        traditional <refterm primary="indicator">indicator</refterm>-based
        scoping similar to JSON<q/>s and Perl<q/>s. Such <refterm
        primary="style" secondary="flow">flow content</refterm> can be freely
        nested inside <refterm primary="style" secondary="block">indented
        blocks</refterm>.
      </para>

      <para>
        YAML<q/>s <refterm primary="style" secondary="flow"
        tertiary="double-quoted">double-quoted style</refterm> uses familiar
        C-style <refterm primary="escaping" secondary="in double-quoted
        scalars">escape sequences</refterm>. This enables ASCII encoding of
        non-<refterm primary="printable character">printable</refterm> or 8-bit
        (ISO 8859-1) characters such as <link
        linkend="ns-esc-8-bit"><uquote>\x3B</uquote></link>. Non-<refterm
        primary="printable character">printable</refterm> 16-bit Unicode and
        32-bit (ISO/IEC 10646) characters are supported with <refterm
        primary="escaping" secondary="in double-quoted scalars">escape
        sequences</refterm> such as <link
        linkend="ns-esc-16-bit"><uquote>\u003B</uquote></link> and <link
        linkend="ns-esc-32-bit"><uquote>\U0000003B</uquote></link>.
      </para>

      <para>
        Motivated by HTML<q/>s end-of-line normalization, YAML<q/>s <refterm
        primary="line folding">line folding</refterm> employs an intuitive
        method of handling <refterm primary="line break">line breaks</refterm>.
        A single <refterm primary="line break">line break</refterm> is <refterm
        primary="line folding">folded</refterm> into a single <refterm
        primary="space">space</refterm>, while <refterm primary="empty
        line">empty lines</refterm> are interpreted as <refterm primary="line
        break">line break</refterm> characters. This technique allows for
        paragraphs to be word-wrapped without affecting the <refterm
        primary="scalar" secondary="canonical form">canonical form</refterm> of
        the <refterm primary="scalar">scalar content</refterm>.
      </para>

      <para>
        YAML<q/>s core type system is based on the requirements of agile
        languages such as Perl, Python, and Ruby. YAML directly supports both
        <refterm primary="collection">collections</refterm> (<refterm
        primary="mapping">mappings</refterm>, <refterm
        primary="sequence">sequences</refterm>) and <refterm
        primary="scalar">scalars</refterm>. Support for these common types
        enables programmers to use their language<q/>s <refterm primary="native
        data structure">native data structures</refterm> for YAML manipulation,
        instead of requiring a special document object model (DOM).
      </para>

      <para>
        Like XML<q/>s SOAP, YAML supports <refterm
        primary="serialize">serializing</refterm> a graph of <refterm
        primary="native data structure">native data structures</refterm>
        through an <refterm primary="alias">aliasing</refterm> mechanism. Also
        like SOAP, YAML provides for <refterm
        primary="application">application</refterm>-defined <refterm
        primary="tag">types</refterm>. This allows YAML to <refterm
        primary="represent">represent</refterm> rich data structures required
        for modern distributed computing. YAML provides globally unique
        <refterm primary="tag" secondary="global">type names</refterm> using a
        namespace mechanism inspired by Java<q/>s DNS-based package naming
        convention and XML<q/>s URI-based namespaces. In addition, YAML allows
        for private <refterm primary="tag" secondary="local">types</refterm>
        specific to a single <refterm
        primary="application">application</refterm>.
      </para>

      <para>
        YAML was designed to support incremental interfaces that include both
        input (<uquote>getNextEvent()</uquote>) and output
        (<uquote>sendNextEvent()</uquote>) one-pass interfaces. Together, these
        enable YAML to support the processing of large <refterm
        primary="document">documents</refterm> (e.g. transaction logs) or
        continuous <refterm primary="stream">streams</refterm> (e.g. feeds from
        a production machine).
      </para>
    </sect1>

    <sect1>
      <title>Relation to JSON</title>

      <para>
        Both JSON and YAML aim to be human readable data interchange formats.
        However, JSON and YAML have different priorities. JSON<q/>s foremost
        design goal is simplicity and universality. Thus, JSON is trivial to
        generate and parse, at the cost of reduced human readability. It also
        uses a lowest common denominator information model, ensuring any JSON
        data can be easily processed by every modern programming environment.
      </para>

      <para>
        In contrast, YAML<q/>s foremost design goals are human readability and
        support for <refterm primary="serialize">serializing</refterm>
        arbitrary <refterm primary="native data structure">native data
        structures</refterm>. Thus, YAML allows for extremely readable files,
        but is more complex to generate and parse. In addition, YAML ventures
        beyond the lowest common denominator data types, requiring more complex
        processing when crossing between different programming environments.
      </para>

      <para>
        YAML can therefore be viewed as a natural superset of JSON, offering
        improved human readability and a more complete information model. This
        is also the case in practice; every JSON file is also a valid YAML
        file. This makes it easy to migrate from JSON to YAML if/when the
        additional features are required.
      </para>

      <para>
        JSON's <ulink url="http://www.ietf.org/rfc/rfc4627.txt">RFC4627</ulink>
        requires that <refterm primary="mapping">mappings</refterm> <refterm
        primary="key">keys</refterm> merely <quote>SHOULD</quote> be <refterm
        primary="equality">unique</refterm>, while YAML insists they
        <quote>MUST</quote> be. Technically, YAML therefore complies with the
        JSON spec, choosing to treat duplicates as an error. In practice, since
        JSON is silent on the semantics of such duplicates, the only portable
        JSON files are those with unique keys, which are therefore valid YAML
        files.
      </para>

      <para>
        It may be useful to define a intermediate format between YAML and JSON.
        Such a format would be trivial to parse (but not very human readable),
        like JSON. At the same time, it would allow for <refterm
        primary="serialize">serializing</refterm> arbitrary <refterm
        primary="native data structure">native data structures</refterm>, like
        YAML. Such a format might also serve as YAML<q/>s "canonical format".
        Defining such a <quote>YSON</quote> format (YSON is a Serialized Object
        Notation) can be done either by enhancing the JSON specification or by
        restricting the YAML specification. Such a definition is beyond the
        scope of this specification.
      </para>
    </sect1>

    <pagebreak/>

    <sect1>
      <title>Relation to XML</title>

      <para>
        Newcomers to YAML often search for its correlation to the eXtensible
        Markup Language (XML). Although the two languages may actually compete
        in several application domains, there is no direct correlation between
        them.
      </para>

      <para>
        YAML is primarily a data serialization language. XML was designed to be
        backwards compatible with the Standard Generalized Markup Language
        (SGML), which was designed to support structured documentation. XML
        therefore had many design constraints placed on it that YAML does not
        share. XML is a pioneer in many domains, YAML is the result of lessons
        learned from XML and other technologies.
      </para>

      <para>
        It should be mentioned that there are ongoing efforts to define
        standard XML/YAML mappings. This generally requires that a subset of
        each language be used. For more information on using both XML and YAML,
        please visit <ulink url="http://yaml.org/xml"/>.
      </para>
    </sect1>

    <sect1>
      <title>Terminology</title>

      <para>
        This specification uses key words based on <ulink
        url="http://www.ietf.org/rfc/rfc2119.txt">RFC2119</ulink> to indicate
        requirement level. In particular, the following words are used to
        describe the actions of a YAML <refterm
        primary="processor">processor</refterm>:
      </para>

      <variablelist>
        <varlistentry>
          <term>May</term>

          <listitem>
            The word <emphasis>may</emphasis>, or the adjective
            <emphasis>optional</emphasis>, mean that conforming YAML <refterm
            primary="processor">processors</refterm> are permitted to, but
            <defterm primary="need not">need not</defterm> behave as described.
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Should</term>

          <listitem>
            The word <emphasis>should</emphasis>, or the adjective
            <emphasis>recommended</emphasis>, mean that there could be reasons
            for a YAML <refterm primary="processor">processor</refterm> to
            deviate from the behavior described, but that such deviation could
            hurt interoperability and should therefore be advertised with
            appropriate notice.
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Must</term>

          <listitem>
            The word <emphasis>must</emphasis>, or the term <defterm
            primary="required">required</defterm> or <defterm
            primary="shall">shall</defterm>, mean that the behavior described
            is an absolute requirement of the specification.
          </listitem>
        </varlistentry>
      </variablelist>
    </sect1>

    <para>
      The rest of this document is arranged as follows. Chapter <link
      linkend="Preview">2</link> provides a short preview of the main YAML
      features. Chapter <link linkend="Processing">3</link> describes the YAML
      information model, and the processes for converting from and to this
      model and the YAML text format. The bulk of the document, chapters <link
      linkend="Syntax">4</link> through <link linkend="YAML">9</link>, formally
      define this text format. Finally, chapter <link
      linkend="Syntax">10</link> recommends basic YAML schemas.
    </para>
  </chapter>

  <chapter id="Preview">
    <title>Preview</title>

    <para>
      This section provides a quick glimpse into the expressive power of YAML.
      It is not expected that the first-time reader grok all of the examples.
      Rather, these selections are used as motivation for the remainder of the
      specification.
    </para>

    <sect1>
      <title>Collections</title>

      <para>
        YAML<q/>s <refterm primary="style" secondary="block"
        tertiary="collection">block collections</refterm> use <refterm
        primary="space" secondary="indentation">indentation</refterm> for scope
        and begin each entry on its own line. <refterm primary="style"
        secondary="block" tertiary="sequence">Block sequences</refterm>
        indicate each entry with a dash and space&nbsp;( <refterm primary="-
        block sequence entry"><uquote>-&nbsp;</uquote></refterm>). <refterm
        primary="mapping">Mappings</refterm> use a colon and
        space&nbsp;(<refterm primary=": mapping
        value"><uquote>:&nbsp;</uquote></refterm>) to mark each <refterm
        primary="key: value pair">key:&nbsp;value pair</refterm>. <refterm
        primary="comment">Comments</refterm> begin with an octothorpe (also
        called a <quote>hash</quote>, <quote>sharp</quote>,
        <quote>pound</quote>, or <quote>number sign</quote> - <refterm
        primary="# comment"> <uquote>#</uquote></refterm>).
      </para>

      <simplelist type="horiz" columns="2">
        <member>
          <example>
            <title>
              Sequence of Scalars<sbr/>
              (ball players)
            </title>
<programlisting>- Mark McGwire<sbr/>
- Sammy Sosa
- Ken Griffey
</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>
              Mapping Scalars to Scalars<sbr/>
              (player statistics)
            </title>
<programlisting>hr:  65    # Home runs<sbr/>
avg: 0.278 # Batting average
rbi: 147   # Runs Batted In
</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>
              Mapping Scalars to Sequences<sbr/>
              (ball clubs in each league)
            </title>
<programlisting>american:<sbr/>
  - Boston Red Sox
  - Detroit Tigers
  - New York Yankees
national:
  - New York Mets
  - Chicago Cubs
  - Atlanta Braves
</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>
              Sequence of Mappings<sbr/>
              (players<q/> statistics)
            </title>
<programlisting>-<sbr/>
  name: Mark McGwire
  hr:   65
  avg:  0.278
-
  name: Sammy Sosa
  hr:   63
  avg:  0.288
</programlisting>
          </example>
        </member>
      </simplelist>

      <para>
        YAML also has <refterm primary="style" secondary="flow">flow
        styles</refterm>, using explicit <refterm
        primary="indicator">indicators</refterm> rather than <refterm
        primary="space" secondary="indentation">indentation</refterm> to denote
        scope. The <refterm primary="style" secondary="flow"
        tertiary="sequence">flow sequence</refterm> is written as a <refterm
        primary=", end flow entry">comma</refterm> separated list within
        <refterm primary="[ start flow sequence">square</refterm> <refterm
        primary="] end flow sequence">brackets</refterm>. In a similar manner,
        the <refterm primary="style" secondary="flow" tertiary="mapping">flow
        mapping</refterm> uses <refterm primary="{ start flow
        mapping">curly</refterm> <refterm primary="} end flow
        mapping">braces</refterm>.
      </para>

      <simplelist type="horiz" columns="2">
        <member>
          <example>
            <title>Sequence of Sequences</title>
<programlisting>- [name        , hr, avg  ]<sbr/>
- [Mark McGwire, 65, 0.278]
- [Sammy Sosa  , 63, 0.288]


</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>Mapping of Mappings</title>
<programlisting>Mark McGwire: {hr: 65, avg: 0.278}<sbr/>
Sammy Sosa: {
    hr: 63,
    avg: 0.288
  }
</programlisting>
          </example>
        </member>
      </simplelist>
    </sect1>

    <pagebreak/>

    <sect1>
      <title>Structures</title>

      <para>
        YAML uses three dashes&nbsp;(<refterm primary="marker"
        secondary="directives end"><uquote>---</uquote></refterm>) to separate
        <refterm primary="directive">directives</refterm> from <refterm
        primary="document">document</refterm> <refterm
        primary="content">content</refterm>. This also serves to signal the
        start of a document if no <refterm
        primary="directive">directives</refterm> are present. Three dots&nbsp;(
        <refterm primary="marker" secondary="document
        end"><uquote>...</uquote></refterm>) indicate the end of a document
        without starting a new one, for use in communication channels.
      </para>

      <simplelist type="horiz" columns="2">
        <member>
          <example>
            <title>
              Two Documents in a Stream<sbr/>
              (each with a leading comment)
            </title>
<programlisting># Ranking of 1998 home runs<sbr/>
---
- Mark McGwire
- Sammy Sosa
- Ken Griffey

# Team ranking
---
- Chicago Cubs
- St Louis Cardinals
</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>
              Play by Play Feed<sbr/>
              from a Game
            </title>
<programlisting>---<sbr/>
time: 20:03:20
player: Sammy Sosa
action: strike (miss)
...
---
time: 20:03:47
player: Sammy Sosa
action: grand slam
...
</programlisting>
          </example>
        </member>
      </simplelist>

      <para>
        Repeated <refterm primary="node">nodes</refterm> (objects) are first
        <refterm primary="alias" secondary="identified">identified</refterm>
        by an <refterm primary="anchor">anchor</refterm> (marked with the
        ampersand&nbsp;-&nbsp;<refterm primary="&amp;
        anchor"><uquote>&amp;</uquote></refterm>), and are then <refterm
        primary="alias">aliased</refterm> (referenced with an
        asterisk&nbsp;-&nbsp;<refterm primary="*
        alias"><uquote>*</uquote></refterm>) thereafter.
      </para>

      <simplelist type="horiz" columns="2">
        <member>
          <example>
            <title>
              Single Document with<sbr/>
              Two Comments
            </title>
<programlisting>---<sbr/>
hr: # 1998 hr ranking
  - Mark McGwire
  - Sammy Sosa
rbi:
  # 1998 rbi ranking
  - Sammy Sosa
  - Ken Griffey
</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>
              Node for <uquote>Sammy Sosa</uquote><sbr/>
              appears twice in this document
            </title>
<programlisting>---<sbr/>
hr:
  - Mark McGwire
  # Following node labeled SS
  - &amp;SS Sammy Sosa
rbi:
  - *SS # Subsequent occurrence
  - Ken Griffey
</programlisting>
          </example>
        </member>
      </simplelist>

      <para>
        A question mark and space&nbsp;(<refterm primary="? mapping
        key"><uquote>?&nbsp;</uquote></refterm>) indicate a complex <refterm
        primary="mapping">mapping</refterm> <refterm
        primary="key">key</refterm>. Within a <refterm primary="style"
        secondary="block" tertiary="collection">block collection</refterm>,
        <refterm primary="key: value pair">key:&nbsp;value pairs</refterm> can
        start immediately following the <refterm primary="- block sequence
        entry">dash</refterm>, <refterm primary=": mapping
        value">colon</refterm>, or <refterm primary="? mapping key">question
        mark</refterm>.
      </para>

      <simplelist type="horiz" columns="2">
        <member>
          <example>
            <title>Mapping between Sequences</title>
<programlisting>? - Detroit Tigers<sbr/>
  - Chicago cubs
:
  - 2001-07-23

? [ New York Yankees,
    Atlanta Braves ]
: [ 2001-07-02, 2001-08-12,
    2001-08-14 ]
</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>Compact Nested Mapping</title>
<programlisting>---<sbr/>
# Products purchased
- item    : Super Hoop
  quantity: 1
- item    : Basketball
  quantity: 4
- item    : Big Shoes
  quantity: 1

</programlisting>
          </example>
        </member>
      </simplelist>
    </sect1>

    <sect1>
      <title>Scalars</title>

      <para>
        <refterm primary="scalar">Scalar content</refterm> can be written in
        <refterm primary="style" secondary="block">block</refterm> notation,
        using a <refterm primary="style" secondary="block"
        tertiary="literal">literal style</refterm>&nbsp;(indicated by <refterm
        primary="| literal style"><uquote>|</uquote></refterm>) where all
        <refterm primary="line break">line breaks</refterm> are significant.
        Alternatively, they can be written with the <refterm primary="style"
        secondary="block" tertiary="folded">folded
        style</refterm>&nbsp;<refterm primary="&gt; folded style">(denoted by
        <uquote>&gt;</uquote></refterm>) where each <refterm primary="line
        break">line break</refterm> is <refterm primary="line
        folding">folded</refterm> to a <refterm primary="space">space</refterm>
        unless it ends an <refterm primary="empty line">empty</refterm> or a
        <refterm primary="more-indented">more-indented</refterm> line.
      </para>

      <simplelist type="horiz" columns="2">
        <member>
          <example>
            <title>
              In literals,<sbr/>
              newlines are preserved
            </title>
<programlisting># ASCII Art<sbr/>
--- |
  \//||\/||
  // ||  ||__
</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>
              In the folded scalars,<sbr/>
              newlines become spaces
            </title>
<programlisting>--- &gt;<sbr/>
  Mark McGwire's
  year was crippled
  by a knee injury.
</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>
              Folded newlines are preserved<sbr/>
              for "more indented" and blank lines
            </title>
<programlisting>&gt;<sbr/>
 Sammy Sosa completed another
 fine season with great stats.

   63 Home Runs
   0.288 Batting Average

 What a year!
</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>
              Indentation determines scope<sbr/>
              &nbsp;
            </title>
<programlisting>name: Mark McGwire<sbr/>
accomplishment: &gt;
  Mark set a major league
  home run record in 1998.
stats: |
  65 Home Runs
  0.278 Batting Average

</programlisting>
          </example>
        </member>
      </simplelist>

      <para>
        YAML<q/>s <refterm primary="style" secondary="flow"
        tertiary="scalar">flow scalars</refterm> include the <refterm
        primary="style" secondary="flow" tertiary="plain">plain style</refterm>
        (most examples thus far) and two quoted styles. The <refterm
        primary="style" secondary="flow" tertiary="double-quoted">double-quoted
        style</refterm> provides <refterm primary="escaping" secondary="in
        double-quoted scalars">escape sequences</refterm>. The <refterm
        primary="style" secondary="flow" teriary="single-quoted">single-quoted
        style</refterm> is useful when <refterm primary="escaping"
        secondary="in double-quoted scalars">escaping</refterm> is not needed.
        All <refterm primary="style" secondary="flow" tertiary="scalar">flow
        scalars</refterm> can span multiple lines; <refterm primary="line
        break">line breaks</refterm> are always <refterm primary="line
        folding">folded</refterm>.
      </para>

      <simplelist type="horiz" columns="2">
        <member>
          <example>
            <title>Quoted Scalars</title>
<programlisting>unicode: "Sosa did fine.\u263A"<sbr/>
control: "\b1998\t1999\t2000\n"
hex esc: "\x0d\x0a is \r\n"

single: '"Howdy!" he cried.'
quoted: ' # Not a ''comment''.'
tie-fighter: '|\-*-/|'
</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>Multi-line Flow Scalars</title>
<programlisting>plain:<sbr/>
  This unquoted scalar
  spans many lines.

quoted: "So does this
  quoted scalar.\n"

</programlisting>
          </example>
        </member>
      </simplelist>
    </sect1>

    <pagebreak/>

    <sect1>
      <title>Tags</title>

      <para>
        In YAML, <refterm primary="tag" secondary="non-specific">untagged
        nodes</refterm> are given a type depending on the <refterm
        primary="application">application</refterm>. The examples in this
        specification generally use the <refterm primary="tag"
        secondary="repository" tertiary="seq">
        <userinput>seq</userinput></refterm>, <refterm primary="tag"
        secondary="repository" tertiary="map">
        <userinput>map</userinput></refterm> and <refterm primary="tag"
        secondary="repository" tertiary="str">
        <userinput>str</userinput></refterm> types from the <refterm
        primary="schema" secondary="failsafe">fail safe schema</refterm>. A few
        examples also use the <refterm primary="tag" secondary="repository"
        tertiary="int"><userinput>int</userinput></refterm>, <refterm
        primary="tag" secondary="repository"
        tertiary="float"><userinput>float</userinput></refterm>, and <refterm
        primary="tag" secondary="repository"
        tertiary="null"><userinput>null</userinput></refterm> types from the
        <refterm primary="schema" secondary="JSON">JSON schema</refterm>. The
        <refterm primary="tag" secondary="repository">repository</refterm>
        includes additional types such as <ulink
        url="http://yaml.org/type/binary.html"
        ><userinput>binary</userinput></ulink>, <ulink
        url="http://yaml.org/type/omap.html"><userinput>omap</userinput></ulink>,
        <ulink
        url="http://yaml.org/type/set.html"><userinput>set</userinput></ulink>
        and others.
      </para>

      <simplelist type="horiz" columns="2">
        <member>
          <example>
            <title>Integers</title>
<programlisting>canonical: 12345<sbr/>
decimal: +12345
octal: 0o14
hexadecimal: 0xC

</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>Floating Point</title>
<programlisting>canonical: 1.23015e+3<sbr/>
exponential: 12.3015e+02
fixed: 1230.15
negative infinity: -.inf
not a number: .NaN
</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>Miscellaneous</title>
<programlisting>null:<sbr/>
booleans: [ true, false ]
string: '012345'
</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>Timestamps</title>
<programlisting>canonical: 2001-12-15T02:59:43.1Z<sbr/>
iso8601: 2001-12-14t21:59:43.10-05:00
spaced: 2001-12-14 21:59:43.10 -5
date: 2002-12-14
</programlisting>
          </example>
        </member>
      </simplelist>

      <para>
        Explicit typing is denoted with a <refterm primary="tag">tag</refterm>
        using the exclamation point (<refterm primary="! tag
        indicator"><uquote>!</uquote></refterm>) symbol. <refterm primary="tag"
        secondary="global">Global tags</refterm> are URIs and may be specified
        in a <refterm primary="tag" secondary="shorthand">tag
        shorthand</refterm> notation using a <refterm primary="tag"
        secondary="handle">handle</refterm>. <refterm
        primary="application">Application</refterm>-specific <refterm
        primary="tag" secondary="local">local tags</refterm> may also be used.
      </para>

      <simplelist type="horiz" columns="2">
        <member>
          <example>
            <title>Various Explicit Tags</title>
<programlisting>---<sbr/>
not-date: !!str 2002-04-28

picture: !!binary |
 R0lGODlhDAAMAIQAAP//9/X
 17unp5WZmZgAAAOfn515eXv
 Pz7Y6OjuDg4J+fn5OTk6enp
 56enmleECcgggoBADs=

application specific tag: !something |
 The semantics of the tag
 above may be different for
 different documents.

</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>Global Tags</title>
<programlisting>%TAG ! tag:clarkevans.com,2002:<sbr/>
--- !shape
  # Use the ! handle for presenting
  # tag:clarkevans.com,2002:circle
- !circle
  center: &amp;ORIGIN {x: 73, y: 129}
  radius: 7
- !line
  start: *ORIGIN
  finish: { x: 89, y: 102 }
- !label
  start: *ORIGIN
  color: 0xFFEEBB
  text: Pretty vector drawing.
</programlisting>
          </example>
        </member>
      </simplelist>

      <simplelist type="horiz" columns="2">
        <member>
          <example>
            <title>Unordered Sets</title>
<programlisting># Sets are represented as a<sbr/>
# Mapping where each key is
# associated with a null value
--- !!set
? Mark McGwire
? Sammy Sosa
? Ken Griff
</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>Ordered Mappings</title>
<programlisting># Ordered maps are represented as<sbr/>
# A sequence of mappings, with
# each mapping having one key
--- !!omap
- Mark McGwire: 65
- Sammy Sosa: 63
- Ken Griffy: 58
</programlisting>
          </example>
        </member>
      </simplelist>
    </sect1>

    <sect1>
      <title>Full Length Example</title>

      <para>
        Below are two full-length examples of YAML. On the left is a sample
        invoice; on the right is a sample log file.
      </para>

      <simplelist type="horiz" columns="2">
        <member>
          <example>
            <title>Invoice</title>
<programlisting>--- !&lt;tag:clarkevans.com,2002:invoice&gt;<sbr/>
invoice: 34843
date   : 2001-01-23
bill-to: &amp;id001
    given  : Chris
    family : Dumars
    address:
        lines: |
            458 Walkman Dr.
            Suite #292
        city    : Royal Oak
        state   : MI
        postal  : 48046
ship-to: *id001
product:
    - sku         : BL394D
      quantity    : 4
      description : Basketball
      price       : 450.00
    - sku         : BL4438H
      quantity    : 1
      description : Super Hoop
      price       : 2392.00
tax  : 251.42
total: 4443.52
comments:
    Late afternoon is best.
    Backup contact is Nancy
    Billsmer @ 338-4338.
</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>Log File</title>
<programlisting>---<sbr/>
Time: 2001-11-23 15:01:42 -5
User: ed
Warning:
  This is an error message
  for the log file
---
Time: 2001-11-23 15:02:31 -5
User: ed
Warning:
  A slightly different error
  message.
---
Date: 2001-11-23 15:03:17 -5
User: ed
Fatal:
  Unknown variable "bar"
Stack:
  - file: TopClass.py
    line: 23
    code: |
      x = MoreObject("345\n")
  - file: MoreClass.py
    line: 58
    code: |-
      foo = bar



</programlisting>
          </example>
        </member>
      </simplelist>
    </sect1>
  </chapter>

  <chapter id="Processing">
    <title>Processing YAML Information</title>

    <para>
      YAML is both a text format and a method for <refterm
      primary="present">presenting</refterm> any <refterm primary="native data
      structure">native data structure</refterm> in this format. Therefore,
      this specification defines two concepts: a class of data objects called
      YAML <refterm primary="representation">representations</refterm>, and a
      syntax for <refterm primary="present">presenting</refterm> YAML <refterm
      primary="representation">representations</refterm> as a series of
      characters, called a YAML <refterm primary="stream">stream</refterm>. A
      YAML <defterm primary="processor">processor</defterm> is a tool for
      converting information between these complementary views. It is assumed
      that a YAML processor does its work on behalf of another module, called
      an <defterm primary="application">application</defterm>. This chapter
      describes the information structures a YAML processor must provide to or
      obtain from the application.
    </para>

    <para>
      YAML information is used in two ways: for machine processing, and for
      human consumption. The challenge of reconciling these two perspectives is
      best done in three distinct translation stages: <refterm
      primary="representation">representation</refterm>, <refterm
      primary="serialization">serialization</refterm>, and <refterm
      primary="presentation">presentation</refterm>. <refterm
      primary="representation">Representation</refterm> addresses how YAML
      views <refterm primary="native data structure">native data
      structures</refterm> to achieve portability between programming
      environments. <refterm primary="serialization">Serialization</refterm>
      concerns itself with turning a YAML <refterm
      primary="representation">representation</refterm> into a serial form,
      that is, a form with sequential access constraints. <refterm
      primary="presentation">Presentation</refterm> deals with the formatting
      of a YAML <refterm primary="serialization">serialization</refterm> as a
      series of characters in a human-friendly manner.
    </para>

    <sect1>
      <title>Processes</title>

      <para>
        Translating between <refterm primary="native data structure">native
        data structures</refterm> and a character <refterm
        primary="stream">stream</refterm> is done in several logically distinct
        stages, each with a well defined input and output data model, as shown
        in the following diagram:
      </para>

      <figure>
        <title>Processing Overview</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="overview2.eps" format="eps"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>
        A YAML processor need not expose the <refterm
        primary="serialization">serialization</refterm> or <refterm
        primary="representation">representation</refterm> stages. It may
        translate directly between <refterm primary="native data
        structure">native data structures</refterm> and a character <refterm
        primary="stream">stream</refterm> (<refterm
        primary="dump">dump</refterm> and <refterm
        primary="load">load</refterm> in the diagram above). However, such a
        direct translation should take place so that the <refterm
        primary="native data structure">native data structures</refterm> are
        <refterm primary="construct">constructed</refterm> only from
        information available in the <refterm
        primary="representation">representation</refterm>. In particular,
        <refterm primary="key" secondary="order">mapping key order</refterm>,
        <refterm primary="comment">comments</refterm>, and <refterm
        primary="tag" secondary="handle">tag handles</refterm> should not be
        referenced during <refterm primary="compose">composition</refterm>.
      </para>

      <pagebreak/>

      <sect2>
        <title>Dump</title>

        <para>
          <defterm primary="dump">Dumping</defterm> native data structures to a
          character <refterm primary="stream">stream</refterm> is done using
          the following three stages:
        </para>

        <variablelist>
          <varlistentry>
            <term>Representing<pbr/>Native Data<pbr/>Structures</term>

            <listitem>
              <para>
                YAML <defterm primary="represent">represents</defterm> any
                <defterm primary="native data structure">native data
                structure</defterm> using three <refterm primary="kind">node
                kinds</refterm>: <refterm primary="sequence">sequence</refterm>
                - an ordered series of entries; <refterm
                primary="mapping">mapping</refterm> - an unordered association
                of <refterm primary="equality">unique</refterm> <refterm
                primary="key">keys</refterm> to <refterm
                primary="value">values</refterm>; and <refterm
                primary="scalar">scalar</refterm> - any datum with opaque
                structure presentable as a series of Unicode characters.
                Combined, these primitives generate directed graph structures.
                These primitives were chosen because they are both powerful and
                familiar: the <refterm primary="sequence">sequence</refterm>
                corresponds to a Perl array and a Python list, the <refterm
                primary="mapping">mapping</refterm> corresponds to a Perl hash
                table and a Python dictionary. The <refterm
                primary="scalar">scalar</refterm> represents strings, integers,
                dates, and other atomic data types.
              </para>

              <para>
                Each YAML <refterm primary="node">node</refterm> requires, in
                addition to its <refterm primary="kind">kind</refterm> and
                <refterm primary="content">content</refterm>, a <refterm
                primary="tag">tag</refterm> specifying its data type. Type
                specifiers are either <refterm primary="tag"
                secondary="global">global</refterm> URIs, or are <refterm
                primary="tag" secondary="local">local</refterm> in scope to a
                single <refterm primary="application">application</refterm>.
                For example, an integer is represented in YAML with a <refterm
                primary="scalar">scalar</refterm> plus the <refterm
                primary="tag" secondary="global">global tag</refterm>
                <uquote>tag:yaml.org,2002:int</uquote>. Similarly, an invoice
                object, particular to a given organization, could be
                represented as a <refterm primary="mapping">mapping</refterm>
                together with the <refterm primary="tag"
                secondary="local">local tag</refterm>
                <uquote>!invoice</uquote>. This simple model can represent any
                data structure independent of programming language.
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Serializing the Representation Graph</term>

            <listitem>
              For sequential access mediums, such as an event callback API, a
              YAML <refterm primary="representation">representation</refterm>
              must be <defterm primary="serialize">serialized</defterm> to an
              ordered tree. Since in a YAML <refterm
              primary="representation">representation</refterm>, <refterm
              primary="key">mapping keys</refterm> are unordered and <refterm
              primary="node">nodes</refterm> may be referenced more than once
              (have more than one incoming <quote>arrow</quote>), the
              serialization process is required to impose an <refterm
              primary="key" secondary="order">ordering</refterm> on the
              <refterm primary="key">mapping keys</refterm> and to replace the
              second and subsequent references to a given <refterm
              primary="node">node</refterm> with place holders called <refterm
              primary="alias">aliases</refterm>. YAML does not specify how
              these <defterm primary="serialization"
              secondary="detail">serialization details</defterm> are chosen. It
              is up to the YAML <refterm
              primary="processor">processor</refterm> to come up with
              human-friendly <refterm primary="key" secondary="order">key
              order</refterm> and <refterm primary="anchor">anchor</refterm>
              names, possibly with the help of the <refterm
              primary="application">application</refterm>. The result of this
              process, a YAML <refterm primary="serialization">serialization
              tree</refterm>, can then be traversed to produce a series of
              event calls for one-pass processing of YAML data.
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Presenting the Serialization Tree</term>

            <listitem>
              The final output process is <defterm
              primary="present">presenting</defterm> the YAML <refterm
              primary="serialization">serializations</refterm> as a character
              <refterm primary="stream">stream</refterm> in a human-friendly
              manner. To maximize human readability, YAML offers a rich set of
              stylistic options which go far beyond the minimal functional
              needs of simple data storage. Therefore the YAML <refterm
              primary="processor">processor</refterm> is required to introduce
              various <defterm primary="presentation"
              secondary="detail">presentation details</defterm> when creating
              the <refterm primary="stream">stream</refterm>, such as the
              choice of <refterm primary="style">node styles</refterm>, how to
              <refterm primary="scalar" secondary="content format">format
              scalar content</refterm>, the amount of <refterm primary="space"
              secondary="indentation">indentation</refterm>, which <refterm
              primary="tag" secondary="handle">tag handles</refterm> to use,
              the <refterm primary="tag">node tags</refterm> to leave <refterm
              primary="tag" secondary="non-specific">unspecified</refterm>, the
              set of <refterm primary="directive" >directives</refterm> to
              provide and possibly even what <refterm
              primary="comment">comments</refterm> to add. While some of this
              can be done with the help of the <refterm
              primary="application">application</refterm>, in general this
              process should be guided by the preferences of the user.
            </listitem>
          </varlistentry>
        </variablelist>
      </sect2>

      <sect2>
        <title>Load</title>

        <para>
          <defterm primary="load">Loading</defterm> <refterm primary="native
          data structure">native data structures</refterm> from a character
          <refterm primary="stream">stream</refterm> is done using the
          following three stages:
        </para>

        <variablelist>
          <varlistentry>
            <term>Parsing the Presentation Stream</term>

            <listitem>
              <defterm primary="parse">Parsing</defterm> is the inverse process
              of <refterm primary="present">presentation</refterm>, it takes a
              <refterm primary="stream">stream</refterm> of characters and
              produces a series of events. Parsing discards all the <refterm
              primary="presentation" secondary="detail">details</refterm>
              introduced in the <refterm
              primary="present">presentation</refterm> process, reporting only
              the <refterm primary="serialization">serialization</refterm>
              events. Parsing can fail due to <refterm primary="stream"
              secondary="ill-formed">ill-formed</refterm> input.
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Composing the Representation Graph</term>

            <listitem>
              <defterm primary="compose">Composing</defterm> takes a series of
              <refterm primary="serialization">serialization</refterm> events
              and produces a <refterm primary="representation">representation
              graph</refterm>. Composing discards all the <refterm
              primary="serialization" secondary="detail">details</refterm>
              introduced in the <refterm
              primary="serialize">serialization</refterm> process, producing
              only the <refterm primary="representation">representation
              graph</refterm>. Composing can fail due to any of several
              reasons, detailed <refterm primary="load" secondary="failure
              point">below</refterm>.
            </listitem>
          </varlistentry>
        </variablelist>

        <variablelist>
          <varlistentry>
            <term>Constructing Native Data Structures</term>

            <listitem>
              The final input process is <defterm
              primary="construct">constructing</defterm>&nbsp;<refterm
              primary="native data structure">native data structures</refterm>
              from the YAML <refterm
              primary="representation">representation</refterm>. Construction
              must be based only on the information available in the <refterm
              primary="representation">representation</refterm>, and not on
              additional <refterm
              primary="serialization">serialization</refterm> or <refterm
              primary="presentation" secondary="detail">presentation
              details</refterm> such as <refterm
              primary="comment">comments</refterm>, <refterm
              primary="directive">directives</refterm>, <refterm primary="key"
              secondary="order">mapping key order</refterm>, <refterm
              primary="style">node styles</refterm>, <refterm primary="scalar"
              secondary="content format">scalar content format</refterm>,
              <refterm primary="space"
              secondary="indentation">indentation</refterm> levels etc.
              Construction can fail due to the <refterm primary="tag"
              secondary="unavailable">unavailability</refterm> of the required
              <refterm primary="native data structure">native data
              types</refterm>.
            </listitem>
          </varlistentry>
        </variablelist>
      </sect2>
    </sect1>

    <pagebreak/>

    <sect1>
      <title>Information Models</title>

      <para>
        This section specifies the formal details of the results of the above
        processes. To maximize data portability between programming languages
        and implementations, users of YAML should be mindful of the distinction
        between <refterm primary="serialization">serialization</refterm> or
        <refterm primary="presentation">presentation</refterm> properties and
        those which are part of the YAML <refterm
        primary="representation">representation</refterm>. Thus, while imposing
        a <refterm primary="key" secondary="order">order</refterm> on <refterm
        primary="key">mapping keys</refterm> is necessary for flattening YAML
        <refterm primary="representation">representations</refterm> to a
        sequential access medium, this <refterm primary="serialization"
        secondary="detail">serialization detail</refterm> must not be used to
        convey <refterm primary="application">application</refterm> level
        information. In a similar manner, while <refterm primary="space"
        secondary="indentation">indentation</refterm> technique and a choice of
        a <refterm primary="style">node style</refterm> are needed for the
        human readability, these <refterm primary="presentation"
        secondary="detail">presentation details</refterm> are neither part of
        the YAML <refterm primary="serialization">serialization</refterm> nor
        the YAML <refterm primary="representation">representation</refterm>. By
        carefully separating properties needed for <refterm
        primary="serialization">serialization</refterm> and <refterm
        primary="presentation">presentation</refterm>, YAML <refterm
        primary="representation">representations</refterm> of <refterm
        primary="application">application</refterm> information will be
        consistent and portable between various programming environments.
      </para>

      <para>
        The following diagram summarizes the three <defterm
        primary="information model">information models</defterm>. Full arrows
        denote composition, hollow arrows denote inheritance,
        <uquote>1</uquote> and <uquote>*</uquote> denote <quote>one</quote> and
        <quote>many</quote> relationships. A single <uquote>+</uquote> denotes
        <refterm primary="serialization">serialization</refterm> details, a
        double <uquote>++</uquote> denotes <refterm
        primary="presentation">presentation</refterm> details.
      </para>

      <figure>
        <title>Information Models</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="model2.eps" format="eps"/>
          </imageobject>
        </mediaobject>
      </figure>

      <pagebreak/>

      <sect2>
        <title>Representation Graph</title>

        <para>
          YAML<q/>s <defterm primary="representation">representation</defterm>
          of <refterm primary="native data structure">native data
          structure</refterm> is a rooted, connected, directed graph of
          <refterm primary="tag">tagged</refterm> <refterm
          primary="node">nodes</refterm>. By <quote>directed graph</quote> we
          mean a set of <refterm primary="node">nodes</refterm> and directed
          edges (<quote>arrows</quote>), where each edge connects one <refterm
          primary="node">node</refterm> to another (see <ulink
          url="http://www.nist.gov/dads/HTML/directedGraph.html">a formal
          definition</ulink>). All the <refterm primary="node">nodes</refterm>
          must be reachable from the <defterm primary="node"
          secondary="root">root node</defterm> via such edges. Note that the
          YAML graph may include cycles, and a <refterm
          primary="node">node</refterm> may have more than one incoming edge.
        </para>

        <para>
          <refterm primary="node">Nodes</refterm> that are defined in terms of
          other <refterm primary="node">nodes</refterm> are <refterm
          primary="collection">collections</refterm>; <refterm
          primary="node">nodes</refterm> that are independent of any other
          <refterm primary="node">nodes</refterm> are <refterm
          primary="scalar">scalars</refterm>. YAML supports two <refterm
          primary="kind">kinds</refterm> of <refterm
          primary="collection">collection nodes</refterm>: <refterm
          primary="sequence">sequences</refterm> and <refterm
          primary="mapping">mappings</refterm>. <refterm
          primary="mapping">Mapping nodes</refterm> are somewhat tricky because
          their <refterm primary="key">keys</refterm> are unordered and must be
          <refterm primary="equality">unique</refterm>.
        </para>

        <figure>
          <title>Representation Model</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="represent2.eps" format="eps"/>
            </imageobject>
          </mediaobject>
        </figure>

        <sect3>
          <title>Nodes</title>

          <para>
            A YAML <defterm primary="node">node</defterm> <refterm
            primary="representation">represents</refterm> a single <refterm
            primary="native data structure">native data structure</refterm>.
            Such nodes have <defterm primary="content">content</defterm> of one
            of three <defterm primary="kind">kinds</defterm>: scalar, sequence,
            or mapping. In addition, each node has a <refterm
            primary="tag">tag</refterm> which serves to restrict the set of
            possible values the content can have.
          </para>

          <variablelist>
            <varlistentry>
              <term>Scalar</term>

              <listitem>
                The content of a <defterm primary="scalar">scalar</defterm>
                node is an opaque datum that can be <refterm
                primary="present">presented</refterm> as a series of zero or
                more Unicode characters.
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Sequence</term>

              <listitem>
                The content of a <defterm primary="sequence">sequence</defterm>
                node is an ordered series of zero or more nodes. In particular,
                a sequence may contain the same node more than once. It could
                even contain itself (directly or indirectly).
              </listitem>
            </varlistentry>
          </variablelist>

          <variablelist>
            <varlistentry>
              <term>Mapping</term>

              <listitem>
                The content of a <defterm primary="mapping">mapping</defterm>
                node is an unordered set of <defterm
                primary="key">key:</defterm>&nbsp;<defterm
                primary="value">value</defterm> node <defterm primary="key:
                value pair">pairs</defterm>, with the restriction that each of
                the keys is <refterm primary="equality">unique</refterm>. YAML
                places no further restrictions on the nodes. In particular,
                keys may be arbitrary nodes, the same node may be used as the
                value of several key:&nbsp;value pairs, and a mapping could
                even contain itself as a key or a value (directly or
                indirectly).
              </listitem>
            </varlistentry>
          </variablelist>

          <para>
            When appropriate, it is convenient to consider sequences and
            mappings together, as <defterm
            primary="collection">collections</defterm>. In this view, sequences
            are treated as mappings with integer keys starting at zero. Having
            a unified collections view for sequences and mappings is helpful
            both for theoretical analysis and for creating practical YAML tools
            and APIs. This strategy is also used by the Javascript programming
            language.
          </para>
        </sect3>

        <sect3>
          <title>Tags</title>

          <para>
            YAML <refterm primary="represent">represents</refterm> type
            information of <refterm primary="native data structure">native data
            structures</refterm> with a simple identifier, called a <defterm
            primary="tag">tag</defterm>. <defterm primary="tag"
            secondary="global">Global tags</defterm> are <ulink
            url="http://www.ietf.org/rfc/rfc2396.txt">URIs</ulink> and hence
            globally unique across all <refterm
            primary="application">applications</refterm>. The
            <uquote>tag:</uquote> <ulink
            url="http://www.faqs.org/rfcs/rfc4151.html">URI scheme</ulink> is
            recommended for all global YAML tags. In contrast, <defterm
            primary="tag" secondary="local">local tags</defterm> are specific
            to a single <refterm primary="application">application</refterm>.
            Local tags start with <defterm primary="! tag indicator"
            secondary="! local tag"><uquote>!</uquote></defterm>, are not URIs
            and are not expected to be globally unique. YAML provides a
            <refterm primary="directive" secondary="TAG"><uquote>TAG</uquote>
            directive</refterm> to make tag notation less verbose; it also
            offers easy migration from local to global tags. To ensure this,
            local tags are restricted to the URI character set and use URI
            character <refterm primary="% escaping in URI">escaping</refterm>.
          </para>

          <para>
            YAML does not mandate any special relationship between different
            tags that begin with the same substring. Tags ending with URI
            fragments (containing <uquote>#</uquote>) are no exception; tags
            that share the same base URI but differ in their fragment part are
            considered to be different, independent tags. By convention,
            fragments are used to identify different <quote>variants</quote> of
            a tag, while <uquote>/</uquote> is used to define nested tag
            <quote>namespace</quote> hierarchies. However, this is merely a
            convention, and each tag may employ its own rules. For example,
            Perl tags may use <uquote>::</uquote> to express namespace
            hierarchies, Java tags may use <uquote>.</uquote>, etc.
          </para>

          <para>
            YAML tags are used to associate meta information with each <refterm
            primary="node">node</refterm>. In particular, each tag must specify
            the expected <refterm primary="kind">node kind</refterm> (<refterm
            primary="scalar">scalar</refterm>, <refterm
            primary="sequence">sequence</refterm>, or <refterm
            primary="mapping">mapping</refterm>). <refterm
            primary="scalar">Scalar</refterm> tags must also provide a
            mechanism for converting <refterm primary="scalar"
            secondary="content format">formatted content</refterm> to a
            <refterm primary="scalar" secondary="canonical form">canonical
            form</refterm> for supporting <refterm
            primary="equality">equality</refterm> testing. Furthermore, a tag
            may provide additional information such as the set of allowed
            <refterm primary="content">content</refterm> values for validation,
            a mechanism for <refterm primary="tag" secondary="resolution">tag
            resolution</refterm>, or any other data that is applicable to all
            of the tag<q/>s <refterm primary="node">nodes</refterm>.
          </para>
        </sect3>

        <sect3>
          <title>Node Comparison</title>

          <variablelist>
            <varlistentry>
              <term>Equality</term>

              <listitem>
                <para>
                  Since YAML <refterm primary="mapping">mappings</refterm>
                  require <refterm primary="key">key</refterm> uniqueness,
                  <refterm primary="representation">representations</refterm>
                  must include a mechanism for testing the equality of <refterm
                  primary="node">nodes</refterm>. In general, it is impossible
                  to ensure uniqueness for <refterm
                  primary="presentation">presentations</refterm>, for the
                  following reasons:
                </para>

                <itemizedlist>
                  <listitem>
                    <para>
                      YAML allows various ways to <refterm primary="scalar"
                      secondary="content format">format scalar
                      content</refterm>. For example, the integer eleven can be
                      written as <uquote>0o13</uquote> (octal) or
                      <uquote>0xB</uquote> (hexadecimal). If both notations are
                      used as <refterm primary="key">keys</refterm> in the same
                      <refterm primary="mapping">mapping</refterm>, only a YAML
                      <refterm primary="processor">processor</refterm> which
                      recognizes integer <refterm primary="scalar"
                      secondary="content format">formats</refterm> would
                      correctly flag the duplicate <refterm
                      primary="key">key</refterm> as an error.
                    </para>
                  </listitem>

                  <listitem>
                    <para>
                      The semantics of the <refterm
                      primary="representation">representation</refterm> may
                      require that values with different <refterm
                      primary="tag">tags</refterm> be considered equal. For
                      example, the integer one and the float one are considered
                      equal. If both are used as <refterm
                      primary="key">keys</refterm> in the same <refterm
                      primary="mapping">mapping</refterm>, only a YAML <refterm
                      primary="processor">processor</refterm> which recognizes
                      integer and float <refterm
                      primary="representation">representations</refterm> would
                      correctly flag the duplicate <refterm
                      primary="key">key</refterm> as an error.
                    </para>
                  </listitem>
                </itemizedlist>

                <para>
                  YAML therefore requires that each <refterm
                  primary="tag">tag</refterm> must specify a mechanism for
                  testing any of its values for <defterm
                  primary="equality">equality</defterm> with any other value
                  (including values of any different <refterm
                  primary="tag">tag</refterm>). This is often implemented
                  directly by the <refterm primary="native data
                  structure">native data structure</refterm> instead of the
                  YAML <refterm primary="processor">processor</refterm>. That
                  is, duplicate <refterm primary="key">keys</refterm> are often
                  flagged as an error during the <refterm
                  primary="construct">construction</refterm> processing stage.
                </para>

                <para>
                  In order to ensure greater compatibility and clarity, YAML
                  allows the <refterm primary="processor">processor</refterm>
                  to flag obvious duplicate <refterm
                  primary="key">keys</refterm> based on the <refterm
                  primary="presentation">presentation</refterm>. Specifically,
                  two <refterm primary="scalar">scalar</refterm> <refterm
                  primary="key">keys</refterm> in the same <refterm
                  primary="mapping">mapping</refterm>, with the same <refterm
                  primary="tag">tag</refterm> and the same <refterm
                  primary="content">content</refterm>, may be flagged as an
                  error as soon as the <refterm
                  primary="parse">parsing</refterm> stage. Note that this tests
                  also works for <refterm primary="tag"
                  secondary="non-specific">non-specific tags</refterm> due to
                  the way that <refterm primary="tag"
                  secondary="resolution">tag resolution</refterm> is defined.
                  This allows a human reader to reasonably identify
                  <userinput>{ a: 1, a: 2 }</userinput> as an error. Such
                  constructs are silently accepted by many languages, but have
                  no well defined meaning, and are therefore disallowed in YAML
                  to avoid surprising behavior.
                </para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Canonical Form</term>

              <listitem>
                YAML also requires that every <refterm
                primary="scalar">scalar</refterm>&nbsp;<refterm
                primary="tag">tag</refterm> must specify a mechanism for
                producing the <defterm primary="scalar" secondary="canonical
                form">canonical form</defterm> of any <refterm primary="scalar"
                secondary="content format">formatted content</refterm>. This
                form is a Unicode character string which also <refterm
                primary="present">presents</refterm> the same <refterm
                primary="scalar" secondary="content format">content</refterm>.
                While this can be used for equality testing (as long as the
                compared values have the same <refterm
                primary="tag">tag</refterm>), it has other uses, such as the
                production of digital signatures.
              </listitem>
            </varlistentry>
          </variablelist>

          <pagebreak/>

          <variablelist>
            <varlistentry>
              <term>Identity</term>

              <listitem>
                <para>
                  Two <refterm primary="node">nodes</refterm> are <defterm
                  primary="identity">identical</defterm> only when they
                  <refterm primary="represent">represent</refterm> the same
                  <refterm primary="native data structure">native data
                  structure</refterm>. Typically, this corresponds to a single
                  memory address. Identity should not be confused with
                  equality; two equal <refterm primary="node">nodes</refterm>
                  need not have the same identity. A YAML <refterm
                  primary="processor">processor</refterm> may treat equal
                  <refterm primary="scalar">scalars</refterm> as if they were
                  identical. In contrast, the separate identity of two distinct
                  but equal <refterm primary="collection">collections</refterm>
                  must be preserved.
                </para>

                <para>
                  A common programming idiom is creating an empty object to
                  obtain a value that is only equal to itself (for example, in
                  order to generate a dynamic <quote>enumerated type</quote>).
                  The proper way to <refterm
                  primary="representation">represent</refterm> this in YAML
                  would be <userinput>!object {}</userinput>, where the
                  <userinput>!object</userinput> <refterm
                  primary="tag">tag</refterm> defines two objects to be equal
                  only if they are identical. The alternative <refterm
                  primary="scalar">scalar</refterm> <refterm
                  primary="representation">representation</refterm>
                  <userinput>!object ''</userinput> will not work as expected,
                  as the YAML <refterm primary="processor">processor</refterm>
                  is not required to preserve the identity of such objects.
                </para>
              </listitem>
            </varlistentry>
          </variablelist>
        </sect3>
      </sect2>

      <sect2>
        <title>Serialization Tree</title>

        <para>
          To express a YAML <refterm
          primary="representation">representation</refterm> using a serial API,
          it is necessary to impose an <refterm primary="key"
          secondary="order">order</refterm> on <refterm primary="key" >mapping
          keys</refterm> and employ <refterm primary="alias">alias
          nodes</refterm> to indicate a subsequent occurrence of a previously
          encountered <refterm primary="node">node</refterm>. The result of
          this process is a <defterm primary="serialization">serialization
          tree</defterm>, where each <refterm primary="node">node</refterm> has
          an ordered set of children. This tree can be traversed for a serial
          event-based API. <refterm primary="construct">Construction</refterm>
          of <refterm primary="native data structure">native data
          structures</refterm> from the serial interface should not use
          <refterm primary="key" secondary="order">key order</refterm> or
          <refterm primary="anchor">anchor names</refterm> for the preservation
          of <refterm primary="application">application</refterm> data.
        </para>

        <figure>
          <title>Serialization Model</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="serialize2.eps" format="eps"/>
            </imageobject>
          </mediaobject>
        </figure>

        <sect3>
          <title>Keys Order</title>

          <para>
            In the <refterm primary="representation">representation</refterm>
            model, <refterm primary="key">mapping keys</refterm> do not have an
            order. To <refterm primary="serialize">serialize</refterm> a
            <refterm primary="mapping">mapping</refterm>, it is necessary to
            impose an <defterm primary="key"
            secondary="order">ordering</defterm> on its <refterm primary="key"
            >keys</refterm>. This order is a <refterm primary="serialization"
            secondary="detail">serialization detail</refterm> and should not be
            used when <refterm primary="compose">composing</refterm> the
            <refterm primary="representation">representation graph</refterm>
            (and hence for the preservation of <refterm
            primary="application">application</refterm> data). In every case
            where <refterm primary="node">node</refterm> order is significant,
            a <refterm primary="sequence">sequence</refterm> must be used. For
            example, an ordered <refterm primary="mapping">mapping</refterm>
            can be <refterm primary="represent">represented</refterm> as a
            <refterm primary="sequence">sequence</refterm> of <refterm
            primary="mapping">mappings</refterm>, where each <refterm
            primary="mapping">mapping</refterm> is a single <refterm
            primary="key: value pair">key:&nbsp;value pair</refterm>. YAML
            provides convenient <refterm primary="style"
            secondary="single key:value pair mapping">compact notation</refterm> for
            this case.
          </para>
        </sect3>

        <sect3>
          <title>Anchors and Aliases</title>

          <para>
            In the <refterm primary="representation">representation
            graph</refterm>, a <refterm primary="node">node</refterm> may
            appear in more than one <refterm
            primary="collection">collection</refterm>. When <refterm
            primary="serialize">serializing</refterm> such data, the first
            occurrence of the <refterm primary="node">node</refterm> is
            <defterm primary="alias"
            secondary="identified">identified</defterm> by an <defterm
            primary="anchor">anchor</defterm>. Each subsequent occurrence is
            <refterm primary="serialize">serialized</refterm> as an <refterm
            primary="alias">alias node</refterm> which refers back to this
            anchor. Otherwise, anchor names are a <refterm
            primary="serialization" secondary="detail">serialization
            detail</refterm> and are discarded once <refterm
            primary="compose">composing</refterm> is completed. When <refterm
            primary="compose">composing</refterm> a <refterm
            primary="representation">representation graph</refterm> from
            <refterm primary="serialize">serialized</refterm> events, an alias
            node refers to the most recent <refterm
            primary="node">node</refterm> in the <refterm
            primary="serialization">serialization</refterm> having the
            specified anchor. Therefore, anchors need not be unique within a
            <refterm primary="serialization">serialization</refterm>. In
            addition, an anchor need not have an alias node referring to it. It
            is therefore possible to provide an anchor for all <refterm
            primary="node">nodes</refterm> in <refterm
            primary="serialization">serialization</refterm>.
          </para>
        </sect3>
      </sect2>

      <sect2>
        <title>Presentation Stream</title>

        <para>
          A YAML <defterm primary="presentation">presentation</defterm> is a
          <refterm primary="stream">stream</refterm> of Unicode characters
          making use of <refterm primary="style">styles</refterm>, <refterm
          primary="scalar" secondary="content format">scalar content
          formats</refterm>, <refterm primary="comment" >comments</refterm>,
          <refterm primary="directive">directives</refterm> and other <refterm
          primary="presentation" secondary="detail">presentation
          details</refterm> to <refterm primary="present">present</refterm> a
          YAML <refterm primary="serialization">serialization</refterm> in a
          human readable way. Although a YAML <refterm
          primary="processor">processor</refterm> may provide these <refterm
          primary="presentation" secondary="detail">details</refterm> when
          <refterm primary="parse">parsing</refterm>, they should not be
          reflected in the resulting <refterm
          primary="serialization">serialization</refterm>. YAML allows several
          <refterm primary="serialization">serialization trees</refterm> to be
          contained in the same YAML character stream, as a series of <refterm
          primary="document">documents</refterm> separated by <refterm
          primary="marker">markers</refterm>. Documents appearing in the same
          stream are independent; that is, a <refterm
          primary="node">node</refterm> must not appear in more than one
          <refterm primary="serialization">serialization tree</refterm> or
          <refterm primary="representation">representation graph</refterm>.
        </para>

        <figure>
          <title>Presentation Model</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="present2.eps" format="eps"/>
            </imageobject>
          </mediaobject>
        </figure>

        <pagebreak/>

        <sect3>
          <title>Node Styles</title>

          <para>
            Each <refterm primary="node">node</refterm> is presented in some
            <defterm primary="style">style</defterm>, depending on its <refterm
            primary="kind">kind</refterm>. The node style is a <refterm
            primary="presentation" secondary="detail">presentation
            detail</refterm> and is not reflected in the <refterm
            primary="serialization">serialization tree</refterm> or <refterm
            primary="representation">representation graph</refterm>. There are
            two groups of styles. <refterm primary="style"
            secondary="block">Block styles</refterm> use <refterm
            primary="space" secondary="indentation">indentation</refterm> to
            denote structure; in contrast, <refterm primary="style"
            secondary="flow">flow styles</refterm> rely on explicit
            <refterm primary="indicator">indicators</refterm>.
          </para>

          <para>
            YAML provides a rich set of <defterm primary="style"
            secondary="scalar">scalar styles</defterm>. <refterm
            primary="style" secondary="block" tertiary="scalar">Block
            scalar</refterm> styles include the <refterm primary="style"
            secondary="block" tertiary="literal">literal style</refterm> and
            the <refterm primary="style" secondary="block"
            tertiary="folded">folded style</refterm>. <refterm primary="style"
            secondary="flow" tertiary="scalar">Flow scalar</refterm> styles
            include the <refterm primary="style" secondary="flow"
            tertiary="plain">plain style</refterm> and two quoted styles, the
            <refterm primary="style" secondary="flow"
            tertiary="single-quoted">single-quoted style</refterm> and the
            <refterm primary="style" secondary="flow"
            tertiary="double-quoted">double-quoted style</refterm>. These
            styles offer a range of trade-offs between expressive power and
            readability.
          </para>

          <para>
            Normally, <refterm primary="style" secondary="block"
            tertiary="sequence">block sequences</refterm> and <refterm
            primary="style" secondary="block"
            tertiary="mapping">mappings</refterm> begin on the next line. In
            some cases, YAML also allows nested <refterm primary="style"
            secondary="block">block</refterm> <refterm
            primary="collection">collections</refterm> to start in-line for a
            more <refterm primary="style" secondary="compact block collection">compact
            notation</refterm>. In addition, YAML provides a <refterm
            primary="style" secondary="single key:value pair mapping">compact
            notation</refterm> for <refterm primary="style" secondary="flow"
            tertiary="mapping">flow mappings</refterm> with a single <refterm
            primary="key: value pair">key:&nbsp;value pair</refterm>, nested
            inside a <refterm primary="style" secondary="flow"
            tertiary="sequence">flow sequence</refterm>. These allow for a
            natural <quote>ordered mapping</quote> notation.
          </para>

          <figure>
            <title>Kind/Style Combinations</title>
            <mediaobject>
              <imageobject>
                <imagedata fileref="styles2.eps" format="eps"/>
              </imageobject>
            </mediaobject>
          </figure>
        </sect3>

        <sect3>
          <title>Scalar Formats</title>

          <para>
            YAML allows <refterm primary="scalar">scalars</refterm> to be
            <refterm primary="present">presented</refterm> in several <defterm
            primary="scalar" secondary="content format">formats</defterm>. For
            example, the integer <uquote>11</uquote> might also be written as
            <uquote>0xB</uquote>. <refterm primary="tag">Tags</refterm> must
            specify a mechanism for converting the formatted content to a
            <refterm primary="scalar" secondary="canonical form">canonical
            form</refterm> for use in <refterm
            primary="equality">equality</refterm> testing. Like <refterm
            primary="style">node style</refterm>, the format is a <refterm
            primary="presentation" secondary="detail">presentation
            detail</refterm> and is not reflected in the <refterm
            primary="serialization">serialization tree</refterm> and <refterm
            primary="representation">representation graph</refterm>.
          </para>
        </sect3>

        <sect3>
          <title>Comments</title>

          <para>
            <refterm primary="comment">Comments</refterm> are a <refterm
            primary="presentation" secondary="detail">presentation
            detail</refterm> and must not have any effect on the <refterm
            primary="serialization">serialization tree</refterm> or <refterm
            primary="representation">representation graph</refterm>. In
            particular, comments are not associated with a particular <refterm
            primary="node">node</refterm>. The usual purpose of a comment is to
            communicate between the human maintainers of a file. A typical
            example is comments in a configuration file. Comments must not
            appear inside <refterm primary="scalar">scalars</refterm>, but may
            be interleaved with such <refterm
            primary="scalar">scalars</refterm> inside <refterm
            primary="collection">collections</refterm>.
          </para>
        </sect3>

        <sect3>
          <title>Directives</title>

          <para>
            Each <refterm primary="document">document</refterm> may be
            associated with a set of <refterm
            primary="directive">directives</refterm>. A directive has a name
            and an optional sequence of parameters. Directives are instructions
            to the YAML <refterm primary="processor">processor</refterm>, and
            like all other <refterm primary="presentation"
            secondary="detail">presentation details</refterm> are not reflected
            in the YAML <refterm primary="serialization">serialization
            tree</refterm> or <refterm primary="representation">representation
            graph</refterm>. This version of YAML defines two directives,
            <refterm primary="directive"
            secondary="YAML"><uquote>YAML</uquote></refterm> and <refterm
            primary="directive" secondary="TAG"><uquote>TAG</uquote></refterm>.
            All other directives are <refterm primary="directive"
            secondary="reserved">reserved</refterm> for future versions of
            YAML.
          </para>
        </sect3>
      </sect2>
    </sect1>

    <pagebreak/>

    <sect1>
      <title>Loading Failure Points</title>

      <para>
        The process of <refterm primary="load">loading</refterm> <refterm
        primary="native data structure">native data structures</refterm> from a
        YAML <refterm primary="stream">stream</refterm> has several potential
        <defterm primary="load" secondary="failure point">failure
        points</defterm>. The character <refterm
        primary="stream">stream</refterm> may be <refterm primary="stream"
        secondary="ill-formed">ill-formed</refterm>, <refterm
        primary="alias">aliases</refterm> may be <refterm primary="alias"
        secondary="unidentified">unidentified</refterm>, <refterm primary="tag"
        secondary="non-specific">unspecified tags</refterm> may be <refterm
        primary="tag" secondary="unresolved">unresolvable</refterm>, <refterm
        primary="tag">tags</refterm> may be <refterm primary="tag"
        secondary="unrecognized">unrecognized</refterm>, the <refterm
        primary="content">content</refterm> may be <refterm primary="invalid
        content">invalid</refterm>, and a native type may be <refterm
        primary="tag" secondary="unavailable">unavailable</refterm>. Each of
        these failures results with an incomplete loading.
      </para>

      <para>
        A <defterm primary="representation" secondary="partial">partial
        representation</defterm> need not <refterm primary="tag"
        secondary="resolution">resolve</refterm> the <refterm primary="tag"
        >tag</refterm> of each <refterm primary="node">node</refterm>, and the
        <refterm primary="scalar" secondary="canonical form">canonical
        form</refterm> of <refterm primary="scalar" secondary="content
        format">formatted scalar content</refterm> need not be available. This
        weaker representation is useful for cases of incomplete knowledge of
        the types used in the <refterm primary="document">document</refterm>.
        In contrast, a <defterm primary="representation"
        secondary="complete">complete representation</defterm> specifies the
        <refterm primary="tag">tag</refterm> of each <refterm
        primary="node">node</refterm>, and provides the <refterm
        primary="scalar" secondary="canonical form">canonical form</refterm> of
        <refterm primary="scalar" secondary="content format">formatted scalar
        content</refterm>, allowing for <refterm
        primary="equality">equality</refterm> testing. A complete
        representation is required in order to <refterm
        primary="construct">construct</refterm> <refterm primary="native data
        structure">native data structures</refterm>.
      </para>

      <figure>
        <title>Loading Failure Points</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="validity2.eps" format="eps"/>
          </imageobject>
        </mediaobject>
      </figure>

      <sect2>
        <title>Well-Formed Streams and Identified Aliases</title>
        <para>
          A <refterm primary="stream"
          secondary="well-formed">well-formed</refterm> character <refterm
          primary="stream">stream</refterm> must match the BNF productions
          specified in the following chapters. Successful loading also requires
          that each <refterm primary="alias">alias</refterm> shall refer to a
          previous <refterm primary="node">node</refterm> <refterm
          primary="alias" secondary="identified">identified</refterm> by the
          <refterm primary="anchor">anchor</refterm>. A YAML <refterm
          primary="processor">processor</refterm> should reject <defterm
          primary="stream" secondary="ill-formed">ill-formed streams</defterm>
          and <defterm primary="alias" secondary="unidentified">unidentified
          aliases</defterm>. A YAML <refterm
          primary="processor">processor</refterm> may recover from syntax
          errors, possibly by ignoring certain parts of the input, but it must
          provide a mechanism for reporting such errors.
        </para>
      </sect2>

      <pagebreak/>

      <sect2>
        <title>Resolved Tags</title>

        <para>
          Typically, most <refterm primary="tag">tags</refterm> are not
          explicitly specified in the character <refterm
          primary="stream">stream</refterm>. During <refterm
          primary="parse">parsing</refterm>, <refterm
          primary="node">nodes</refterm> lacking an explicit <refterm
          primary="tag">tag</refterm> are given a <defterm primary="tag"
          secondary="non-specific">non-specific tag</defterm>: <defterm
          primary="! tag indicator" secondary="! non-specific
          tag"><uquote>!</uquote></defterm> for non-<refterm primary="style"
          secondary="flow" tertiary="plain">plain scalars</refterm>, and
          <defterm primary="? non-specific tag"><uquote>?</uquote></defterm>
          for all other <refterm primary="node">nodes</refterm>. <refterm
          primary="compose">Composing</refterm> a <refterm
          primary="representation" secondary="complete">complete
          representation</refterm> requires each such non-specific tag to be
          <defterm primary="tag" secondary="resolution">resolved</defterm> to a
          <defterm primary="tag" secondary="specific">specific tag</defterm>,
          be it a <refterm primary="tag" secondary="global">global
          tag</refterm> or a <refterm primary="tag" secondary="local">local
          tag</refterm>.
        </para>

        <para>
          Resolving the <refterm primary="tag">tag</refterm> of a <refterm
          primary="node">node</refterm> must only depend on the following three
          parameters: (1) the non-specific tag of the <refterm
          primary="node">node</refterm>, (2) the path leading from the <refterm
          primary="node" secondary="root">root</refterm> to the <refterm
          primary="node">node</refterm>, and (3) the <refterm
          primary="content">content</refterm> (and hence the <refterm
          primary="kind">kind</refterm>) of the <refterm
          primary="node">node</refterm>. When a <refterm
          primary="node">node</refterm> has more than one occurrence (using
          <refterm primary="alias">aliases</refterm>), tag resolution must
          depend only on the path to the first (<refterm
          primary="anchor">anchored</refterm>) occurrence of the <refterm
          primary="node">node</refterm>.
        </para>

        <para>
          Note that resolution must not consider <refterm
          primary="presentation" secondary="detail">presentation
          details</refterm> such as <refterm
          primary="comment">comments</refterm>, <refterm primary="space"
          secondary="indentation">indentation</refterm> and <refterm
          primary="style">node style</refterm>. Also, resolution must not
          consider the <refterm primary="content">content</refterm> of any
          other <refterm primary="node">node</refterm>, except for the <refterm
          primary="content">content</refterm> of the <refterm primary="key">key
          nodes</refterm> directly along the path leading from the <refterm
          primary="node" secondary="root">root</refterm> to the resolved
          <refterm primary="node" >node</refterm>. Finally, resolution must not
          consider the <refterm primary="content">content</refterm> of a
          sibling <refterm primary="node">node</refterm> in a <refterm
          primary="collection">collection</refterm>, or the <refterm
          primary="content">content</refterm> of the <refterm
          primary="value">value node</refterm> associated with a <refterm
          primary="key">key node</refterm> being resolved.
        </para>

        <para>
          These rules ensure that tag resolution can be performed as soon as a
          <refterm primary="node">node</refterm> is first encountered in the
          <refterm primary="stream">stream</refterm>, typically before its
          <refterm primary="content">content</refterm> is <refterm
          primary="parse">parsed</refterm>. Also, tag resolution only requires
          referring to a relatively small number of previously parsed <refterm
          primary="node">nodes</refterm>. Thus, in most cases, tag resolution
          in one-pass <refterm primary="processor">processors</refterm> is both
          possible and practical.
        </para>

        <para>
          YAML <refterm primary="processor">processors</refterm> should resolve
          <refterm primary="node">nodes</refterm> having the <uquote>!</uquote>
          non-specific tag as <uquote>tag:yaml.org,2002:seq</uquote>,
          <uquote>tag:yaml.org,2002:map</uquote> or
          <uquote>tag:yaml.org,2002:str</uquote> depending on their <refterm
          primary="kind">kind</refterm>. This <defterm primary="tag"
          secondary="resolution" tertiary="convention">tag resolution
          convention</defterm> allows the author of a YAML character <refterm
          primary="stream">stream</refterm> to effectively
          <quote>disable</quote> the tag resolution process. By explicitly
          specifying a <uquote>!</uquote> non-specific <refterm primary="tag"
          secondary="property">tag property</refterm>, the <refterm
          primary="node">node</refterm> would then be resolved to a
          <quote>vanilla</quote> <refterm
          primary="sequence">sequence</refterm>, <refterm
          primary="mapping">mapping</refterm>, or string, according to its
          <refterm primary="kind">kind</refterm>.
        </para>

        <para>
          <refterm primary="application">Application</refterm> specific tag
          resolution rules should be restricted to resolving the
          <uquote>?</uquote> non-specific tag, most commonly to resolving
          <refterm primary="style" secondary="flow" tertiary="plain">plain
          scalars</refterm>. These may be matched against a set of regular
          expressions to provide automatic resolution of integers, floats,
          timestamps, and similar types. An <refterm
          primary="application">application</refterm> may also match the
          <refterm primary="content">content</refterm> of <refterm
          primary="mapping">mapping nodes</refterm> against sets of expected
          <refterm primary="key">keys</refterm> to automatically resolve
          points, complex numbers, and similar types. Resolved <refterm
          primary="sequence">sequence node</refterm> types such as the
          <quote>ordered mapping</quote> are also possible.
        </para>

        <para>
          That said, tag resolution is specific to the <refterm
          primary="application">application</refterm>. YAML <refterm
          primary="processor">processors</refterm> should therefore provide a
          mechanism allowing the <refterm
          primary="application">application</refterm> to override and expand
          these default tag resolution rules.
        </para>

        <para>
          If a <refterm primary="document">document</refterm> contains <defterm
          primary="tag" secondary="unresolved">unresolved tags</defterm>, the
          YAML <refterm primary="processor">processor</refterm> is unable to
          <refterm primary="compose">compose</refterm> a <refterm
          primary="representation" secondary="complete">complete
          representation</refterm> graph. In such a case, the YAML <refterm
          primary="processor">processor</refterm> may <refterm
          primary="compose">compose</refterm> a <refterm
          primary="representation" secondary="partial">partial
          representation</refterm>, based on each <refterm
          primary="kind">node<q/>s kind</refterm> and allowing for non-specific
          tags.
        </para>
      </sect2>

      <sect2>
        <title>Recognized and Valid Tags</title>

        <para>
          To be <defterm primary="content" secondary="valid">valid</defterm>, a
          <refterm primary="node">node</refterm> must have a <refterm
          primary="tag">tag</refterm> which is <defterm primary="tag"
          secondary="recognized">recognized</defterm> by the YAML <refterm
          primary="processor">processor</refterm> and its <refterm
          primary="content">content</refterm> must satisfy the constraints
          imposed by this <refterm primary="tag">tag</refterm>. If a <refterm
          primary="document">document</refterm> contains a <refterm
          primary="scalar">scalar node</refterm> with an <defterm primary="tag"
          secondary="unrecognized">unrecognized tag</defterm> or <defterm
          primary="invalid content">invalid content</defterm>, only a <refterm
          primary="representation" secondary="partial">partial
          representation</refterm> may be <refterm
          primary="compose">composed</refterm>. In contrast, a YAML <refterm
          primary="processor">processor</refterm> can always <refterm
          primary="compose">compose</refterm> a <refterm
          primary="representation" secondary="complete">complete
          representation</refterm> for an unrecognized or an invalid <refterm
          primary="collection">collection</refterm>, since <refterm
          primary="collection">collection</refterm> <refterm
          primary="equality">equality</refterm> does not depend upon knowledge
          of the <refterm primary="collection">collection<q/>s</refterm> data
          type. However, such a <refterm primary="representation"
          secondary="complete">complete representation</refterm> cannot be
          used to <refterm primary="construct">construct</refterm> a <refterm
          primary="native data structure">native data structure</refterm>.
        </para>
      </sect2>

      <sect2>
        <title>Available Tags</title>

        <para>
          In a given processing environment, there need not be an <defterm
          primary="tag" secondary="available">available</defterm> native type
          corresponding to a given <refterm primary="tag">tag</refterm>. If a
          <refterm primary="tag">node<q/>s tag</refterm> is <defterm
          primary="tag" secondary="unavailable">unavailable</defterm>, a YAML
          <refterm primary="processor">processor</refterm> will not be able to
          <refterm primary="construct">construct</refterm> a <refterm
          primary="native data structure">native data structure</refterm> for
          it. In this case, a <refterm primary="representation"
          secondary="complete">complete representation</refterm> may still be
          <refterm primary="compose">composed</refterm>, and an <refterm
          primary="application">application</refterm> may wish to use this
          <refterm primary="representation">representation</refterm> directly.
        </para>
      </sect2>
    </sect1>
  </chapter>

  <chapter id="Syntax">
    <title>Syntax Conventions</title>

    <para>
      The following chapters formally define the syntax of YAML character
      <refterm primary="stream">streams</refterm>, using parameterized BNF
      productions. Each BNF production is both named and numbered for easy
      reference. Whenever possible, basic structures are specified before the
      more complex structures using them in a <quote>bottom up</quote> fashion.
    </para>

    <para>
      The order of alternatives inside a production is significant. Subsequent
      alternatives are only considered when previous ones fails. See for
      example the <nonterminal
      def="#b-break"><userinput>b-break</userinput></nonterminal> production.
      In addition, production matching is expected to be greedy. Optional
      (<userinput>?</userinput>), zero-or-more (<userinput>*</userinput>) and
      one-or-more (<userinput>+</userinput>) patterns are always expected to
      match as much of the input as possible.
    </para>

    <para>
      The productions are accompanied by examples, which are given side-by-side
      next to equivalent YAML text in an explanatory format. This format uses
      only <refterm primary="style" secondary="flow" tertiary="collection">flow
      collections</refterm>, <refterm primary="style" secondary="flow"
      tertiary="double-quoted">double-quoted scalars</refterm>, and explicit
      <refterm primary="tag">tags</refterm> for each <refterm
      primary="node">node</refterm>.
    </para>

    <para>
      A reference implementation using the productions is available as the
      <ulink
      url="http://hackage.haskell.org/cgi-bin/hackage-scripts/package/YamlReference"
      >YamlReference</ulink> Haskell package. This reference implementation is
      also available as an interactive web application at <ulink
      url="http://dev.yaml.org/ypaste"/>.
    </para>

    <sect1>
      <title>Production Parameters</title>

      <para>
        YAML<q/>s syntax is designed for maximal human readability. This
        requires <refterm primary="parse">parsing</refterm> to depend on the
        surrounding text. For notational compactness, this dependency is
        expressed using parameterized BNF productions.
      </para>

      <para>
        This context sensitivity is the cause of most of the complexity of the
        YAML syntax definition. It is further complicated by struggling with
        the human tendency to look ahead when interpreting text. These
        complications are of course the source of most of YAML<q/>s power to
        <refterm primary="presentation">present</refterm> data in a very human
        readable way.
      </para>

      <para>
        Productions use any of the following parameters:
      </para>

      <variablelist termlength="15">
        <varlistentry>
          <term>
            Indentation: <varname>n</varname> or <varname>m</varname>
          </term>

          <listitem>
            Many productions use an explicit <refterm primary="space"
            secondary="indentation">indentation</refterm> level parameter. This
            is less elegant than Python<q/>s <quote>indent</quote> and
            <quote>undent</quote> conceptual tokens. However it is required to
            formally express YAML<q/>s indentation rules.
          </listitem>
        </varlistentry>
      </variablelist>

      <variablelist termlength="15">
        <varlistentry>
          <term>Context: <varname>c</varname></term>

          <listitem>
            <para>
              This parameter allows productions to tweak their behavior
              according to their surrounding. YAML supports two groups of
              <defterm primary="context">contexts</defterm>, distinguishing
              between <refterm primary="style" secondary="block">block
              styles</refterm> and <refterm primary="style"
              secondary="flow">flow styles</refterm>.
            </para>

            <para>
              In <refterm primary="style" secondary="block">block
              styles</refterm>, <refterm primary="space"
              secondary="indentation">indentation</refterm> is used to
              delineate structure. To capture human perception of <refterm
              primary="space" secondary="indentation">indentation</refterm> the
              rules require special treatment of the <refterm primary="- block
              sequence entry"><uquote>-</uquote></refterm> character, used in
              <refterm primary="style" secondary="block"
              tertiary="sequence">block sequences</refterm>. Hence in some
              cases productions need to behave differently inside <refterm
              primary="style" secondary="block" tertiary="sequence">block
              sequences</refterm> (<defterm primary="context"
              secondary="block-in">block-in context</defterm>) and outside them
              (<defterm primary="context" secondary="block-out">block-out
              context</defterm>).
            </para>

            <para>
              In <refterm primary="style" secondary="flow">flow
              styles</refterm>, explicit <refterm
              primary="indicator">indicators</refterm> are used to delineate
              structure. These styles can be viewed as the natural extension of
              JSON to cover <refterm primary="tag">tagged</refterm>, <refterm
              primary="style" secondary="flow"
              tertiary="single-quoted">single-quoted</refterm> and <refterm
              primary="style" secondary="flow" tertiary="plain">plain
              scalars</refterm>. Since the latter have no delineating <refterm
              primary="indicator">indicators</refterm>, they are subject to
              some restrictions to avoid ambiguities. These restrictions depend
              on where they appear: as implicit keys directly inside a <refterm
              primary="style" secondary="block" tertiary="mapping">block
              mapping</refterm> (<defterm primary="context"
              secondary="block-key">block-key</defterm>); as implicit keys
              inside a <refterm primary="style" secondary="flow"
              tertiary="mapping">flow mapping</refterm> (<defterm
              primary="context" secondary="flow-key">flow-key</defterm>); as
              values inside a <refterm primary="style" secondary="flow"
              tertiary="collection">flow collection</refterm> (<defterm
              primary="context" secondary="flow-in">flow-in</defterm>); or as
              values outside one (<defterm primary="context"
              secondary="flow-out">flow-out</defterm>).
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>(Block) Chomping: <varname>t</varname></term>

          <listitem>
            Block scalars offer three possible mechanisms for <refterm
            primary="chomping">chomping</refterm> any trailing <refterm
            primary="line break">line breaks</refterm>: <refterm
            primary="chomping" secondary="strip">strip</refterm>, <refterm
            primary="chomping" secondary="clip">clip</refterm> and <refterm
            primary="chomping" secondary="keep">keep</refterm>. Unlike the
            previous parameters, this only controls interpretation; the
            <refterm primary="line break">line breaks</refterm> are valid in
            all cases.
          </listitem>
        </varlistentry>
      </variablelist>
    </sect1>

    <pagebreak/>

    <sect1>
      <title>Production Naming Conventions</title>

      <para>
        To make it easier to follow production combinations, production names
        use a Hungarian-style naming convention. Each production is given a
        prefix based on the type of characters it begins and ends with.
      </para>

      <variablelist>
        <varlistentry>
          <term><userinput>e-</userinput></term>

          <listitem>
            A production matching no characters.
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><userinput>c-</userinput></term>

          <listitem>
            A production starting and ending with a special character.
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><userinput>b-</userinput></term>

          <listitem>
            A production matching a single <refterm primary="line break">line
            break</refterm>.
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><userinput>nb-</userinput></term>

          <listitem>
            A production starting and ending with a non-<refterm primary="line
            break">break</refterm> character.
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><userinput>s-</userinput></term>

          <listitem>
            A production starting and ending with a <refterm primary="space"
            secondary="white">white space</refterm> character.
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><userinput>ns-</userinput></term>

          <listitem>
            A production starting and ending with a non-<refterm
            primary="space" secondary="white">space</refterm> character.
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><userinput>l-</userinput></term>

          <listitem>
            A production matching complete line(s).
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <varname>X</varname><userinput>-</userinput
            ><varname>Y</varname><userinput>-</userinput>
          </term>

          <listitem>
            A production starting with an
            <varname>X</varname><userinput>-</userinput> character and ending
            with a <varname>Y</varname><userinput>-</userinput> character,
            where <varname>X</varname><userinput>-</userinput> and
            <varname>Y</varname><userinput>-</userinput> are any of the above
            prefixes.
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <varname>X</varname><userinput>+</userinput>,
            <varname>X</varname><userinput>-</userinput
            ><varname>Y</varname><userinput>+</userinput>
          </term>

          <listitem>
            A production as above, with the additional property that the
            matched content <refterm primary="space"
            secondary="indentation">indentation</refterm> level is greater than
            the specified <varname>n</varname> parameter.
          </listitem>
        </varlistentry>
      </variablelist>
    </sect1>
  </chapter>

  <chapter id="Characters">
    <title>Characters</title>

    <sect1>
      <title>Character Set</title>

      <para>
        To ensure readability, YAML <refterm primary="stream">streams</refterm>
        use only the <defterm primary="printable character">printable</defterm>
        subset of the Unicode character set. The allowed character range
        explicitly excludes the C0 control block
        <userinput>#x0-#x1F</userinput> (except for TAB
        <userinput>#x9</userinput>, LF <userinput>#xA</userinput>, and CR
        <userinput>#xD</userinput> which are allowed), DEL
        <userinput>#x7F</userinput>, the C1 control block
        <userinput>#x80-#x9F</userinput> (except for NEL
        <userinput>#x85</userinput> which is allowed), the surrogate block
        <userinput>#xD800-#xDFFF</userinput>, <userinput>#xFFFE</userinput>,
        and <userinput>#xFFFF</userinput>.
      </para>

      <para>
        On input, a YAML <refterm primary="processor">processor</refterm> must
        accept all Unicode characters except those explicitly excluded above.
      </para>

      <para>
        On output, a YAML <refterm primary="processor">processor</refterm> must
        only produce acceptable characters. Any excluded characters must be
        <refterm primary="present">presented</refterm> using <refterm
        primary="escaping" secondary="in double-quoted
        scalars">escape</refterm> sequences. In addition, any allowed
        characters known to be non-printable should also be <refterm
        primary="escaping" secondary="in double-quoted
        scalars">escaped</refterm>. This isn<q/>t mandatory since a full
        implementation would require extensive character property tables.
      </para>

      <productionset>
        <production id="c-printable">
          <lhs>c-printable</lhs>
          <rhs>
            &nbsp;&nbsp;#x9 | #xA | #xD | [#x20-#x7E]&nbsp;&nbsp;&nbsp;
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* 8 bit */<sbr/>
            | #x85 | [#xA0-#xD7FF] | [#xE000-#xFFFD] /* 16 bit */<sbr/>
            | [#x10000-#x10FFFF]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            &nbsp;&nbsp;&nbsp;&nbsp;/* 32 bit */
          </rhs>
        </production>
      </productionset>

      <para>
        To ensure <refterm primary="JSON compatibility">JSON
        compatibility</refterm>, YAML <refterm
        primary="processor">processors</refterm> must allow all non-control
        characters inside <refterm primary="style" secondary="flow"
        tertiary="double-quoted">quoted scalars</refterm>. To ensure
        readability, non-printable characters should be <refterm
        primary="escaping" secondary="in double-quoted
        scalars">escaped</refterm> on output, even inside such <refterm
        primary="style" secondary="flow"
        tertiary="double-quoted">scalars</refterm>. Note that JSON <refterm
        primary="style" secondary="flow" tertiary="double-quoted">quoted
        scalars</refterm> cannot span multiple lines or contain <refterm
        primary="tab">tabs</refterm>, but YAML <refterm primary="style"
        secondary="flow" tertiary="double-quoted">quoted scalars</refterm> can.
      </para>

      <productionset>
        <production id="nb-json">
          <lhs>nb-json</lhs>
          <rhs>
            #x9 | [#x20-#x10FFFF]
          </rhs>
        </production>
      </productionset>
    </sect1>

    <sect1>
      <title>Character Encodings</title>

      <para>
        All characters mentioned in this specification are Unicode code points.
        Each such code point is written as one or more bytes depending on the
        <defterm primary="character encoding">character encoding</defterm>
        used. Note that in UTF-16, characters above
        <userinput>#xFFFF</userinput> are written as four bytes, using a
        surrogate pair.
      </para>

      <para>
        The character encoding is a <refterm primary="presentation"
        secondary="detail">presentation detail</refterm> and must not be used
        to convey <refterm primary="content">content</refterm> information.
      </para>

      <para>
        On input, a YAML <refterm primary="processor">processor</refterm> must
        support the UTF-8 and UTF-16 character encodings. For <refterm
        primary="JSON compatibility">JSON compatibility</refterm>, the UTF-32
        encodings must also be supported.
      </para>

      <para>
        If a character <refterm primary="stream">stream</refterm> begins with a
        <defterm primary="byte order mark">byte order mark</defterm>, the
        character encoding will be taken to be as indicated by the byte
        order mark. Otherwise, the <refterm primary="stream">stream</refterm>
        must begin with an ASCII character. This allows the encoding to be
        deduced by the pattern of null (<userinput>#x00</userinput>)
        characters.
      </para>

      <para>
        To make it easier to concatenate <refterm
        primary="stream">streams</refterm>, byte order marks may appear at the
        start of any <refterm primary="document">document</refterm>. However
        all <refterm primary="document">documents</refterm> in the same
        <refterm primary="stream">stream</refterm> must use the same character
        encoding.
      </para>

      <para>
        To allow for <refterm primary="JSON compatibility">JSON
        compatibility</refterm>, byte order marks are also allowed inside
        <refterm primary="style" secondary="flow"
        tertiary="double-quoted">quoted scalars</refterm>. For readability,
        such <refterm primary="content">content</refterm> byte order marks
        should be <refterm primary="escaping" secondary="in double-quoted
        scalars">escaped</refterm> on output.
      </para>

      <pagebreak/>

      <para>
        The encoding can therefore be deduced by matching the first few bytes
        of the <refterm primary="stream">stream</refterm> with the following
        table rows (in order):
      </para>

      <informaltable>
        <tgroup cols="6">
          <tbody>
            <row>
              <entry></entry>
              <entry>&nbsp;<emphasis>Byte0&nbsp;</emphasis></entry>
              <entry>&nbsp;<emphasis>Byte1&nbsp;</emphasis></entry>
              <entry>&nbsp;<emphasis>Byte2&nbsp;</emphasis></entry>
              <entry>&nbsp;<emphasis>Byte3&nbsp;</emphasis></entry>
              <entry>&nbsp;<emphasis>Encoding</emphasis></entry>
            </row>

            <row>
              <entry>&nbsp;<emphasis>&nbsp;Explicit&nbsp;BOM</emphasis></entry>
              <entry>&nbsp;<userinput>#x00</userinput></entry>
              <entry>&nbsp;<userinput>#x00</userinput></entry>
              <entry>&nbsp;<userinput>#xFE</userinput></entry>
              <entry>&nbsp;<userinput>#xFF</userinput></entry>
              <entry>&nbsp;UTF-32BE</entry>
            </row>

            <row>
              <entry>&nbsp;<emphasis
                >&nbsp;ASCII&nbsp;first&nbsp;character</emphasis></entry>
              <entry>&nbsp;<userinput>#x00</userinput></entry>
              <entry>&nbsp;<userinput>#x00</userinput></entry>
              <entry>&nbsp;<userinput>#x00</userinput></entry>
              <entry>&nbsp;<emphasis>any</emphasis></entry>
              <entry>&nbsp;UTF-32BE</entry>
            </row>

            <row>
              <entry>&nbsp;<emphasis>&nbsp;Explicit&nbsp;BOM</emphasis></entry>
              <entry>&nbsp;<userinput>#xFF</userinput></entry>
              <entry>&nbsp;<userinput>#xFE</userinput></entry>
              <entry>&nbsp;<userinput>#x00</userinput></entry>
              <entry>&nbsp;<userinput>#x00</userinput></entry>
              <entry>&nbsp;UTF-32LE</entry>
            </row>

            <row>
              <entry>&nbsp;<emphasis
                >&nbsp;ASCII&nbsp;first&nbsp;character</emphasis></entry>
              <entry>&nbsp;<emphasis>any</emphasis></entry>
              <entry>&nbsp;<userinput>#x00</userinput></entry>
              <entry>&nbsp;<userinput>#x00</userinput></entry>
              <entry>&nbsp;<userinput>#x00</userinput></entry>
              <entry>&nbsp;UTF-32LE</entry>
            </row>

            <row>
              <entry>&nbsp;<emphasis>&nbsp;Explicit&nbsp;BOM</emphasis></entry>
              <entry>&nbsp;<userinput>#xFE</userinput></entry>
              <entry>&nbsp;<userinput>#xFF</userinput></entry>
              <entry></entry>
              <entry></entry>
              <entry>&nbsp;UTF-16BE</entry>
            </row>

            <row>
              <entry>&nbsp;<emphasis
                >&nbsp;ASCII&nbsp;first&nbsp;character</emphasis></entry>
              <entry>&nbsp;<userinput>#x00</userinput></entry>
              <entry>&nbsp;<emphasis>any</emphasis></entry>
              <entry></entry>
              <entry></entry>
              <entry>&nbsp;UTF-16BE</entry>
            </row>

            <row>
              <entry>&nbsp;<emphasis>&nbsp;Explicit&nbsp;BOM</emphasis></entry>
              <entry>&nbsp;<userinput>#xFF</userinput></entry>
              <entry>&nbsp;<userinput>#xFE</userinput></entry>
              <entry></entry>
              <entry></entry>
              <entry>&nbsp;UTF-16LE</entry>
            </row>

            <row>
              <entry>&nbsp;<emphasis
                >&nbsp;ASCII&nbsp;first&nbsp;character</emphasis></entry>
              <entry>&nbsp;<emphasis>any</emphasis></entry>
              <entry>&nbsp;<userinput>#x00</userinput></entry>
              <entry></entry>
              <entry></entry>
              <entry>&nbsp;UTF-16LE</entry>
            </row>

            <row>
              <entry>&nbsp;<emphasis>&nbsp;Explicit&nbsp;BOM</emphasis></entry>
              <entry>&nbsp;<userinput>#xEF</userinput></entry>
              <entry>&nbsp;<userinput>#xBB</userinput></entry>
              <entry>&nbsp;<userinput>#xBF</userinput></entry>
              <entry></entry>
              <entry>&nbsp;UTF-8</entry>
            </row>

            <row>
              <entry>&nbsp;<emphasis>&nbsp;Default</emphasis></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry>&nbsp;UTF-8</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>
        The recommended output encoding is UTF-8. If another encoding is used,
        it is recommended that an explicit byte order mark be used, even if the
        first <refterm primary="stream">stream</refterm> character is ASCII.
      </para>

      <para>
        For more information about the byte order mark and the Unicode
        character encoding schemes see the <ulink
        url="http://www.unicode.org/unicode/faq/utf_bom.html">Unicode
        FAQ</ulink>.
      </para>

      <productionset>
        <production id="c-byte-order-mark">
          <lhs>c-byte-order-mark</lhs>
          <rhs>
            #xFEFF
          </rhs>
        </production>
      </productionset>

      <para>
        In the examples, byte order mark characters are displayed as
        <uquote>&hArr;</uquote>.
      </para>

      <example>
        <title>Byte Order Mark</title>

        <simplelist type="horiz" columns="2">
          <member>
<programlisting><hl1>&hArr;</hl1># Comment only.<sbr/>
</programlisting>
<synopsis>Legend:
  <hl1><link linkend="c-byte-order-mark">c-byte-order-mark</link></hl1>
</synopsis>
          </member>
          <member>
<programlisting># This stream contains no<sbr/>
# documents, only comments.
</programlisting>
          </member>
        </simplelist>
      </example>

      <example>
        <title>Invalid Byte Order Mark</title>

        <simplelist type="horiz" columns="2">
          <member>
<screen>- Invalid use of BOM<sbr/>
<hl1>&hArr;</hl1>
- Inside a document.
</screen>
            </member>
            <member>
<screen>ERROR:<sbr/>
 A <hl1>BOM</hl1> must not appear
 inside a document.
</screen>
          </member>
        </simplelist>
      </example>
    </sect1>

    <sect1>
      <title>Indicator Characters</title>

      <para>
        <defterm primary="indicator">Indicators</defterm> are characters that
        have special semantics.
      </para>

      <simplelist type="horiz" columns="2">
        <member>
          <productionset>
            <production id="c-sequence-entry">
              <lhs>c-sequence-entry</lhs>
              <rhs>
                <quote>-</quote>
              </rhs>
            </production>
          </productionset>
        </member>

        <member>
          A <refterm primary="- block sequence
          entry"><uquote>-</uquote></refterm> (<userinput>#x2D</userinput>,
          hyphen) denotes a <refterm primary="style" secondary="block"
          tertiary="sequence">block sequence</refterm> entry.
        </member>
      </simplelist>

      <simplelist type="horiz" columns="2">
        <member>
          <productionset>
            <production id="c-mapping-key">
              <lhs>c-mapping-key</lhs>
              <rhs>
                <quote>?</quote>
              </rhs>
            </production>
          </productionset>
        </member>

        <member>
          A <refterm primary="? mapping key"><uquote>?</uquote></refterm>
          (<userinput>#x3F</userinput>, question mark) denotes a <refterm
          primary="key">mapping key</refterm>.
        </member>
      </simplelist>

      <simplelist type="horiz" columns="2">
        <member>
          <productionset>
            <production id="c-mapping-value">
              <lhs>c-mapping-value</lhs>
              <rhs>
                <quote>:</quote>
              </rhs>
            </production>
          </productionset>
        </member>

        <member>
          A <refterm primary=": mapping value"><uquote>:</uquote></refterm>
          (<userinput>#x3A</userinput>, colon) denotes a <refterm
          primary="value">mapping value</refterm>.
        </member>
      </simplelist>

      <example>
        <title>Block Structure Indicators</title>

        <simplelist type="horiz" columns="2">
          <member>
<programlisting>sequence<hl3>:</hl3><sbr/>
<hl1>-</hl1> one
<hl1>-</hl1> two
mapping<hl3>:</hl3>
  <hl2>?</hl2> sky
  <hl3>:</hl3> blue
  sea <hl3>:</hl3> green
</programlisting>
<synopsis>Legend:
  <hl1><link linkend="c-sequence-entry">c-sequence-entry</link></hl1>
  <hl2><link linkend="c-mapping-key">c-mapping-key</link></hl2> <hl3><link linkend="c-mapping-value">c-mapping-value</link></hl3>
</synopsis>
            </member>
            <member>
<programlisting>%YAML 1.2<sbr/>
---
!!map {
  ? !!str "sequence"
  : !!seq [ !!str "one", !!str "two" ],
  ? !!str "mapping"
  : !!map {
    ? !!str "sky" : !!str "blue",
    ? !!str "sea" : !!str "green",
  },
}
</programlisting>
          </member>
        </simplelist>
      </example>

      <simplelist type="horiz" columns="2">
        <member>
          <productionset>
            <production id="c-collect-entry">
              <lhs>c-collect-entry</lhs>
              <rhs>
                <quote>,</quote>
              </rhs>
            </production>
          </productionset>
        </member>

        <member>
          A <refterm primary=", end flow entry"><uquote>,</uquote></refterm>
          (<userinput>#x2C</userinput>, comma) ends a <refterm primary="style"
          secondary="flow" tertiary="collection">flow collection</refterm>
          entry.
        </member>
      </simplelist>

      <simplelist type="horiz" columns="2">
        <member>
          <productionset>
            <production id="c-sequence-start">
              <lhs>c-sequence-start</lhs>
              <rhs>
                <quote>[</quote>
              </rhs>
            </production>
          </productionset>
        </member>

        <member>
          A <refterm primary="[ start flow
          sequence"><uquote>[</uquote></refterm> (<userinput>#x5B</userinput>,
          left bracket) starts a <refterm primary="style" secondary="flow"
          tertiary="sequence">flow sequence</refterm>.
        </member>
      </simplelist>

      <simplelist type="horiz" columns="2">
        <member>
          <productionset>
            <production id="c-sequence-end">
              <lhs>c-sequence-end</lhs>
              <rhs>
                <quote>]</quote>
              </rhs>
            </production>
          </productionset>
        </member>

        <member>
          A <refterm primary="] end flow sequence"><uquote>]</uquote></refterm>
          (<userinput>#x5D</userinput>, right bracket) ends a <refterm
          primary="style" secondary="flow" tertiary="sequence">flow
          sequence</refterm>.
        </member>
      </simplelist>

      <simplelist type="horiz" columns="2">
        <member>
          <productionset>
            <production id="c-mapping-start">
              <lhs>c-mapping-start</lhs>
              <rhs>
                <quote>{</quote>
              </rhs>
            </production>
          </productionset>
        </member>

        <member>
          A <refterm primary="{ start flow
          mapping"><uquote>{</uquote></refterm> (<userinput>#x7B</userinput>,
          left brace) starts a <refterm primary="style" secondary="flow"
          tertiary="mapping">flow mapping</refterm>.
        </member>
      </simplelist>

      <simplelist type="horiz" columns="2">
        <member>
          <productionset>
            <production id="c-mapping-end">
              <lhs>c-mapping-end</lhs>
              <rhs>
                <quote>}</quote>
              </rhs>
            </production>
          </productionset>
        </member>

        <member>
          A <refterm primary="} end flow mapping"><uquote>}</uquote></refterm>
          (<userinput>#x7D</userinput>, right brace) ends a <refterm
          primary="style" secondary="flow" tertiary="mapping">flow
          mapping</refterm>.
        </member>
      </simplelist>

      <example>
        <title>Flow Collection Indicators</title>

        <simplelist type="horiz" columns="2">
          <member>
<programlisting>sequence: <hl1>[</hl1> one<hl3>,</hl3> two<hl3>,</hl3> <hl1>]</hl1><sbr/>
mapping: <hl2>{</hl2> sky: blue<hl3>,</hl3> sea: green <hl2>}</hl2>
</programlisting>
<synopsis>Legend:
  <hl1><link linkend="c-sequence-start">c-sequence-start</link></hl1> <hl1><link linkend="c-sequence-end">c-sequence-end</link></hl1>
  <hl2><link linkend="c-mapping-start">c-mapping-start</link></hl2>  <hl2><link linkend="c-mapping-end">c-mapping-end</link></hl2>
  <hl3><link linkend="c-collect-entry">c-collect-entry</link></hl3>
</synopsis>
            </member>
            <member>
<programlisting>%YAML 1.2<sbr/>
---
!!map {
  ? !!str "sequence"
  : !!seq [ !!str "one", !!str "two" ],
  ? !!str "mapping"
  : !!map {
    ? !!str "sky" : !!str "blue",
    ? !!str "sea" : !!str "green",
  },
}
</programlisting>
          </member>
        </simplelist>
      </example>

      <simplelist type="horiz" columns="2">
        <member>
          <productionset>
            <production id="c-comment">
              <lhs>c-comment</lhs>
              <rhs>
                <quote>#</quote>
              </rhs>
            </production>
          </productionset>
        </member>

        <member>
          An <refterm primary="# comment"><uquote>#</uquote></refterm>
          (<userinput>#x23</userinput>, octothorpe, hash, sharp, pound, number
          sign) denotes a <refterm primary="comment">comment</refterm>.
        </member>
      </simplelist>

      <example>
        <title>Comment Indicator</title>

        <simplelist type="horiz" columns="2">
          <member>
<programlisting><hl1>#</hl1> Comment only.<sbr/>
</programlisting>
<synopsis>Legend:
  <hl1><link linkend="c-comment">c-comment</link></hl1>
</synopsis>
            </member>
            <member>
<programlisting># This stream contains no<sbr/>
# documents, only comments.
</programlisting>
          </member>
        </simplelist>
      </example>

      <pagebreak/>

      <simplelist type="horiz" columns="2">
        <member>
          <productionset>
            <production id="c-anchor">
              <lhs>c-anchor</lhs>
              <rhs>
                <quote>&amp;</quote>
              </rhs>
            </production>
          </productionset>
        </member>

        <member>
          An <refterm primary="&amp; anchor"><uquote>&amp;</uquote></refterm>
          (<userinput>#x26</userinput>, ampersand) denotes a <refterm
          primary="anchor">node<q/>s anchor property</refterm>.
        </member>
      </simplelist>

      <simplelist type="horiz" columns="2">
        <member>
          <productionset>
            <production id="c-alias">
              <lhs>c-alias</lhs>
              <rhs>
                <quote>*</quote>
              </rhs>
            </production>
          </productionset>
        </member>

        <member>
          An <refterm primary="* alias"><uquote>*</uquote></refterm>
          (<userinput>#x2A</userinput>, asterisk) denotes an <refterm
          primary="alias">alias node</refterm>.
        </member>
      </simplelist>

      <simplelist type="horiz" columns="2">
        <member>
          <productionset>
            <production id="c-tag">
              <lhs>c-tag</lhs>
              <rhs>
                <quote>!</quote>
              </rhs>
            </production>
          </productionset>
        </member>

        <member>
          The <refterm primary="! tag indicator"><uquote>!</uquote></refterm>
          (<userinput>#x21</userinput>, exclamation) is heavily overloaded for
          specifying <refterm primary="tag">node tags</refterm>. It is used to
          denote <refterm primary="tag" secondary="handle">tag
          handles</refterm> used in <refterm primary="directive"
          secondary="TAG">tag directives</refterm> and <refterm primary="tag"
          secondary="property">tag properties</refterm>; to denote <refterm
          primary="tag" secondary="local">local tags</refterm>; and as the
          <refterm primary="tag" secondary="non-specific">non-specific
          tag</refterm> for non-<refterm primary="style" secondary="flow"
          tertiary="plain">plain scalars</refterm>.
        </member>
      </simplelist>

      <example>
        <title>Node Property Indicators</title>

        <simplelist type="horiz" columns="2">
          <member>
<programlisting>anchored: <hl1>!</hl1>local <hl2>&amp;</hl2>anchor value<sbr/>
alias: <hl3>*</hl3>anchor
</programlisting>
<synopsis>Legend:
  <hl1><link linkend="c-tag">c-tag</link></hl1> <hl2><link linkend="c-anchor">c-anchor</link></hl2> <hl3><link linkend="c-alias">c-alias</link></hl3>
</synopsis>
            </member>
            <member>
<programlisting>%YAML 1.2<sbr/>
---
!!map {
  ? !!str "anchored"
  : !local &amp;A1 "value",
  ? !!str "alias"
  : *A1,
}
</programlisting>
          </member>
        </simplelist>
      </example>

      <simplelist type="horiz" columns="2">
        <member>
          <productionset>
            <production id="c-literal">
              <lhs>c-literal</lhs>
              <rhs>
                <quote>|</quote>
              </rhs>
            </production>
          </productionset>
        </member>

        <member>
          A <refterm primary="| literal style"><uquote>|</uquote></refterm>
          (<userinput>7C</userinput>, vertical bar) denotes a <refterm
          primary="style" secondary="block" tertiary="literal">literal block
          scalar</refterm>.
        </member>
      </simplelist>

      <simplelist type="horiz" columns="2">
        <member>
          <productionset>
            <production id="c-folded">
              <lhs>c-folded</lhs>
              <rhs>
                <quote>&gt;</quote>
              </rhs>
            </production>
          </productionset>
        </member>

        <member>
          A <refterm primary="&gt; folded
          style"><uquote>&gt;</uquote></refterm> (<userinput>#x3E</userinput>,
          greater than) denotes a <refterm primary="style" secondary="block"
          tertiary="folded">folded block scalar</refterm>.
        </member>
      </simplelist>

      <example>
        <title>Block Scalar Indicators</title>

        <simplelist type="horiz" columns="2">
          <member>
<programlisting>literal: <hl1>|</hl1><sbr/>
  some
  text
folded: <hl2>&gt;</hl2>
  some
  text
</programlisting>
<synopsis>Legend:
  <hl1><link linkend="c-literal">c-literal</link></hl1> <hl2><link linkend="c-folded">c-folded</link></hl2>
</synopsis>
            </member>
            <member>
<programlisting>%YAML 1.2<sbr/>
---
!!map {
  ? !!str "literal"
  : !!str "some\ntext\n",
  ? !!str "folded"
  : !!str "some text\n",
}
</programlisting>
          </member>
        </simplelist>
      </example>

      <simplelist type="horiz" columns="2">
        <member>
          <productionset>
            <production id="c-single-quote">
              <lhs>c-single-quote</lhs>
              <rhs>
                <quote>'</quote>
              </rhs>
            </production>
          </productionset>
        </member>

        <member>
          An <refterm primary="' single-quoted
          style"><uquote>'</uquote></refterm> (<userinput>#x27</userinput>,
          apostrophe, single quote) surrounds a <refterm primary="style"
          secondary="flow" tertiary="single-quoted">single-quoted flow
          scalar</refterm>.
        </member>
      </simplelist>

      <simplelist type="horiz" columns="2">
        <member>
          <productionset>
            <production id="c-double-quote">
              <lhs>c-double-quote</lhs>
              <rhs>
                <quote>"</quote>
              </rhs>
            </production>
          </productionset>
        </member>

        <member>
          A <refterm primary='" double-quoted
          style'><uquote>"</uquote></refterm> (<userinput>#x22</userinput>,
          double quote) surrounds a <refterm primary="style" secondary="flow"
          tertiary="double-quoted">double-quoted flow scalar</refterm>.
        </member>
      </simplelist>

      <example>
        <title>Quoted Scalar Indicators</title>

        <simplelist type="horiz" columns="2">
          <member>
<programlisting>single: <hl1>'</hl1>text<hl1>'</hl1><sbr/>
double: <hl2>"</hl2>text<hl2>"</hl2>
</programlisting>
<synopsis>Legend:
  <hl1><link linkend="c-single-quote">c-single-quote</link></hl1> <hl2><link linkend="c-double-quote">c-double-quote</link></hl2>
</synopsis>
            </member>
            <member>
<programlisting>%YAML 1.2<sbr/>
---
!!map {
  ? !!str "single"
  : !!str "text",
  ? !!str "double"
  : !!str "text",
}
</programlisting>
          </member>
        </simplelist>
      </example>

      <pagebreak/>

      <simplelist type="horiz" columns="2">
        <member>
          <productionset>
            <production id="c-directive">
              <lhs>c-directive</lhs>
              <rhs>
                <quote>%</quote>
              </rhs>
            </production>
          </productionset>
        </member>

        <member>
          A <refterm primary="% directive"><uquote>%</uquote></refterm>
          (<userinput>#x25</userinput>, percent) denotes a <refterm
          primary="directive">directive</refterm> line.
        </member>
      </simplelist>

      <example>
        <title>Directive Indicator</title>

        <simplelist type="horiz" columns="2">
          <member>
<programlisting><hl1>%</hl1>YAML 1.2<sbr/>
--- text
</programlisting>
<synopsis>Legend:
  <hl1><link linkend="c-directive">c-directive</link></hl1>
</synopsis>
            </member>
            <member>
<programlisting>%YAML 1.2<sbr/>
---
!!str "text"
</programlisting>
          </member>
        </simplelist>
      </example>

      <simplelist type="horiz" columns="2">
        <member>
          <productionset>
            <production id="c-reserved">
              <lhs>c-reserved</lhs>
              <rhs>
                <quote>@</quote> | <quote>`</quote>
              </rhs>
            </production>
          </productionset>
        </member>

        <member>
          The <defterm primary="@ reserved
          indicator"><uquote>@</uquote></defterm> (<userinput>#x40</userinput>,
          at) and <defterm primary="' reserved
          indicator"><uquote>`</uquote></defterm> (<userinput>#x60</userinput>,
          grave accent) are <defterm primary="indicator"
          secondary="reserved">reserved</defterm> for future use.
        </member>
      </simplelist>

      <example>
        <title>Invalid use of Reserved Indicators</title>

        <simplelist type="horiz" columns="2">
          <member>
<screen>commercial-at: <hl1>@</hl1>text<sbr/>
grave-accent: <hl1>`</hl1>text
</screen>
            </member>
            <member>
<screen>ERROR:<sbr/>
 <hl1>Reserved indicators</hl1> can't
 start a plain scalar.
</screen>
          </member>
        </simplelist>
      </example>

      <para>
        Any indicator character:
      </para>

      <productionset>
        <production id="c-indicator">
          <lhs>c-indicator</lhs>
          <rhs>
            &nbsp;&nbsp;<nonterminal
                def="#c-sequence-entry"><quote>-</quote></nonterminal>
            | <nonterminal
                def="#c-mapping-key"><quote>?</quote></nonterminal>
            | <nonterminal
                def="#c-mapping-value"><quote>:</quote></nonterminal>
            | <nonterminal
             def="#c-collect-entry"><quote>,</quote></nonterminal>
            | <nonterminal
                def="#c-sequence-start"><quote>[</quote></nonterminal>
            | <nonterminal
                def="#c-sequence-end"><quote>]</quote></nonterminal>
            | <nonterminal
                def="#c-mapping-start"><quote>{</quote></nonterminal>
            | <nonterminal
                def="#c-mapping-end"><quote>}</quote></nonterminal><sbr/>
            | <nonterminal
                def="#c-comment"><quote>#</quote></nonterminal>
            | <nonterminal
                def="#c-anchor"><quote>&amp;</quote></nonterminal>
            | <nonterminal def="#c-alias"><quote>*</quote></nonterminal>
            | <nonterminal
                def="#c-tag"><quote>!</quote></nonterminal>
            | <nonterminal
                def="#c-literal"><quote>|</quote></nonterminal>
            | <nonterminal
                def="#c-folded"><quote>&gt;</quote></nonterminal>
            | <nonterminal
              def="#c-single-quote"><quote>'</quote></nonterminal>
            | <nonterminal
              def="#c-double-quote"><quote>"</quote></nonterminal><sbr/>
            | <nonterminal
              def="#c-directive"><quote>%</quote></nonterminal>
            | <nonterminal def="#c-reserved"><quote>@</quote>
            | <quote>`</quote></nonterminal>
          </rhs>
        </production>
      </productionset>

      <para>
        The <refterm primary="[ start flow
        sequence"><uquote>[</uquote></refterm>, <refterm primary="] end flow
        sequence"><uquote>]</uquote></refterm>, <refterm primary="{ start flow
        mapping"><uquote>{</uquote></refterm>, <refterm primary="} end flow
        mapping"><uquote>}</uquote></refterm> and <refterm primary=", end flow
        entry"><uquote>,</uquote></refterm> indicators denote structure in
        <refterm primary="style" secondary="flow" tertiary="collection">flow
        collections</refterm>. They are therefore forbidden in some cases, to
        avoid ambiguity in several constructs. This is handled on a
        case-by-case basis by the relevant productions.
      </para>

      <productionset>
        <production id="c-flow-indicator">
          <lhs>c-flow-indicator</lhs>
          <rhs>
            <nonterminal
             def="#c-collect-entry"><quote>,</quote></nonterminal>
            | <nonterminal
                def="#c-sequence-start"><quote>[</quote></nonterminal>
            | <nonterminal
                def="#c-sequence-end"><quote>]</quote></nonterminal>
            | <nonterminal
                def="#c-mapping-start"><quote>{</quote></nonterminal>
            | <nonterminal
                def="#c-mapping-end"><quote>}</quote></nonterminal><sbr/>
          </rhs>
        </production>
      </productionset>
    </sect1>

    <sect1>
      <title>Line Break Characters</title>

      <para>
        YAML recognizes the following ASCII <defterm primary="line break">line
        break</defterm> characters.
      </para>

      <productionset>
        <production id="b-line-feed">
          <lhs>b-line-feed</lhs>
          <rhs>
            #xA &nbsp;&nbsp;&nbsp;/* LF */
          </rhs>
        </production>

        <production id="b-carriage-return">
          <lhs>b-carriage-return</lhs>
          <rhs>
            #xD &nbsp;&nbsp;&nbsp;/* CR */
          </rhs>
        </production>

        <production id="b-char">
          <lhs>b-char</lhs>
          <rhs>
            <nonterminal def="#b-line-feed"/>
            | <nonterminal def="#b-carriage-return"/>
          </rhs>
        </production>
      </productionset>

      <para>
        All other characters, including the form feed
        (<userinput>#x0C</userinput>), are considered to be non-break
        characters. Note that these include the <defterm primary="line break"
        secondary="non-ASCII">non-ASCII line breaks</defterm>: next line
        (<userinput>#x85</userinput>), line separator
        (<userinput>#x2028</userinput>) and paragraph separator
        (<userinput>#x2029</userinput>).
      </para>

      <para>
        <anchor id="non-ASCII line breaks"/> <refterm primary="YAML 1.1
        processing">YAML version 1.1</refterm> did support the above non-ASCII
        line break characters; however, JSON does not. Hence, to ensure
        <refterm primary="JSON compatibility">JSON compatibility</refterm>,
        YAML treats them as non-break characters as of version 1.2. In theory
        this would cause incompatibility with <refterm primary="YAML 1.1
        processing">version 1.1</refterm>; in practice these characters were
        rarely (if ever) used. YAML 1.2 <refterm
        primary="processor">processors</refterm> <refterm
        primary="parse">parsing</refterm> a <refterm primary="YAML 1.1
        processing">version 1.1</refterm> <refterm
        primary="document">document</refterm> should therefore treat these line
        breaks as non-break characters, with an appropriate warning.
      </para>

      <productionset>
        <production id="nb-char">
          <lhs>nb-char</lhs>
          <rhs>
            <nonterminal def="#c-printable"/>
            - <nonterminal def="#b-char"/>
            - <nonterminal def="#c-byte-order-mark"/>
          </rhs>
        </production>
      </productionset>

      <para>
        Line breaks are interpreted differently by different systems, and have
        several widely used formats.
      </para>

      <productionset>
        <production id="b-break">
          <lhs>b-break</lhs>
          <rhs>
            &nbsp;&nbsp;( <nonterminal def="#b-carriage-return"/>
            <nonterminal def="#b-line-feed"/> ) /* DOS, Windows */<sbr/>
            | <nonterminal def="#b-carriage-return"/>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* MacOS upto 9.x */<sbr/>
            | <nonterminal def="#b-line-feed"/>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            &nbsp; /* UNIX, MacOS X */
          </rhs>
        </production>
      </productionset>

      <para>
        Line breaks inside <refterm primary="scalar">scalar content</refterm>
        must be <defterm primary="line break"
        secondary="normalization">normalized</defterm> by the YAML <refterm
        primary="processor">processor</refterm>. Each such line break must be
        <refterm primary="parse">parsed</refterm> into a single line feed
        character. The original line break format is a <refterm
        primary="presentation" secondary="detail">presentation detail</refterm>
        and must not be used to convey <refterm
        primary="content">content</refterm> information.
      </para>

      <productionset>
        <production id="b-as-line-feed">
          <lhs>b-as-line-feed</lhs>
          <rhs>
            <nonterminal def="#b-break"/>
          </rhs>
        </production>
      </productionset>

      <para>
        Outside <refterm primary="scalar">scalar content</refterm>, YAML allows
        any line break to be used to terminate lines.
      </para>

      <productionset>
        <production id="b-non-content">
          <lhs>b-non-content</lhs>
          <rhs>
            <nonterminal def="#b-break"/>
          </rhs>
        </production>
      </productionset>

      <para>
        On output, a YAML <refterm primary="processor">processor</refterm> is
        free to emit line breaks using whatever convention is most appropriate.
      </para>

      <para>
        In the examples, line breaks are sometimes displayed using the
        <uquote>&darr;</uquote> glyph for clarity.
      </para>

      <example>
        <title>Line Break Characters</title>

        <simplelist type="horiz" columns="2">
          <member>
<programlisting>|<sbr/>
  Line break (no glyph)
  Line break (glyphed)<hl1>&darr;</hl1>
</programlisting>
<synopsis>Legend:
  <hl1><link linkend="b-break">b-break</link></hl1>
</synopsis>
          </member>
          <member>
<programlisting>%YAML 1.2<sbr/>
---
!!str "line break (no glyph)\n\
      line break (glyphed)\n"
</programlisting>
          </member>
        </simplelist>
      </example>
    </sect1>

    <sect1>
      <title>White Space Characters</title>

      <para>
        YAML recognizes two <defterm primary="space" secondary="white">white
        space</defterm> characters: <defterm primary="space">space</defterm>
        and <defterm primary="tab">tab</defterm>.
      </para>

      <productionset>
        <production id="s-space">
          <lhs>s-space</lhs>
          <rhs>
            #x20 /* SP */
          </rhs>
        </production>

        <production id="s-tab">
          <lhs>s-tab</lhs>
          <rhs>
            #x9 &nbsp;/* TAB */
          </rhs>
        </production>

        <production id="s-white">
          <lhs>s-white</lhs>
          <rhs>
            <nonterminal def="#s-space"/> | <nonterminal def="#s-tab"/>
          </rhs>
        </production>
      </productionset>

      <para>
        The rest of the (<refterm primary="printable
        character">printable</refterm>) non-<refterm primary="line
        break">break</refterm> characters are considered to be non-space
        characters.
      </para>

      <productionset>
        <production id="ns-char">
          <lhs>ns-char</lhs>
          <rhs>
            <nonterminal def="#nb-char"/> - <nonterminal def="#s-white"/>
          </rhs>
        </production>
      </productionset>

      <para>
        In the examples, tab characters are displayed as the glyph
        <uquote>&rarr;</uquote>. Space characters are sometimes displayed as
        the glyph <uquote>&middot;</uquote> for clarity.
      </para>

      <example>
        <title>Tabs and Spaces</title>

        <simplelist type="horiz" columns="2">
          <member>
<programlisting># Tabs and spaces<sbr/>
quoted:<hl1>&middot;</hl1>"Quoted <hl2>&rarr;</hl2>"
block:<hl2>&rarr;</hl2>|
<hl1>&middot;&middot;</hl1>void main() {
<hl1>&middot;&middot;</hl1><hl2>&rarr;</hl2>printf("Hello, world!\n");
<hl1>&middot;&middot;</hl1>}
</programlisting>
<synopsis>Legend:
  <hl1><link linkend="s-space">s-space</link></hl1> <hl2><link linkend="s-tab">s-tab</link></hl2>
</synopsis>
          </member>
          <member>
<programlisting>%YAML 1.2<sbr/>
---
!!map {
  ? !!str "quoted"
  : "Quoted \t",
  ? !!str "block"
  : "void main() {\n\
    \tprintf(\"Hello, world!\\n\");\n\
    }\n",
}
</programlisting>

          </member>
        </simplelist>
      </example>
    </sect1>

    <pagebreak/>

    <sect1>
      <title>Miscellaneous Characters</title>

      <para>
        The YAML syntax productions make use of the following additional
        character classes:
      </para>

      <itemizedlist>
        <listitem>
          A decimal digit for numbers:
        </listitem>
      </itemizedlist>

      <productionset>
        <production id="ns-dec-digit">
          <lhs>ns-dec-digit</lhs>
          <rhs>
            [#x30-#x39] /* 0-9 */
          </rhs>
        </production>
      </productionset>

      <itemizedlist>
        <listitem>
          A hexadecimal digit for <refterm primary="escaping" secondary="in
          double-quoted scalars">escape sequences</refterm>:
        </listitem>
      </itemizedlist>

      <productionset>
        <production id="ns-hex-digit">
          <lhs>ns-hex-digit</lhs>
          <rhs>
            &nbsp;&nbsp;<nonterminal def="#ns-dec-digit"/><sbr/>
            | [#x41-#x46] /* A-F */ | [#x61-#x66] /* a-f */
          </rhs>
        </production>
      </productionset>

      <itemizedlist>
        <listitem>
          ASCII letter (alphabetic) characters:
        </listitem>
      </itemizedlist>

      <productionset>
        <production id="ns-ascii-letter">
          <lhs>ns-ascii-letter</lhs>
          <rhs>
            [#x41-#x5A] /* A-Z */ | [#x61-#x7A] /* a-z */
          </rhs>
        </production>
      </productionset>

      <itemizedlist>
        <listitem>
          Word (alphanumeric) characters for identifiers:
        </listitem>
      </itemizedlist>

      <productionset>
        <production id="ns-word-char">
          <lhs>ns-word-char</lhs>
          <rhs>
            <nonterminal def="#ns-dec-digit"/>
            | <nonterminal def="#ns-ascii-letter"/>
            | <quote>-</quote>
          </rhs>
        </production>
      </productionset>

      <itemizedlist>
        <listitem>
          <para>
            URI characters for <refterm primary="tag">tags</refterm>, as
            specified in <ulink
            url="http://www.ietf.org/rfc/rfc2396.txt">RFC2396</ulink>, with the
            addition of the <uquote>[</uquote> and <uquote>]</uquote> for
            presenting IPv6 addresses as proposed in <ulink
            url="http://www.ietf.org/rfc/rfc2732.txt">RFC2732</ulink>.
          </para>

          <para>
            By convention, any URI characters other than the allowed printable
            ASCII characters are first <defterm primary="character encoding"
            secondary="in URI">encoded</defterm> in UTF-8, and then each byte
            is <defterm primary="escaping" secondary="in
            URIs">escaped</defterm> using the <defterm primary="% escaping in
            URI"><uquote>%</uquote></defterm> character. The YAML <refterm
            primary="processor">processor</refterm> must not expand such
            escaped characters. <refterm primary="tag">Tag</refterm> characters
            must be preserved and compared exactly as <refterm
            primary="present">presented</refterm> in the YAML <refterm
            primary="stream">stream</refterm>, without any processing.
          </para>
        </listitem>
      </itemizedlist>

      <productionset>
        <production id="ns-uri-char">
          <lhs>ns-uri-char</lhs>
          <rhs>
            &nbsp;&nbsp;<quote>%</quote> <nonterminal def="#ns-hex-digit"/>
            <nonterminal def="#ns-hex-digit"/>
            | <nonterminal def="#ns-word-char"/> | <quote>#</quote><sbr/>
            | <quote>;</quote> | <quote>/</quote> | <quote>?</quote>
            | <quote>:</quote> | <quote>@</quote> | <quote>&amp;</quote>
            | <quote>=</quote> | <quote>+</quote> | <quote>$</quote>
            | <quote>,</quote><sbr/>
            | <quote>_</quote> | <quote>.</quote> | <quote>!</quote>
            | <quote>~</quote> | <quote>*</quote> | <quote>'</quote>
            | <quote>(</quote> | <quote>)</quote> | <quote>[</quote>
            | <quote>]</quote>
          </rhs>
        </production>
      </productionset>

      <itemizedlist>
        <listitem>
          The <link linkend="c-tag"><uquote>!</uquote></link> character is used
          to indicate the end of a <refterm primary="tag" secondary="handle"
          tertiary="named">named tag handle</refterm>; hence its use in
          <refterm primary="tag" secondary="shorthand">tag shorthands</refterm>
          is restricted. In addition, such <refterm primary="tag"
          secondary="shorthand">shorthands</refterm> must not contain the
          <refterm primary="[ start flow
          sequence"><uquote>[</uquote></refterm>, <refterm primary="] end flow
          sequence"><uquote>]</uquote></refterm>, <refterm primary="{ start
          flow mapping"><uquote>{</uquote></refterm>, <refterm primary="} end
          flow mapping"><uquote>}</uquote></refterm> and <refterm primary=",
          end flow entry"><uquote>,</uquote></refterm> characters. These
          characters would cause ambiguity with <refterm primary="style"
          secondary="flow" tertiary="collection">flow collection</refterm>
          structures.
        </listitem>
      </itemizedlist>

      <productionset>
        <production id="ns-tag-char">
          <lhs>ns-tag-char</lhs>
          <rhs>
            <nonterminal def="#ns-uri-char"/>
            - <nonterminal def="#c-tag"><quote>!</quote></nonterminal>
            - <nonterminal def="#c-flow-indicator"/>
          </rhs>
        </production>
      </productionset>
    </sect1>

    <pagebreak/>

    <sect1>
      <title>Escaped Characters</title>

      <para>
        All non-<refterm primary="printable character">printable</refterm>
        characters must be <defterm primary="escaping" secondary="in
        double-quoted scalars">escaped</defterm>. YAML escape sequences use the
        <defterm primary="\ escaping in double-quoted
        scalars"><uquote>\</uquote></defterm> notation common to most modern
        computer languages. Each escape sequence must be <refterm
        primary="parse">parsed</refterm> into the appropriate Unicode
        character. The original escape sequence is a <refterm
        primary="presentation" secondary="detail">presentation detail</refterm>
        and must not be used to convey <refterm
        primary="content">content</refterm> information.
      </para>

      <para>
        Note that escape sequences are only interpreted in <refterm
        primary="style" secondary="flow" tertiary="double-quoted">double-quoted
        scalars</refterm>. In all other <refterm primary="style"
        secondary="scalar">scalar styles</refterm>, the <uquote>\</uquote>
        character has no special meaning and non-<refterm primary="printable
        character">printable</refterm> characters are not available.
      </para>

      <productionset>
        <production id="c-escape">
          <lhs>c-escape</lhs>
          <rhs>
            <quote>\</quote>
          </rhs>
        </production>
      </productionset>

      <para>
        YAML escape sequences are a superset of C<q/>s escape sequences:
      </para>

      <simplelist type="horiz" columns="2">
        <member>
          <productionset>
            <production id="ns-esc-null">
              <lhs>ns-esc-null</lhs>
              <rhs>
                <quote>0</quote>
              </rhs>
            </production>
          </productionset>
        </member>

        <member>
          Escaped ASCII null (<userinput>#x0</userinput>) character.
        </member>
      </simplelist>

      <simplelist type="horiz" columns="2">
        <member>
          <productionset>
            <production id="ns-esc-bell">
              <lhs>ns-esc-bell</lhs>
              <rhs>
                <quote>a</quote>
              </rhs>
            </production>
          </productionset>
        </member>

        <member>
          Escaped ASCII bell (<userinput>#x7</userinput>) character.
        </member>
      </simplelist>

      <simplelist type="horiz" columns="2">
        <member>
          <productionset>
            <production id="ns-esc-backspace">
              <lhs>ns-esc-backspace</lhs>
              <rhs>
                <quote>b</quote>
              </rhs>
            </production>
          </productionset>
        </member>

        <member>
          Escaped ASCII backspace (<userinput>#x8</userinput>) character.
        </member>
      </simplelist>

      <simplelist type="horiz" columns="2">
        <member>
          <productionset>
            <production id="ns-esc-horizontal-tab">
              <lhs>ns-esc-horizontal-tab</lhs>
              <rhs>
                <quote>t</quote>
                | #x9
              </rhs>
            </production>
          </productionset>
        </member>

        <member>
          Escaped ASCII horizontal tab (<userinput>#x9</userinput>) character.
          This is useful at the start or the end of a line to force a leading
          or trailing tab to become part of the <refterm
          primary="content">content</refterm>.
        </member>
      </simplelist>

      <simplelist type="horiz" columns="2">
        <member>
          <productionset>
            <production id="ns-esc-line-feed">
              <lhs>ns-esc-line-feed</lhs>
              <rhs>
                <quote>n</quote>
              </rhs>
            </production>
          </productionset>
        </member>

        <member>
          Escaped ASCII line feed (<userinput>#xA</userinput>) character.
        </member>
      </simplelist>

      <simplelist type="horiz" columns="2">
        <member>
          <productionset>
            <production id="ns-esc-vertical-tab">
              <lhs>ns-esc-vertical-tab</lhs>
              <rhs>
                <quote>v</quote>
              </rhs>
            </production>
          </productionset>
        </member>

        <member>
          Escaped ASCII vertical tab (<userinput>#xB</userinput>) character.
        </member>
      </simplelist>

      <simplelist type="horiz" columns="2">
        <member>
          <productionset>
            <production id="ns-esc-form-feed">
              <lhs>ns-esc-form-feed</lhs>
              <rhs>
                <quote>f</quote>
              </rhs>
            </production>
          </productionset>
        </member>

        <member>
          Escaped ASCII form feed (<userinput>#xC</userinput>) character.
        </member>
      </simplelist>

      <simplelist type="horiz" columns="2">
        <member>
          <productionset>
            <production id="ns-esc-carriage-return">
              <lhs>ns-esc-carriage-return</lhs>
              <rhs>
                <quote>r</quote>
              </rhs>
            </production>
          </productionset>
        </member>

        <member>
          Escaped ASCII carriage return (<userinput>#xD</userinput>) character.
        </member>
      </simplelist>

      <simplelist type="horiz" columns="2">
        <member>
          <productionset>
            <production id="ns-esc-escape">
              <lhs>ns-esc-escape</lhs>
              <rhs>
                <quote>e</quote>
              </rhs>
            </production>
          </productionset>
        </member>

        <member>
          Escaped ASCII escape (<userinput>#x1B</userinput>) character.
        </member>
      </simplelist>

      <simplelist type="horiz" columns="2">
        <member>
          <productionset>
            <production id="ns-esc-space">
              <lhs>ns-esc-space</lhs>
              <rhs>
                #x20
              </rhs>
            </production>
          </productionset>
        </member>

        <member>
          Escaped ASCII space (<userinput>#x20</userinput>) character. This is
          useful at the start or the end of a line to force a leading or
          trailing space to become part of the <refterm
          primary="content">content</refterm>.
        </member>
      </simplelist>

      <simplelist type="horiz" columns="2">
        <member>
          <productionset>
            <production id="ns-esc-double-quote">
              <lhs>ns-esc-double-quote</lhs>
              <rhs>
                <nonterminal def="#c-double-quote"><quote
                  >"</quote></nonterminal>
              </rhs>
            </production>
          </productionset>
        </member>

        <member>
          Escaped ASCII double quote (<userinput>#x22</userinput>).
        </member>
      </simplelist>

      <simplelist type="horiz" columns="2">
        <member>
          <productionset>
            <production id="ns-esc-slash">
              <lhs>ns-esc-slash</lhs>
              <rhs>
                <quote>/</quote>
              </rhs>
            </production>
          </productionset>
        </member>

        <member>
          Escaped ASCII slash (<userinput>#x2F</userinput>),
          for <refterm primary="JSON compatibility">JSON
          compatibility</refterm>.
        </member>
      </simplelist>

      <simplelist type="horiz" columns="2">
        <member>
          <productionset>
            <production id="ns-esc-backslash">
              <lhs>ns-esc-backslash</lhs>
              <rhs>
                <nonterminal def="#c-escape"><quote>\</quote></nonterminal>
              </rhs>
            </production>
          </productionset>
        </member>

        <member>
          Escaped ASCII back slash (<userinput>#x5C</userinput>).
        </member>
      </simplelist>

      <simplelist type="horiz" columns="2">
        <member>
          <productionset>
            <production id="ns-esc-next-line">
              <lhs>ns-esc-next-line</lhs>
              <rhs>
                <quote>N</quote>
              </rhs>
            </production>
          </productionset>
        </member>

        <member>
          Escaped Unicode next line (<userinput>#x85</userinput>) character.
        </member>
      </simplelist>

      <simplelist type="horiz" columns="2">
        <member>
          <productionset>
            <production id="ns-esc-non-breaking-space">
              <lhs>ns-esc-non-breaking-space</lhs>
              <rhs>
                <quote>_</quote>
              </rhs>
            </production>
          </productionset>
        </member>

        <member>
          Escaped Unicode non-breaking space (<userinput>#xA0</userinput>)
          character.
        </member>
      </simplelist>

      <simplelist type="horiz" columns="2">
        <member>
          <productionset>
            <production id="ns-esc-line-separator">
              <lhs>ns-esc-line-separator</lhs>
              <rhs>
                <quote>L</quote>
              </rhs>
            </production>
          </productionset>
        </member>

        <member>
          Escaped Unicode line separator (<userinput>#x2028</userinput>)
          character.
        </member>
      </simplelist>

      <simplelist type="horiz" columns="2">
        <member>
          <productionset>
            <production id="ns-esc-paragraph-separator">
              <lhs>ns-esc-paragraph-separator</lhs>
              <rhs>
                <quote>P</quote>
              </rhs>
            </production>
          </productionset>
        </member>

        <member>
          Escaped Unicode paragraph separator (<userinput>#x2029</userinput>)
          character.
        </member>
      </simplelist>

      <simplelist type="horiz" columns="2">
        <member>
          <productionset>
            <production id="ns-esc-8-bit">
              <lhs>ns-esc-8-bit</lhs>
              <rhs>
                <quote>x</quote><sbr/>
                ( <nonterminal def="#ns-hex-digit"/> &times; 2 )
              </rhs>
            </production>
          </productionset>
        </member>

        <member>
          Escaped 8-bit Unicode character.
        </member>
      </simplelist>

      <simplelist type="horiz" columns="2">
        <member>
          <productionset>
            <production id="ns-esc-16-bit">
              <lhs>ns-esc-16-bit</lhs>
              <rhs>
                <quote>u</quote><sbr/>
                ( <nonterminal def="#ns-hex-digit"/> &times; 4 )
              </rhs>
            </production>
          </productionset>
        </member>

        <member>
          Escaped 16-bit Unicode character.
        </member>
      </simplelist>

      <simplelist type="horiz" columns="2">
        <member>
          <productionset>
            <production id="ns-esc-32-bit">
              <lhs>ns-esc-32-bit</lhs>
              <rhs>
                <quote>U</quote><sbr/>
                ( <nonterminal def="#ns-hex-digit"/> &times; 8 )
              </rhs>
            </production>
          </productionset>
        </member>

        <member>
          Escaped 32-bit Unicode character.
        </member>
      </simplelist>

      <pagebreak/>

      <para>
        Any escaped character:
      </para>

      <productionset>
        <production id="c-ns-esc-char">
          <lhs>c-ns-esc-char</lhs>
          <rhs>
            <nonterminal def="#c-escape"><quote>\</quote></nonterminal><sbr/>
            (&nbsp;<nonterminal def="#ns-esc-null"/>
            | <nonterminal def="#ns-esc-bell"/>
            | <nonterminal def="#ns-esc-backspace"/><sbr/>
            | <nonterminal def="#ns-esc-horizontal-tab"/>
            | <nonterminal def="#ns-esc-line-feed"/><sbr/>
            | <nonterminal def="#ns-esc-vertical-tab"/>
            | <nonterminal def="#ns-esc-form-feed"/><sbr/>
            | <nonterminal def="#ns-esc-carriage-return"/>
            | <nonterminal def="#ns-esc-escape"/>
            | <nonterminal def="#ns-esc-space"/><sbr/>
            | <nonterminal def="#ns-esc-double-quote"/>
            | <nonterminal def="#ns-esc-slash"/>
            | <nonterminal def="#ns-esc-backslash"/><sbr/>
            | <nonterminal def="#ns-esc-next-line"/>
            | <nonterminal def="#ns-esc-non-breaking-space"/><sbr/>
            | <nonterminal def="#ns-esc-line-separator"/>
            | <nonterminal def="#ns-esc-paragraph-separator"/><sbr/>
            | <nonterminal def="#ns-esc-8-bit"/>
            | <nonterminal def="#ns-esc-16-bit"/>
            | <nonterminal def="#ns-esc-32-bit"/> )<sbr/>
          </rhs>
        </production>
      </productionset>

      <example>
        <title>Escaped Characters</title>

        <simplelist type="horiz" columns="2">
          <member>
<programlisting>"Fun with <hl1>\\</hl1><sbr/>
<hl1>\"</hl1> <hl1>\a</hl1> <hl1>\b</hl1> <hl1>\e</hl1> <hl1>\f</hl1> <hl1>\&darr;</hl1>
<hl1>\n</hl1> <hl1>\r</hl1> <hl1>\t</hl1> <hl1>\v</hl1> <hl1>\0</hl1> <hl1>\&darr;</hl1>
<hl1>\&nbsp;</hl1> <hl1>\_</hl1> <hl1>\N</hl1> <hl1>\L</hl1> <hl1>\P</hl1> <hl1>\&darr;</hl1>
<hl1>\x41</hl1> <hl1>\u0041</hl1> <hl1>\U00000041</hl1>"
</programlisting>
<synopsis>Legend:
  <hl1><link linkend="c-ns-esc-char">c-ns-esc-char</link></hl1>
</synopsis>
            </member>
            <member>
<programlisting>%YAML 1.2<sbr/>
---
"Fun with \x5C
\x22 \x07 \x08 \x1B \x0C
\x0A \x0D \x09 \x0B \x00
\x20 \xA0 \x85 \u2028 \u2029
A A A"
</programlisting>
          </member>
        </simplelist>
      </example>

      <example>
        <title>Invalid Escaped Characters</title>

        <simplelist type="horiz" columns="2">
          <member>
<screen>Bad escapes:<sbr/>
  "\<hl1>c</hl1>
  \x<hl2>q-</hl2>"
</screen>
            </member>
            <member>
<screen>ERROR:<sbr/>
- <hl1>c</hl1> is an invalid escaped character.
- <hl2>q</hl2> and <hl2>-</hl2> are invalid hex digits.
</screen>
          </member>
        </simplelist>
      </example>
    </sect1>
  </chapter>

  <chapter id="Basic">
    <title>Basic Structures</title>

    <sect1>
      <title>Indentation Spaces</title>

      <para>
        In YAML <refterm primary="style" secondary="block">block
        styles</refterm>, structure is determined by <defterm primary="space"
        secondary="indentation">indentation</defterm>. In general, indentation
        is defined as a zero or more <refterm primary="space">space</refterm>
        characters at the start of a line.
      </para>

      <para>
        To maintain portability, <refterm primary="tab">tab</refterm>
        characters must not be used in indentation, since different systems
        treat <refterm primary="tab">tabs</refterm> differently. Note that most
        modern editors may be configured so that pressing the <refterm
        primary="tab">tab</refterm> key results in the insertion of an
        appropriate number of <refterm primary="space">spaces</refterm>.
      </para>

      <para>
        The amount of indentation is a <refterm primary="presentation"
        secondary="detail">presentation detail</refterm> and must not be used
        to convey <refterm primary="content">content</refterm> information.
      </para>

      <productionset>
        <production id="s-indent(n)">
          <lhs>s-indent(n)</lhs>
          <rhs>
            <nonterminal def="#s-space"/> &times; n
          </rhs>
        </production>
      </productionset>

      <para>
        A <refterm primary="style" secondary="block">block style</refterm>
        construct is terminated when encountering a line which is less indented
        than the construct. The productions use the notation
        <uquote>s-indent(&lt;n)</uquote> and <uquote>s-indent(&les;n)</uquote>
        to express this.
      </para>

      <productionset>
        <production id="s-indent(&lt;n)">
          <lhs>s-indent(&lt;n)</lhs>
          <rhs>
            <nonterminal def="#s-space"/> &times; <varname>m</varname>
            /* Where <varname>m</varname> &lt; <varname>n</varname> */
          </rhs>
        </production>

        <production id="s-indent(&les;n)">
          <lhs>s-indent(&les;n)</lhs>
          <rhs>
            <nonterminal def="#s-space"/> &times; <varname>m</varname>
            /* Where <varname>m</varname> &les; <varname>n</varname> */
          </rhs>
        </production>
      </productionset>

      <para>
        Each <refterm primary="node">node</refterm> must be indented further
        than its parent <refterm primary="node">node</refterm>. All sibling
        <refterm primary="node">nodes</refterm> must use the exact same
        indentation level. However the <refterm
        primary="content">content</refterm> of each sibling <refterm
        primary="node">node</refterm> may be further indented independently.
      </para>

      <example>
        <title>Indentation Spaces</title>

        <simplelist type="horiz" columns="2">
          <member>
<programlisting><hl3>&middot;&middot;</hl3># Leading comment line spaces are<sbr/>
<hl3>&middot;&middot;&middot;</hl3># neither content nor indentation.
<hl3>&middot;&middot;&middot;&middot;</hl3>
Not indented:
<hl1>&middot;</hl1>By one space: |
<hl1>&middot;&middot;&middot;&middot;</hl1>By four
<hl1>&middot;&middot;&middot;&middot;</hl1><hl2>&middot;&middot;</hl2>spaces
<hl1>&middot;</hl1>Flow style: [    # Leading spaces
<hl1>&middot;&middot;</hl1><hl3>&middot;</hl3>By two,        # in flow style
<hl1>&middot;&middot;</hl1>Also by two,    # are neither
<hl1>&middot;&middot;</hl1>&rarr;Still by two   # content nor
<hl1>&middot;&middot;</hl1><hl3>&middot;&middot;</hl3>]             # indentation.
</programlisting>
<synopsis>Legend:
  <hl1><link linkend="s-indent(n)">s-indent(n)</link></hl1> <hl2>Content</hl2>
  <hl3>Neither content nor indentation</hl3>
</synopsis>
          </member>
          <member>
<programlisting>%YAML 1.2<sbr/>
- - -
!!map {
  ? !!str "Not indented"
  : !!map {
      ? !!str "By one space"
      : !!str "By four\n  spaces\n",
      ? !!str "Flow style"
      : !!seq [
          !!str "By two",
          !!str "Also by two",
          !!str "Still by two",
        ]
    }
}
</programlisting>
          </member>
        </simplelist>
      </example>

      <para>
        The <refterm primary="- block sequence
        entry"><uquote>-</uquote></refterm>, <refterm primary="? mapping
        key"><uquote>?</uquote></refterm> and <refterm primary=": mapping
        value"><uquote>:</uquote></refterm> characters used to denote <refterm
        primary="style" secondary="block" tertiary="collection">block
        collection</refterm> entries are perceived by people to be part of the
        indentation. This is handled on a case-by-case basis by the relevant
        productions.
      </para>

      <example>
        <title>Indentation Indicators</title>

        <simplelist type="horiz" columns="2">
          <member>
<programlisting><HL><hl1><hl3>?</hl3></hl1></HL>&middot;a<sbr/>
<HL><hl1><hl3>:</hl3><hl2>&middot;</hl2><hl3>-</hl3></hl1></HL>&rarr;b
<HL><hl1><hl2>&middot;&middot;</hl2><hl3>-</hl3><hl2>&middot;&middot;</hl2><hl3>-</hl3></hl1></HL>&rarr;c
<HL><hl1><hl2>&middot;&middot;&middot;&middot;&middot;</hl2><hl3>-</hl3></hl1></HL>&middot;d
</programlisting>
<synopsis>Legend:
  <hl1>Total Indentation</hl1>
  <hl2><link linkend="s-indent(n)">s-indent(n)</link></hl2> <hl3>Indicator as indentation</hl3>
</synopsis>
            </member>
            <member>
<programlisting>%YAML 1.2<sbr/>
---
!!map {
  ? !!str "a"
  : !!seq [
    !!str "b",
    !!seq [ !!str "c", !!str "d" ]
  ],
}
</programlisting>
          </member>
        </simplelist>
      </example>
    </sect1>

    <sect1>
      <title>Separation Spaces</title>

      <para>
        Outside <refterm primary="space"
        secondary="indentation">indentation</refterm> and <refterm
        primary="scalar">scalar content</refterm>, YAML uses <refterm
        primary="space" secondary="white">white space</refterm> characters for
        <defterm primary="space" secondary="separation">separation</defterm>
        between tokens within a line. Note that such <refterm primary="space"
        secondary="white">white space</refterm> may safely include <refterm
        primary="tab">tab</refterm> characters.
      </para>

      <para>
        Separation spaces are a <refterm primary="presentation"
        secondary="detail">presentation detail</refterm> and must not be used
        to convey <refterm primary="content">content</refterm> information.
      </para>

      <productionset>
        <production id="s-separate-in-line">
          <lhs>s-separate-in-line</lhs>
          <rhs>
              <nonterminal def="#s-white"/>+ | /* Start of line */
          </rhs>
        </production>
      </productionset>

      <example>
        <title>Separation Spaces</title>

        <simplelist type="horiz" columns="2">
          <member>
<programlisting>-<hl1>&middot;</hl1>foo:<hl1>&rarr;&middot;</hl1>bar<sbr/>
- -<hl1>&middot;</hl1>baz
  -<hl1>&rarr;</hl1>baz
</programlisting>
<synopsis>Legend:
  <hl1><link linkend="s-separate-in-line">s-separate-in-line</link></hl1>
</synopsis>
          </member>
          <member>
<programlisting>%YAML 1.2<sbr/>
---
!!seq [
  !!map {
    ? !!str "foo" : !!str "bar",
  },
  !!seq [ !!str "baz", !!str "baz" ],
]
</programlisting>
          </member>
        </simplelist>
      </example>
    </sect1>

    <sect1>
      <title>Line Prefixes</title>

      <para>
        Inside <refterm primary="scalar">scalar content</refterm>, each line
        begins with a non-<refterm primary="content">content</refterm> <defterm
        primary="line prefix">line prefix</defterm>. This prefix always
        includes the <refterm primary="space"
        secondary="indentation">indentation</refterm>. For <refterm
        primary="style" secondary="flow" tertiary="scalar">flow scalar
        styles</refterm> it additionally includes all leading <refterm
        primary="space" secondary="white">white space</refterm>, which may
        contain <refterm primary="tab">tab</refterm> characters.
      </para>

      <para>
        Line prefixes are a <refterm primary="presentation"
        secondary="detail">presentation detail</refterm> and must not be used
        to convey <refterm primary="content">content</refterm> information.
      </para>

      <productionset>
        <production id="s-line-prefix(n,c)">
          <lhs>s-line-prefix(n,c)</lhs>
          <rhs>
            <varname>c</varname> = block-out &rArr;
            <nonterminal def="#s-block-line-prefix(n)"/><sbr/>
            <varname>c</varname> = block-in&nbsp; &rArr;
            <nonterminal def="#s-block-line-prefix(n)"/><sbr/>
            <varname>c</varname> = flow-out&nbsp; &rArr;
            <nonterminal def="#s-flow-line-prefix(n)"/><sbr/>
            <varname>c</varname> = flow-in&nbsp;&nbsp; &rArr;
            <nonterminal def="#s-flow-line-prefix(n)"/>
          </rhs>
        </production>

        <production id="s-block-line-prefix(n)">
          <lhs>s-block-line-prefix(n)</lhs>
          <rhs>
            <nonterminal def="#s-indent(n)"/>
          </rhs>
        </production>

        <production id="s-flow-line-prefix(n)">
          <lhs>s-flow-line-prefix(n)</lhs>
          <rhs>
            <nonterminal def="#s-indent(n)"/>
            <nonterminal def="#s-separate-in-line"/>?
          </rhs>
        </production>
      </productionset>

      <example>
        <title>Line Prefixes</title>

        <simplelist type="horiz" columns="2">
          <member>
<programlisting>plain: text<sbr/>
<HL><hl1><hl3>&middot;</hl3>&middot;</hl1></HL>lines
quoted: "text
<HL><hl1><hl3>&middot;</hl3>&middot;&rarr;</hl1></HL>lines"
block: |
<HL><hl2><hl3>&middot;&middot;</hl3></hl2></HL>text
<HL><hl2><hl3>&middot;&middot;</hl3></hl2></HL>&middot;&rarr;lines
</programlisting>
<synopsis>
Legend:
  <hl1><link linkend="s-flow-line-prefix(n)">s-flow-line-prefix(n)</link></hl1> <hl2><link linkend="s-block-line-prefix(n)">s-block-line-prefix(n)</link></hl2> <hl3><link linkend="s-indent(n)">s-indent(n)</link></hl3>
</synopsis>
          </member>
          <member>
<programlisting>%YAML 1.2<sbr/>
---
!!map {
  ? !!str "plain"
  : !!str "text lines",
  ? !!str "quoted"
  : !!str "text lines",
  ? !!str "block"
  : !!str "text\n&middot;&rarr;lines\n",
}
</programlisting>
          </member>
        </simplelist>
      </example>
    </sect1>

    <sect1>
      <title>Empty Lines</title>

      <para>
        An <defterm primary="empty line">empty line</defterm> line consists of
        the non-<refterm primary="content">content</refterm> <refterm
        primary="line prefix">prefix</refterm> followed by a <refterm
        primary="line break">line break</refterm>.
      </para>

      <productionset>
        <production id="l-empty(n,c)">
          <lhs>l-empty(n,c)</lhs>
          <rhs>
            ( <nonterminal def="#s-line-prefix(n,c)"/>
            | <nonterminal def="#s-indent(n)"
                >s-indent(&lt;n)</nonterminal> )<sbr/>
            <nonterminal def="#b-as-line-feed"/>
          </rhs>
        </production>
      </productionset>

      <para>
        The semantics of empty lines depend on the <refterm primary="style"
        secondary="scalar">scalar style</refterm> they appear in. This is
        handled on a case-by-case basis by the relevant productions.
      </para>

      <example>
        <title>Empty Lines</title>

        <simplelist type="horiz" columns="2">
          <member>
<programlisting>Folding:<sbr/>
  "Empty line
<hl1>&middot;&middot;&middot;&rarr;</hl1>
  as a line feed"
Chomping: |
  Clipped empty lines
<hl1>&middot;</hl1>
</programlisting>
<synopsis>Legend:
  <hl1><link linkend="l-empty(n,c)">l-empty(n,c)</link></hl1>
</synopsis>
          </member>
          <member>
<programlisting>%YAML 1.2<sbr/>
---
!!map {
  ? !!str "Folding"
  : !!str "Empty line\nas a line feed",
  ? !!str "Chomping"
  : !!str "Clipped empty lines\n",
}
</programlisting>
          </member>
        </simplelist>
      </example>
    </sect1>

    <sect1>
      <title>Line Folding</title>

      <para>
        <defterm primary="line folding">Line folding</defterm> allows long
        lines to be broken for readability, while retaining the semantics of
        the original long line. If a <refterm primary="line break">line
        break</refterm> is followed by an <refterm primary="empty line">empty
        line</refterm>, it is <defterm primary="trimming">trimmed</defterm>;
        the first <refterm primary="line break">line break</refterm> is
        discarded and the rest are retained as <refterm
        primary="content">content</refterm>.
      </para>

      <productionset>
        <production id="b-l-trimmed(n,c)">
          <lhs>b-l-trimmed(n,c)</lhs>
          <rhs>
            <nonterminal def="#b-non-content"/>
            <nonterminal def="#l-empty(n,c)"/>+
          </rhs>
        </production>
      </productionset>

      <para>
        Otherwise (the following line is not <refterm primary="empty
        line">empty</refterm>), the <refterm primary="line break">line
        break</refterm> is converted to a single <refterm
        primary="space">space</refterm> (<userinput>#x20</userinput>).
      </para>

      <productionset>
        <production id="b-as-space">
          <lhs>b-as-space</lhs>
          <rhs>
            <nonterminal def="#b-break"/>
          </rhs>
        </production>
      </productionset>

      <para>
        A folded non-<refterm primary="empty line">empty line</refterm> may end
        with either of the above <refterm primary="line break">line
        breaks</refterm>.
      </para>

      <productionset>
        <production id="b-l-folded(n,c)">
          <lhs>b-l-folded(n,c)</lhs>
          <rhs>
            <nonterminal def="#b-l-trimmed(n,c)"/>
            | <nonterminal def="#b-as-space"/>
          </rhs>
        </production>
      </productionset>

      <example>
        <title>Line Folding</title>

        <simplelist type="horiz" columns="2">
          <member>
<programlisting>&gt;-<sbr/>
  trimmed<hl1>&darr;
&middot;&middot;&darr;
&middot;&darr;
&darr;</hl1>
  as<hl2>&darr;</hl2>
  space
</programlisting>
          </member>
          <member>
<programlisting>%YAML 1.2<sbr/>
---
!!str "trimmed\n\n\nas space"
</programlisting>
<synopsis>&nbsp;Legend:
   <hl1><link linkend="b-l-trimmed(n,c)">b-l-trimmed(n,c)</link></hl1>
   <hl2><link linkend="b-as-space">b-as-space</link></hl2>
</synopsis>
          </member>
        </simplelist>
      </example>

      <para>
        The above rules are common to both the <refterm primary="style"
        secondary="block" tertiary="folded">folded block style</refterm> and
        the <refterm primary="style" secondary="flow" tertiary="scalar">scalar
        flow styles</refterm>. Folding does distinguish between these cases in
        the following way:
      </para>

      <variablelist>
        <varlistentry>
          <term>Block Folding</term>

          <listitem>
            <para>
              In the <refterm primary="style" secondary="block"
              tertiary="folded">folded block style</refterm>, the final
              <refterm primary="line break">line break</refterm> and trailing
              <refterm primary="empty line">empty lines</refterm> are subject
              to <refterm primary="chomping">chomping</refterm>, and are never
              folded. In addition, folding does not apply to <refterm
              primary="line break">line breaks</refterm> surrounding text lines
              that contain leading <refterm primary="space"
              secondary="white">white space</refterm>. Note that such a
              <refterm primary="more-indented">more-indented</refterm> line may
              consist only of such leading <refterm primary="space"
              secondary="white">white space</refterm>.
            </para>

            <para>
              The combined effect of the <defterm primary="line folding"
              secondary="block">block line folding</defterm> rules is that each
              <quote>paragraph</quote> is interpreted as a line, <refterm
              primary="empty line">empty lines</refterm> are interpreted as a
              line feed, and the formatting of <refterm
              primary="more-indented">more-indented</refterm> lines is
              preserved.
            </para>
          </listitem>
        </varlistentry>
      </variablelist>

      <example>
        <title>Block Folding</title>

        <simplelist type="horiz" columns="2">
          <member>
<programlisting>&gt;<sbr/>
<hl2>&middot;&middot;</hl2>foo<hl3>&middot;</hl3><hl1>&darr;</hl1>
<hl1>&middot;&darr;</hl1>
<hl2>&middot;&middot;</hl2><hl3>&rarr;&middot;</hl3>bar<hl1>&darr;</hl1>
<hl1>&darr;</hl1>
<hl2>&middot;&middot;</hl2>baz&darr;
</programlisting>
          </member>
          <member>
<programlisting>%YAML 1.2<sbr/>
--- !!str
"foo \n\n\t bar\n\nbaz\n"
</programlisting>
<synopsis>&nbsp;Legend:
   <hl1><link linkend="b-l-folded(n,c)">b-l-folded(n,c)</link></hl1>
   <hl2>Non-content spaces</hl2> <hl3>Content spaces</hl3>
</synopsis>
          </member>
        </simplelist>
      </example>

      <variablelist>
        <varlistentry>
          <term>Flow Folding</term>

          <listitem>
            <para>
              Folding in <refterm primary="style" secondary="flow">flow
              styles</refterm> provides more relaxed semantics. <refterm
              primary="style" secondary="flow">Flow styles</refterm> typically
              depend on explicit <refterm
              primary="indicator">indicators</refterm> rather than <refterm
              primary="space" secondary="indentation">indentation</refterm> to
              convey structure. Hence spaces preceding or following the text in
              a line are a <refterm primary="presentation"
              secondary="detail">presentation detail</refterm> and must not be
              used to convey <refterm primary="content">content</refterm>
              information. Once all such spaces have been discarded, all
              <refterm primary="line break">line breaks</refterm> are folded,
              without exception.
            </para>

            <para>
              The combined effect of the <defterm primary="line folding"
              secondary="flow">flow line folding</defterm> rules is that each
              <quote>paragraph</quote> is interpreted as a line, <refterm
              primary="empty line">empty lines</refterm> are interpreted as
              line feeds, and text can be freely <refterm
              primary="more-indented">more-indented</refterm> without affecting
              the <refterm primary="content">content</refterm> information.
            </para>
          </listitem>
        </varlistentry>
      </variablelist>

      <productionset>
        <production id="s-flow-folded(n)">
          <lhs>s-flow-folded(n)</lhs>
          <rhs>
            <nonterminal def="#s-separate-in-line"/>?
            <nonterminal def="#b-l-folded(n,c)"
              >b-l-folded(n,flow-in)</nonterminal><sbr/>
            <nonterminal def="#s-flow-line-prefix(n)"
              >s-flow-line-prefix(n)</nonterminal>
          </rhs>
        </production>
      </productionset>

      <example>
        <title>Flow Folding</title>

        <simplelist type="horiz" columns="2">
          <member>
<programlisting>"<HL><hl1>&darr;<sbr/>
<hl2>&middot;&middot;</hl2></hl1></HL>foo<HL><hl1><hl2>&middot;</hl2>&darr;
<hl2>&middot;</hl2>&darr;
<hl2>&middot;&middot;&rarr;&middot;</hl2></hl1></HL>bar<HL><hl1>&darr;
&darr;
<hl2>&middot;&middot;</hl2></hl1></HL>baz<hl1>&darr;
</hl1>"
</programlisting>
          </member>
          <member>
<programlisting>%YAML 1.2<sbr/>
--- !!str
" foo\nbar\nbaz "
</programlisting>
<synopsis>&nbsp;Legend:
   <hl1><link linkend="s-flow-folded(n)">s-flow-folded(n)</link></hl1>
   <hl2>Non-content spaces</hl2>
</synopsis>
          </member>
        </simplelist>
      </example>
    </sect1>

    <sect1>
      <title>Comments</title>

      <para>
        An explicit <defterm primary="comment">comment</defterm> is marked by a
        <defterm primary="# comment"><uquote>#</uquote> indicator</defterm>.
        Comments are a <refterm primary="presentation"
        secondary="detail">presentation detail</refterm> and must not be used
        to convey <refterm primary="content">content</refterm> information.
      </para>

      <para>
        Comments must be <refterm primary="space"
        secondary="separation">separated</refterm> from other tokens by
        <refterm primary="space" secondary="white">white space</refterm>
        characters. To ensure <refterm primary="JSON compatibility">JSON
        compatibility</refterm>, YAML <refterm
        primary="processor">processors</refterm> must allow for the omission of
        the final comment <refterm primary="line break">line break</refterm> of
        the input <refterm primary="stream">stream</refterm>. However, as this
        confuses many tools, YAML <refterm
        primary="processor">processors</refterm> should terminate the <refterm
        primary="stream">stream</refterm> with an explicit <refterm
        primary="line break">line break</refterm> on output.
      </para>

      <productionset>
        <production id="c-nb-comment-text">
          <lhs>c-nb-comment-text</lhs>
          <rhs>
            <nonterminal def="#c-comment"><quote>#</quote></nonterminal>
            <nonterminal def="#nb-char"/>*
          </rhs>
        </production>

        <production id="b-comment">
          <lhs>b-comment</lhs>
          <rhs>
            <nonterminal def="#b-non-content"/> | /* End of file */
          </rhs>
        </production>

        <production id="s-b-comment">
          <lhs>s-b-comment</lhs>
          <rhs>
            ( <nonterminal def="#s-separate-in-line"/>
            <nonterminal def="#c-nb-comment-text"/>? )?<sbr/>
            <nonterminal def="#b-comment"/>
          </rhs>
        </production>
      </productionset>

      <example>
        <title>Separated Comment</title>

        <simplelist type="horiz" columns="2">
          <member>
<programlisting>key:<HL><hl3>&middot;&middot;&middot;&middot;<hl1># Comment</hl1><hl2>&darr;</hl2></hl3></HL><sbr/>
  value<HL><hl3><hl2><emphasis>eof</emphasis></hl2></hl3></HL>
</programlisting>
<synopsis>Legend:
  <hl1><link linkend="c-nb-comment-text">c-nb-comment-text</link></hl1> <hl2><link linkend="b-comment">b-comment</link></hl2>
  <hl3><link linkend="s-b-comment">s-b-comment</link></hl3>
</synopsis>
            </member>
            <member>
<programlisting>%YAML 1.2<sbr/>
---
!!map {
  ? !!str "key"
  : !!str "value",
}
</programlisting>
          </member>
        </simplelist>
      </example>

      <para>
        Outside <refterm primary="scalar">scalar content</refterm>, comments
        may appear on a line of their own, independent of the <refterm
        primary="space" secondary="indentation">indentation</refterm> level.
        Note that outside <refterm primary="scalar">scalar content</refterm>, a
        line containing only <refterm primary="space" secondary="white">white
        space</refterm> characters is taken to be a comment line.
      </para>

      <productionset>
        <production id="l-comment">
          <lhs>l-comment</lhs>
          <rhs>
            <nonterminal def="#s-separate-in-line"/>
            <nonterminal def="#c-nb-comment-text"/>?
            <nonterminal def="#b-comment"/>
          </rhs>
        </production>
      </productionset>

      <example>
        <title>Comment Lines</title>

        <simplelist type="horiz" columns="2">
          <member>
<programlisting><HL><hl2>&middot;&middot;<hl1># Comment&darr;</hl1></hl2></HL><sbr/>
<HL><hl2>&middot;&middot;&middot;<hl1>&darr;</hl1></hl2></HL>
<HL><hl2><hl1>&darr;</hl1></hl2></HL>
</programlisting>
            </member>
            <member>
<programlisting># This stream contains no<sbr/>
# documents, only comments.
</programlisting>
<synopsis>&nbsp;Legend:
   <hl1><link linkend="s-b-comment">s-b-comment</link></hl1> <hl2><link linkend="l-comment">l-comment</link></hl2>
</synopsis>
          </member>
        </simplelist>
      </example>

      <para>
        In most cases, when a line may end with a comment, YAML allows it to be
        followed by additional comment lines. The only exception is a comment
        ending a <refterm primary="block scalar header">block scalar
        header</refterm>.
      </para>

      <productionset>
        <production id="s-l-comments">
          <lhs>s-l-comments</lhs>
          <rhs>
            ( <nonterminal def="#s-b-comment"/> | /* Start of line */ )<sbr/>
            <nonterminal def="#l-comment"/>*
          </rhs>
        </production>
      </productionset>

      <example>
        <title>Multi-Line Comments</title>

        <simplelist type="horiz" columns="2">
          <member>
<programlisting>key:<HL><hl3><hl1>&middot;&middot;&middot;&middot;# Comment&darr;</hl1><sbr/>
<hl2>&middot;&middot;&middot;&middot;&middot;&middot;&middot;&middot;# lines&darr;</hl2></hl3></HL>
  value<HL><hl3><hl1>&darr;</hl1>
<hl2>&darr;</hl2></hl3></HL>
</programlisting>
          </member>
          <member>
<programlisting>%YAML 1.2<sbr/>
---
!!map {
  ? !!str "key"
  : !!str "value",
}
</programlisting>
          </member>
        </simplelist>
<synopsis>Legend:
  <hl1><link linkend="s-b-comment">s-b-comment</link></hl1> <hl2><link linkend="l-comment">l-comment</link></hl2> <hl3><link linkend="s-l-comments">s-l-comments</link></hl3>
</synopsis>
      </example>
    </sect1>

    <sect1>
      <title>Separation Lines</title>

      <para>
        <refterm primary="key" secondary="implicit">Implicit keys</refterm> are
        restricted to a single line. In all other cases, YAML allows tokens to
        be separated by multi-line (possibly empty) <refterm
        primary="comment">comments</refterm>.
      </para>

      <para>
        Note that structures following multi-line comment separation must be
        properly <refterm primary="space"
        secondary="indentation">indented</refterm>, even though there is no
        such restriction on the separation <refterm
        primary="comment">comment</refterm> lines themselves.
      </para>

      <productionset>
        <production id="s-separate(n,c)">
          <lhs>s-separate(n,c)</lhs>
          <rhs>
            <varname>c</varname> = block-out &rArr;
            <nonterminal def="#s-separate-lines(n)"/><sbr/>
            <varname>c</varname> = block-in&nbsp; &rArr;
            <nonterminal def="#s-separate-lines(n)"/><sbr/>
            <varname>c</varname> = flow-out&nbsp; &rArr;
            <nonterminal def="#s-separate-lines(n)"/><sbr/>
            <varname>c</varname> = flow-in&nbsp;&nbsp; &rArr;
            <nonterminal def="#s-separate-lines(n)"/><sbr/>
            <varname>c</varname> = block-key &rArr;
            <nonterminal def="#s-separate-in-line"/><sbr/>
            <varname>c</varname> = flow-key&nbsp; &rArr;
            <nonterminal def="#s-separate-in-line"/>
          </rhs>
        </production>

        <production id="s-separate-lines(n)">
          <lhs>s-separate-lines(n)</lhs>
          <rhs>
            &nbsp;&nbsp;( <nonterminal def="#s-l-comments"/>
            <nonterminal def="#s-flow-line-prefix(n)"/> )<sbr/>
            | <nonterminal def="#s-separate-in-line"/>
          </rhs>
        </production>
      </productionset>

      <example>
        <title>Separation Spaces</title>

        <simplelist type="horiz" columns="2">
          <member>
<programlisting>{<hl1>&middot;</hl1>first:<hl1>&middot;</hl1>Sammy,<hl1>&middot;</hl1>last:<hl1>&middot;</hl1>Sosa<hl1>&middot;</hl1>}:<HL><hl2>&darr;<sbr/>
# Statistics:
<hl3>&middot;&middot;</hl3></hl2></HL>hr:<HL><hl2>&middot;&middot;# Home runs
<hl3>&middot;&middot;&middot;</hl3>&middot;&middot;</hl2></HL>65
<hl3>&middot;&middot;</hl3>avg:<HL><hl2>&middot;# Average
<hl3>&middot;&middot;&middot;</hl3></hl2></HL>0.278
</programlisting>
<synopsis>Legend:
  <hl1><link linkend="s-separate-in-line">s-separate-in-line</link></hl1>
  <hl2><link linkend="s-separate-lines(n)">s-separate-lines(n)</link></hl2>
  <hl3><link linkend="s-indent(n)">s-indent(n)</link></hl3>
</synopsis>
          </member>
          <member>
<programlisting>%YAML 1.2<sbr/>
---
!!map {
  ? !!map {
    ? !!str "first"
    : !!str "Sammy",
    ? !!str "last"
    : !!str "Sosa",
  }
  : !!map {
    ? !!str "hr"
    : !!int "65",
    ? !!str "avg"
    : !!float "0.278",
  },
}
</programlisting>
          </member>
        </simplelist>
      </example>
    </sect1>

    <sect1>
      <title>Directives</title>

      <para>
        <defterm primary="directive">Directives</defterm> are instructions to
        the YAML <refterm primary="processor">processor</refterm>. This
        specification defines two directives, <refterm primary="directive"
        secondary="YAML"><uquote>YAML</uquote></refterm> and <refterm
        primary="directive" secondary="TAG"><uquote>TAG</uquote></refterm>, and
        <defterm primary="directive" secondary="reserved">reserves</defterm>
        all other directives for future use. There is no way to define private
        directives. This is intentional.
      </para>

      <para>
        Directives are a <refterm primary="presentation"
        secondary="detail">presentation detail</refterm> and must not be used
        to convey <refterm primary="content">content</refterm> information.
      </para>

      <productionset>
        <production id="l-directive">
          <lhs>l-directive</lhs>
          <rhs>
            <nonterminal
              def="#c-directive"><quote>%</quote></nonterminal><sbr/>
            ( <nonterminal def="#ns-yaml-directive"/><sbr/>
            | <nonterminal def="#ns-tag-directive"/><sbr/>
            | <nonterminal def="#ns-reserved-directive"/> )<sbr/>
            <nonterminal def="#s-l-comments"/>
          </rhs>
        </production>
      </productionset>

      <pagebreak/>

      <para>
        Each directive is specified on a separate non-<refterm primary="space"
        secondary="indentation">indented</refterm> line starting with the
        <defterm primary="% directive"><uquote>%</uquote> indicator</defterm>,
        followed by the directive name and a list of parameters. The semantics
        of these parameters depends on the specific directive. A YAML <refterm
        primary="processor">processor</refterm> should ignore unknown
        directives with an appropriate warning.
      </para>

      <productionset>
        <production id="ns-reserved-directive">
          <lhs>ns-reserved-directive</lhs>
          <rhs>
            <nonterminal def="#ns-directive-name"/><sbr/>
            ( <nonterminal def="#s-separate-in-line"/>
              <nonterminal def="#ns-directive-parameter"/> )*
          </rhs>
        </production>

        <production id="ns-directive-name">
          <lhs>ns-directive-name</lhs>
          <rhs>
            <nonterminal def="#ns-char"/>+
          </rhs>
        </production>

        <production id="ns-directive-parameter">
          <lhs>ns-directive-parameter</lhs>
          <rhs>
            <nonterminal def="#ns-char"/>+
          </rhs>
        </production>
      </productionset>

      <example>
        <title>Reserved Directives</title>

        <simplelist type="horiz" columns="2">
          <member>
<programlisting>%<HL><hl1><hl2>FOO</hl2>  <hl3>bar</hl3> <hl3>baz</hl3></hl1></HL> # Should be ignored<sbr/>
               # with a warning.
--- "foo"
</programlisting>
          </member>
          <member>
<programlisting>%YAML 1.2<sbr/>
--- !!str
"foo"
</programlisting>
          </member>
        </simplelist>
<synopsis>Legend:
  <hl1><link linkend="ns-reserved-directive">ns-reserved-directive</link></hl1> <hl2><link linkend="ns-directive-name">ns-directive-name</link></hl2> <hl3><link linkend="ns-directive-parameter">ns-directive-parameter</link></hl3>
</synopsis>
      </example>

      <sect2>
        <title><uquote>YAML</uquote> Directives</title>

        <para>
          The <defterm primary="directive"
          secondary="YAML"><uquote>YAML</uquote> directive</defterm> specifies
          the version of YAML the <refterm
          primary="document">document</refterm> conforms to. This specification
          defines version <uquote>1.2</uquote>, including recommendations for
          <defterm primary="YAML 1.1 processing">YAML 1.1 processing</defterm>.
        </para>

        <para>
          A version 1.2 YAML <refterm primary="processor">processor</refterm>
          must accept <refterm primary="document">documents</refterm> with an
          explicit <uquote>%YAML 1.2</uquote> directive, as well as <refterm
          primary="document">documents</refterm> lacking a
          <uquote>YAML</uquote> directive. Such <refterm
          primary="document">documents</refterm> are assumed to conform to the
          1.2 version specification. <refterm
          primary="document">Documents</refterm> with a <uquote>YAML</uquote>
          directive specifying a higher minor version (e.g.
          <uquote>%YAML&nbsp;1.3</uquote>) should be processed with an
          appropriate warning. <refterm primary="document">Documents</refterm>
          with a <uquote>YAML</uquote> directive specifying a higher major
          version (e.g. <uquote>%YAML&nbsp;2.0</uquote>) should be rejected
          with an appropriate error message.
        </para>

        <para>
          A version 1.2 YAML <refterm primary="processor">processor</refterm>
          must also accept <refterm primary="document">documents</refterm> with
          an explicit <uquote>%YAML 1.1</uquote> directive. Note that version
          1.2 is mostly a superset of version 1.1, defined for the purpose of
          ensuring <defterm primary="JSON compatibility">JSON
          compatibility</defterm>. Hence a version 1.2 <refterm
          primary="processor">processor</refterm> should process version 1.1
          <refterm primary="document">documents</refterm> as if they were
          version 1.2, giving a warning on points of incompatibility (handling
          of <refterm primary="line break" secondary="non-ASCII">non-ASCII line
          breaks</refterm>, as described <link linkend="non-ASCII line
          breaks">above</link>).
        </para>

        <productionset>
          <production id="ns-yaml-directive">
            <lhs>ns-yaml-directive</lhs>
            <rhs>
              <quote>Y</quote> <quote>A</quote>
              <quote>M</quote> <quote>L</quote><sbr/>
              <nonterminal def="#s-separate-in-line"/>
              <nonterminal def="#ns-yaml-version"/>
            </rhs>
          </production>

          <production id="ns-yaml-version">
            <lhs>ns-yaml-version</lhs>
            <rhs>
              <nonterminal def="#ns-dec-digit"/>+
              <quote>.</quote>
              <nonterminal def="#ns-dec-digit"/>+
            </rhs>
          </production>
        </productionset>

        <example>
          <title><uquote>YAML</uquote> directive</title>

          <simplelist type="horiz" columns="2">
            <member>
<programlisting>%<HL><hl1>YAML <hl2>1.3</hl2></hl1></HL> # Attempt parsing<sbr/>
           # with a warning
---
"foo"
</programlisting>
            </member>
            <member>
<programlisting>%YAML 1.2<sbr/>
---
!!str "foo"
</programlisting>
<synopsis>&nbsp;Legend:
   <hl1><link linkend="ns-yaml-directive">ns-yaml-directive</link></hl1> <hl2><link linkend="ns-yaml-version">ns-yaml-version</link></hl2>
</synopsis>
            </member>
          </simplelist>
        </example>

        <para>
          It is an error to specify more than one <uquote>YAML</uquote>
          directive for the same document, even if both occurrences give the
          same version number.
        </para>

        <example>
          <title>Invalid Repeated YAML directive</title>

          <simplelist type="horiz" columns="2">
            <member>
<screen>%YAML 1.2<sbr/>
%<hl1>YAML</hl1> 1.1
foo
</screen>
            </member>
            <member>
<screen>ERROR:<sbr/>
The <hl1>YAML</hl1> directive must only be
given at most once per document.
</screen>
            </member>
          </simplelist>
        </example>
      </sect2>

      <sect2>
        <title><uquote>TAG</uquote> Directives</title>

        <para>
          The <defterm primary="directive" secondary="TAG"><uquote>TAG</uquote>
          directive</defterm> establishes a <refterm primary="tag"
          secondary="shorthand">tag shorthand</refterm> notation for specifying
          <refterm primary="tag">node tags</refterm>. Each <uquote>TAG</uquote>
          directive associates a <refterm primary="tag"
          secondary="handle">handle</refterm> with a <refterm primary="tag"
          secondary="prefix">prefix</refterm>. This allows for compact and
          readable <refterm primary="tag">tag</refterm> notation.
        </para>

        <productionset>
          <production id="ns-tag-directive">
            <lhs>ns-tag-directive</lhs>
            <rhs>
              <quote>T</quote> <quote>A</quote> <quote>G</quote><sbr/>
              <nonterminal def="#s-separate-in-line"/>
              <nonterminal def="#c-tag-handle"/><sbr/>
              <nonterminal def="#s-separate-in-line"/>
              <nonterminal def="#ns-tag-prefix"/>
            </rhs>
          </production>
        </productionset>

        <example>
          <title><uquote>TAG</uquote> directive</title>

          <simplelist type="horiz" columns="2">
            <member>
<programlisting>%<HL><hl1>TAG <hl2>!yaml!</hl2> <hl3>tag:yaml.org,2002:</hl3></hl1></HL><sbr/>
---
!yaml!str "foo"
</programlisting>
            </member>
            <member>
<programlisting>%YAML 1.2<sbr/>
---
!!str "foo"
</programlisting>
            </member>
          </simplelist>
<synopsis>Legend:
  <hl1><link linkend="ns-tag-directive">ns-tag-directive</link></hl1> <hl2><link linkend="c-tag-handle">c-tag-handle</link></hl2> <hl3><link linkend="ns-tag-prefix">ns-tag-prefix</link></hl3>
</synopsis>
        </example>

        <para>
          It is an error to specify more than one <uquote>TAG</uquote>
          directive for the same <refterm primary="tag"
          secondary="handle">handle</refterm> in the same document, even if
          both occurrences give the same <refterm primary="tag"
          secondary="prefix">prefix</refterm>.
        </para>

        <example>
          <title>Invalid Repeated TAG directive</title>

          <simplelist type="horiz" columns="2">
            <member>
<screen>%TAG ! !foo<sbr/>
%TAG <hl1>!</hl1> !foo
bar
</screen>
            </member>
            <member>
<screen>ERROR:<sbr/>
The TAG directive must only
be given at most once per
<hl1>handle</hl1> in the same document.
</screen>
            </member>
          </simplelist>
        </example>

        <sect3>
          <title>Tag Handles</title>

          <para>
            The <defterm primary="tag" secondary="handle">tag handle</defterm>
            exactly matches the prefix of the affected <refterm primary="tag"
            secondary="shorthand">tag shorthand</refterm>. There are three tag
            handle variants:
          </para>

          <productionset>
            <production id="c-tag-handle">
              <lhs>c-tag-handle</lhs>
              <rhs>
                &nbsp;&nbsp;<nonterminal def="#c-named-tag-handle"/><sbr/>
                | <nonterminal def="#c-secondary-tag-handle"/><sbr/>
                | <nonterminal def="#c-primary-tag-handle"/>
              </rhs>
            </production>
          </productionset>

          <variablelist>
            <varlistentry>
              <term>Primary Handle</term>

              <listitem>
                <para>
                  The <defterm primary="tag" secondary="handle"
                  tertiary="primary">primary tag handle</defterm> is a single
                  <defterm primary="! tag indicator" secondary="! primary tag
                  handle"><uquote>!</uquote></defterm> character. This allows
                  using the most compact possible notation for a single
                  <quote>primary</quote> name space. By default, the prefix
                  associated with this handle is <refterm primary="! tag
                  indicator" secondary="! local
                  tag"><uquote>!</uquote></refterm>. Thus, by default, <refterm
                  primary="tag" secondary="shorthand">shorthands</refterm>
                  using this handle are interpreted as <refterm primary="tag"
                  secondary="local">local tags</refterm>.
                </para>

                <para>
                  It is possible to override the default behavior by providing
                  an explicit <uquote>TAG</uquote> directive, associating a
                  different prefix for this handle. This provides smooth
                  migration from using <refterm primary="tag"
                  secondary="local">local tags</refterm> to using <refterm
                  primary="tag" secondary="global">global tags</refterm>, by
                  the simple addition of a single <uquote>TAG</uquote>
                  directive.
                </para>
              </listitem>
            </varlistentry>
          </variablelist>

          <productionset>
            <production id="c-primary-tag-handle">
              <lhs>c-primary-tag-handle</lhs>
              <rhs>
                <nonterminal def="#c-tag"><quote>!</quote></nonterminal>
              </rhs>
            </production>
          </productionset>

          <example>
            <title>Primary Tag Handle</title>

            <simplelist type="horiz" columns="2">
              <member>
<programlisting># Private<sbr/>
<hl1>!</hl1>foo "bar"
...
# Global
%TAG <hl1>!</hl1> tag:example.com,2000:app/
---
<hl1>!</hl1>foo "bar"
</programlisting>
              </member>
              <member>
<programlisting>%YAML 1.2<sbr/>
---
!&lt;!foo&gt; "bar"
...
---
!&lt;tag:example.com,2000:app/foo&gt; "bar"
</programlisting>
<synopsis>Legend:
  <hl1><link linkend="c-primary-tag-handle">c-primary-tag-handle</link></hl1>
</synopsis>
              </member>
            </simplelist>
          </example>

          <variablelist>
            <varlistentry>
              <term>Secondary Handle</term>

              <listitem>
                <para>
                  The <defterm primary="tag" secondary="handle"
                  tertiary="secondary">secondary tag handle</defterm> is
                  written as <defterm primary="! tag indicator" secondary="!!
                  secondary tag handle"><uquote>!!</uquote></defterm>. This
                  allows using a compact notation for a single
                  <quote>secondary</quote> name space. By default, the prefix
                  associated with this handle is
                  <uquote>tag:yaml.org,2002:</uquote>. This prefix is used by
                  the <refterm primary="tag" secondary="repository">YAML tag
                  repository</refterm>.
                </para>

                <para>
                  It is possible to override this default behavior by providing
                  an explicit <uquote>TAG</uquote> directive associating a
                  different prefix for this handle.
                </para>
              </listitem>
            </varlistentry>
          </variablelist>

          <productionset>
            <production id="c-secondary-tag-handle">
              <lhs>c-secondary-tag-handle</lhs>
              <rhs>
                <nonterminal def="#c-tag"><quote>!</quote></nonterminal>
                <nonterminal def="#c-tag"><quote>!</quote></nonterminal>
              </rhs>
            </production>
          </productionset>

          <example>
            <title>Secondary Tag Handle</title>

            <simplelist type="horiz" columns="2">
              <member>
<programlisting>%TAG <hl1>!!</hl1> tag:example.com,2000:app/<sbr/>
---
<hl1>!!</hl1>int 1 - 3 # Interval, not integer
</programlisting>
<synopsis>Legend:
  <hl1><link linkend="c-secondary-tag-handle">c-secondary-tag-handle</link></hl1>
</synopsis>
              </member>
              <member>
<programlisting>%YAML 1.2<sbr/>
---
!&lt;tag:example.com,2000:app/int&gt; "1 - 3"
</programlisting>
              </member>
            </simplelist>
          </example>

          <variablelist>
            <varlistentry>
              <term>Named Handles</term>

              <listitem>
                <para>
                  A <defterm primary="tag" secondary="handle"
                  tertiary="named">named tag handle</defterm> surrounds a
                  non-empty name with <defterm primary="! tag indicator"
                  secondary="!&hellip;! named
                  handle"><uquote>!</uquote></defterm> characters. A handle
                  name must not be used in a <refterm primary="tag"
                  secondary="shorthand">tag shorthand</refterm> unless an
                  explicit <uquote>TAG</uquote> directive has associated some
                  prefix with it.
                </para>

                <para>
                  The name of the handle is a <refterm primary="presentation"
                  secondary="detail">presentation detail</refterm> and must not
                  be used to convey <refterm
                  primary="content">content</refterm> information. In
                  particular, the YAML <refterm
                  primary="processor">processor</refterm> need not preserve the
                  handle name once <refterm primary="parse">parsing</refterm>
                  is completed.
                </para>
              </listitem>
            </varlistentry>
          </variablelist>

          <productionset>
            <production id="c-named-tag-handle">
              <lhs>c-named-tag-handle</lhs>
              <rhs>
                <nonterminal def="#c-tag"><quote>!</quote></nonterminal>
                <nonterminal def="#ns-word-char"/>+
                <nonterminal def="#c-tag"><quote>!</quote></nonterminal>
              </rhs>
            </production>
          </productionset>

          <example>
            <title>Tag Handles</title>

            <simplelist type="horiz" columns="2">
              <member>
<programlisting>%TAG <hl1>!e!</hl1> tag:example.com,2000:app/<sbr/>
---
<hl1>!e!</hl1>foo "bar"
</programlisting>
<synopsis>Legend:
  <hl1><link linkend="c-named-tag-handle">c-named-tag-handle</link></hl1>
</synopsis>
              </member>
              <member>
<programlisting>%YAML 1.2<sbr/>
---
!&lt;tag:example.com,2000:app/foo&gt; "bar"
</programlisting>
              </member>
            </simplelist>
          </example>
        </sect3>

        <pagebreak/>

        <sect3>
          <title>Tag Prefixes</title>

          <para>
            There are two <defterm primary="tag" secondary="prefix">tag
            prefix</defterm> variants:
          </para>

          <productionset>
            <production id="ns-tag-prefix">
              <lhs>ns-tag-prefix</lhs>
              <rhs>
                <nonterminal def="#c-ns-local-tag-prefix"/>
                | <nonterminal def="#ns-global-tag-prefix"/>
              </rhs>
            </production>
          </productionset>

          <variablelist>
            <varlistentry>
              <term>Local Tag Prefix</term>

              <listitem>
                If the prefix begins with a <refterm primary="! tag indicator"
                secondary="! local tag"><uquote>!</uquote></refterm> character,
                <refterm primary="tag"
                secondary="shorthand">shorthands</refterm> using the <refterm
                primary="tag" secondary="handle">handle</refterm> are expanded
                to a <refterm primary="tag" secondary="local">local
                tag</refterm>. Note that such a <refterm
                primary="tag">tag</refterm> is intentionally not a valid URI,
                and its semantics are specific to the <refterm
                primary="application">application</refterm>. In particular, two
                <refterm primary="document">documents</refterm> in the same
                <refterm primary="stream">stream</refterm> may assign different
                semantics to the same <refterm primary="tag"
                secondary="local">local tag</refterm>.
              </listitem>
            </varlistentry>
          </variablelist>

          <productionset>
            <production id="c-ns-local-tag-prefix">
              <lhs>c-ns-local-tag-prefix</lhs>
              <rhs>
              <nonterminal def="#c-tag"><quote>!</quote></nonterminal>
                <nonterminal def="#ns-uri-char"/>*
              </rhs>
            </production>
          </productionset>

          <example>
            <title>Local Tag Prefix</title>

            <simplelist type="horiz" columns="2">
              <member>
<programlisting>%TAG !m! <hl1>!my-</hl1><sbr/>
--- # Bulb here
!m!light fluorescent
...
%TAG !m! <hl1>!my-</hl1>
--- # Color here
!m!light green
</programlisting>
<synopsis>Legend:
  <hl1><link linkend="c-ns-local-tag-prefix">c-ns-local-tag-prefix</link></hl1>
</synopsis>
              </member>
              <member>
<programlisting>%YAML 1.2<sbr/>
---
!&lt;!my-light&gt; "fluorescent"
...
%YAML 1.2
---
!&lt;!my-light&gt; "green"
</programlisting>
              </member>
            </simplelist>
          </example>

          <variablelist>
            <varlistentry>
              <term>Global Tag Prefix</term>

              <listitem>
                If the prefix begins with a character other than <refterm
                primary="! tag indicator" secondary="! local
                tag"><uquote>!</uquote></refterm>, it must be a valid URI
                prefix, and should contain at least the scheme and the
                authority. <refterm primary="tag"
                secondary="shorthand">Shorthands</refterm> using the associated
                <refterm primary="tag" secondary="handle">handle</refterm> are
                expanded to globally unique URI tags, and their semantics is
                consistent across <refterm
                primary="application">applications</refterm>. In particular,
                every <refterm primary="document">documents</refterm> in every
                <refterm primary="stream">stream</refterm> must assign the same
                semantics to the same <refterm primary="tag"
                secondary="global">global tag</refterm>.
              </listitem>
            </varlistentry>
          </variablelist>

          <productionset>
            <production id="ns-global-tag-prefix">
              <lhs>ns-global-tag-prefix</lhs>
              <rhs>
                <nonterminal def="#ns-tag-char"/>
                <nonterminal def="#ns-uri-char"/>*
              </rhs>
            </production>
          </productionset>

          <example>
            <title>Global Tag Prefix</title>

            <simplelist type="horiz" columns="2">
              <member>
<programlisting>%TAG !e! <hl1>tag:example.com,2000:app/</hl1><sbr/>
---
- !e!foo "bar"
</programlisting>
<synopsis>Legend:
  <hl1><link linkend="ns-global-tag-prefix">ns-global-tag-prefix</link></hl1>
</synopsis>
              </member>
              <member>
<programlisting>%YAML 1.2<sbr/>
---
!&lt;tag:example.com,2000:app/foo&gt; "bar"
</programlisting>
              </member>
            </simplelist>
          </example>
        </sect3>
      </sect2>
    </sect1>

    <sect1>
      <title>Node Properties</title>

      <para>
        Each <refterm primary="node">node</refterm> may have two optional
        <defterm primary="node" secondary="property">properties</defterm>,
        <refterm primary="anchor" >anchor</refterm> and <refterm
        primary="tag">tag</refterm>, in addition to its <refterm
        primary="content">content</refterm>. Node properties may be specified
        in any order before the <refterm primary="content">node<q/>s
        content</refterm>. Either or both may be omitted.
      </para>

      <productionset>
        <production id="c-ns-properties(n,c)">
          <lhs>c-ns-properties(n,c)</lhs>
          <rhs>
            &nbsp;&nbsp;( <nonterminal def="#c-ns-tag-property"/><sbr/>
            &nbsp;&nbsp;&nbsp;&nbsp;(
            <nonterminal def="#s-separate(n,c)"/>
            <nonterminal def="#c-ns-anchor-property"/> )? )<sbr/>
            | ( <nonterminal def="#c-ns-anchor-property"/><sbr/>
            &nbsp;&nbsp;&nbsp;&nbsp;(
            <nonterminal def="#s-separate(n,c)"/>
            <nonterminal def="#c-ns-tag-property"/> )? )
          </rhs>
        </production>
      </productionset>

      <example>
        <title>Node Properties</title>

        <simplelist type="horiz" columns="2">
          <member>
<programlisting><HL><hl1><hl3>!!str</hl3> <hl2>&amp;a1</hl2></hl1></HL> "foo":<sbr/>
  <HL><hl1><hl3>!!str</hl3></hl1></HL> bar
<HL><hl1><hl2>&amp;a2</hl2></hl1></HL> baz : *a1
</programlisting>
<synopsis>Legend:
  <hl1><link linkend="c-ns-properties(n,c)">c-ns-properties(n,c)</link></hl1>
  <hl2><link linkend="c-ns-anchor-property">c-ns-anchor-property</link></hl2>
  <hl3><link linkend="c-ns-tag-property">c-ns-tag-property</link></hl3>
</synopsis>
        </member>
        <member>
<programlisting>%YAML 1.2<sbr/>
---
!!map {
  ? &amp;B1 !!str "foo"
  : !!str "bar",
  ? !!str "baz"
  : *B1,
}
</programlisting>
          </member>
        </simplelist>
      </example>

      <sect2>
        <title>Node Tags</title>

        <para>
          The <defterm primary="tag" secondary="property">tag
          property</defterm> identifies the type of the <refterm
          primary="native data structure">native data structure</refterm>
          <refterm primary="present">presented</refterm> by the <refterm
          primary="node">node</refterm>. A tag is denoted by the <defterm
          primary="! tag indicator"><uquote>!</uquote> indicator</defterm>.
        </para>

        <productionset>
          <production id="c-ns-tag-property">
            <lhs>c-ns-tag-property</lhs>
            <rhs>
              &nbsp;&nbsp;<nonterminal def="#c-verbatim-tag"/><sbr/>
              | <nonterminal def="#c-ns-shorthand-tag"/><sbr/>
              | <nonterminal def="#c-non-specific-tag"/>
            </rhs>
          </production>
        </productionset>

        <variablelist>
          <varlistentry>
            <term>Verbatim Tags</term>

            <listitem>
              A tag may be written <defterm primary="tag"
              secondary="verbatim">verbatim</defterm> by surrounding it with
              the <defterm primary="&lt;&hellip;&gt; verbatim
              tag"><uquote>&lt;</uquote> and <uquote>&gt;</uquote></defterm>
              characters. In this case, the YAML <refterm
              primary="processor">processor</refterm> must deliver the verbatim
              tag as-is to the <refterm
              primary="application">application</refterm>. In particular,
              verbatim tags are not subject to <refterm primary="tag"
              secondary="resolution">tag resolution</refterm>. A verbatim tag
              must either begin with a <refterm primary="! tag indicator"
              secondary="! local tag"><uquote>!</uquote></refterm> (a <refterm
              primary="tag" secondary="local">local tag</refterm>) or be a
              valid URI (a <refterm primary="tag" secondary="global">global
              tag</refterm>).
            </listitem>
          </varlistentry>
        </variablelist>

        <productionset>
          <production id="c-verbatim-tag">
            <lhs>c-verbatim-tag</lhs>
            <rhs>
              <nonterminal def="#c-tag"><quote>!</quote></nonterminal>
              <quote>&lt;</quote>
              <nonterminal def="#ns-uri-char"/>+
              <quote>&gt;</quote>
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Verbatim Tags</title>

          <simplelist type="horiz" columns="2">
            <member>
<programlisting><hl1>!&lt;tag:yaml.org,2002:str&gt;</hl1> foo :<sbr/>
  <hl1>!&lt;!bar&gt;</hl1> baz
</programlisting>
<synopsis>Legend:
  <hl1><link linkend="c-verbatim-tag">c-verbatim-tag</link></hl1>
</synopsis>
            </member>
            <member>
<programlisting>%YAML 1.2<sbr/>
---
!!map {
  ? !&lt;tag:yaml.org,2002:str&gt; "foo"
  : !&lt;!bar&gt; "baz",
}
</programlisting>
          </member>
        </simplelist>
      </example>

      <example>
        <title>Invalid Verbatim Tags</title>

        <simplelist type="horiz" columns="2">
          <member>
<screen>- !&lt;<hl1>!</hl1>&gt; foo<sbr/>
- !&lt;<hl2>$:?</hl2>&gt; bar
</screen>
          </member>
          <member>
<screen>ERROR:<sbr/>
- Verbatim tags aren't resolved,
  so <hl1>!</hl1> is invalid.
- The <hl2>$:?</hl2> tag is neither a global
  URI tag nor a local tag starting
  with <quote>!</quote>.
</screen>
            </member>
          </simplelist>
        </example>

        <pagebreak/>

        <variablelist>
          <varlistentry>
            <term>Tag Shorthands</term>

            <listitem>
              <para>
                A <defterm primary="tag" secondary="shorthand">tag
                shorthand</defterm> consists of a valid <refterm primary="tag"
                secondary="handle">tag handle</refterm> followed by a non-empty
                suffix. The <refterm primary="tag" secondary="handle">tag
                handle</refterm> must be associated with a <refterm
                primary="tag" secondary="prefix">prefix</refterm>, either by
                default or by using a <refterm primary="directive"
                secondary="TAG"><uquote>TAG</uquote> directive</refterm>. The
                resulting <refterm primary="parse">parsed</refterm> <refterm
                primary="tag">tag</refterm> is the concatenation of the
                <refterm primary="tag" secondary="prefix">prefix</refterm> and
                the suffix, and must either begin with <refterm primary="! tag
                indicator" secondary="! local tag"><uquote>!</uquote></refterm>
                (a <refterm primary="tag" secondary="local">local
                tag</refterm>) or be a valid URI (a <refterm primary="tag"
                secondary="global">global tag</refterm>).
              </para>

              <para>
                The choice of <refterm primary="tag" secondary="handle">tag
                handle</refterm> is a <refterm primary="presentation"
                secondary="detail">presentation detail</refterm> and must not
                be used to convey <refterm primary="content">content</refterm>
                information. In particular, the <refterm primary="tag"
                secondary="handle">tag handle</refterm> may be discarded once
                <refterm primary="parse">parsing</refterm> is completed.
              </para>

              <para>
                The suffix must not contain any <refterm primary="! tag
                indicator" secondary="!&hellip;! named
                handle"><uquote>!</uquote></refterm> character. This would
                cause the tag shorthand to be interpreted as having a <refterm
                primary="tag" secondary="handle" tertiary="named">named tag
                handle</refterm>. In addition, the suffix must not contain the
                <refterm primary="[ start flow
                sequence"><uquote>[</uquote></refterm>, <refterm primary="] end
                flow sequence"><uquote>]</uquote></refterm>, <refterm
                primary="{ start flow mapping"><uquote>{</uquote></refterm>,
                <refterm primary="} end flow
                mapping"><uquote>}</uquote></refterm> and <refterm primary=",
                end flow entry"><uquote>,</uquote></refterm> characters. These
                characters would cause ambiguity with <refterm primary="style"
                secondary="flow" tertiary="collection">flow
                collection</refterm> structures. If the suffix needs to specify
                any of the above restricted characters, they must be <refterm
                primary="% escaping in URI">escaped</refterm> using the
                <refterm primary="% escaping in
                URI"><uquote>%</uquote></refterm> character. This behavior is
                consistent with the URI character escaping rules (specifically,
                section 2.3 of <ulink
                url="http://www.ietf.org/rfc/rfc2396.txt">RFC2396</ulink>).
              </para>
            </listitem>
          </varlistentry>
        </variablelist>

        <productionset>
          <production id="c-ns-shorthand-tag">
            <lhs>c-ns-shorthand-tag</lhs>
            <rhs>
              <nonterminal def="#c-tag-handle"/>
              <nonterminal def="#ns-tag-char"/>+
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Tag Shorthands</title>

          <simplelist type="horiz" columns="2">
            <member>
<programlisting>%TAG !e! tag:example.com,2000:app/<sbr/>
---
- <hl1>!local</hl1> foo
- <hl1>!!str</hl1> bar
- <hl1>!e!tag%21</hl1> baz
</programlisting>
<synopsis>Legend:
  <hl1><link linkend="c-ns-shorthand-tag">c-ns-shorthand-tag</link></hl1>
</synopsis>
            </member>
            <member>
<programlisting>%YAML 1.2<sbr/>
---
!!seq [
  !&lt;!local&gt; "foo",
  !&lt;tag:yaml.org,2002:str&gt; "bar",
  !&lt;tag:example.com,2000:app/tag!&gt; "baz"
]
</programlisting>
            </member>
          </simplelist>
        </example>

        <example>
          <title>Invalid Tag Shorthands</title>

          <simplelist type="horiz" columns="2">
            <member>
<screen>%TAG !e! tag:example,2000:app/<sbr/>
---
- <hl1>!e!</hl1> foo
- <hl2>!h!</hl2>bar baz
</screen>
            </member>
            <member>
<screen>ERROR:<sbr/>
- The <hl1>!o!</hl1> handle has no suffix.
- The <hl2>!h!</hl2> handle wasn't declared.
</screen>
            </member>
          </simplelist>
        </example>

        <variablelist>
          <varlistentry>
            <term>Non-Specific Tags</term>

            <listitem>
              <para>
                If a <refterm primary="node">node</refterm> has no tag
                property, it is assigned a <refterm primary="tag"
                secondary="non-specific">non-specific tag</refterm> that needs
                to be <refterm primary="tag"
                secondary="resolution">resolved</refterm> to a <refterm
                primary="tag" secondary="specific">specific</refterm> one. This
                <refterm primary="tag" secondary="non-specific">non-specific
                tag</refterm> is <refterm primary="! tag indicator"
                secondary="! non-specific tag"><uquote>!</uquote></refterm> for
                non-<refterm primary="style" secondary="flow"
                tertiary="plain">plain scalars</refterm> and <refterm
                primary="? non-specific tag"><uquote>?</uquote></refterm> for
                all other <refterm primary="node">nodes</refterm>. This is the
                only case where the <refterm primary="style">node
                style</refterm> has any effect on the <refterm
                primary="content">content</refterm> information.
              </para>

              <para>
                It is possible for the tag property to be explicitly set to the
                <refterm primary="! tag indicator" secondary="! non-specific
                tag"><uquote>!</uquote> non-specific tag</refterm>. By <refterm
                primary="tag" secondary="resolution"
                tertiary="convention">convention</refterm>, this
                <quote>disables</quote> <refterm primary="tag"
                secondary="resolution">tag resolution</refterm>, forcing the
                <refterm primary="node">node</refterm> to be interpreted as
                <uquote>tag:yaml.org,2002:seq</uquote>,
                <uquote>tag:yaml.org,2002:map</uquote>, or
                <uquote>tag:yaml.org,2002:str</uquote>, according to its
                <refterm primary="kind">kind</refterm>.
              </para>

              <para>
                There is no way to explicitly specify the <refterm primary="?
                non-specific tag"><uquote>?</uquote> non-specific</refterm>
                tag. This is intentional.
              </para>
            </listitem>
          </varlistentry>
        </variablelist>

        <productionset>
          <production id="c-non-specific-tag">
            <lhs>c-non-specific-tag</lhs>
            <rhs>
              <nonterminal def="#c-tag"><quote>!</quote></nonterminal>
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Non-Specific Tags</title>

          <simplelist type="horiz" columns="2">
            <member>
<programlisting># Assuming conventional resolution:<sbr/>
- "12"
- 12
- <hl1>!</hl1> 12
</programlisting>
<synopsis>Legend:
  <hl1><link linkend="c-non-specific-tag">c-non-specific-tag</link></hl1>
</synopsis>
            </member>
            <member>
<programlisting>%YAML 1.2<sbr/>
---
!!seq [
  !&lt;tag:yaml.org,2002:str&gt; "12",
  !&lt;tag:yaml.org,2002:int&gt; "12",
  !&lt;tag:yaml.org,2002:str&gt; "12",
]
</programlisting>
            </member>
          </simplelist>
        </example>
      </sect2>

      <pagebreak/>

      <sect2>
        <title>Node Anchors</title>

        <para>
          An anchor is denoted by the <defterm primary="&amp;
          anchor"><uquote>&amp;</uquote> indicator</defterm>. It marks a
          <refterm primary="node">node</refterm> for future reference. An
          <refterm primary="alias">alias node</refterm> can then be used to
          indicate additional inclusions of the anchored <refterm
          primary="node">node</refterm>. An anchored <refterm
          primary="node">node</refterm> need not be referenced by any <refterm
          primary="alias">alias nodes</refterm>; in particular, it is valid for
          all <refterm primary="node">nodes</refterm> to be anchored.
        </para>

        <productionset>
          <production id="c-ns-anchor-property">
            <lhs>c-ns-anchor-property</lhs>
            <rhs>
              <nonterminal def="#c-anchor"><quote>&amp;</quote></nonterminal>
              <nonterminal def="#ns-anchor-name"/>
            </rhs>
          </production>
        </productionset>

        <para>
          Note that as a <refterm primary="serialization"
          secondary="detail">serialization detail</refterm>, the anchor name is
          preserved in the <refterm primary="serialization">serialization
          tree</refterm>. However, it is not reflected in the <refterm
          primary="representation">representation</refterm> graph and must not
          be used to convey <refterm primary="content">content</refterm>
          information. In particular, the YAML <refterm
          primary="processor">processor</refterm> need not preserve the anchor
          name once the <refterm
          primary="representation">representation</refterm> is <refterm
          primary="compose">composed</refterm>.
        </para>

        <para>
          Anchor names must not contain the <refterm primary="[ start flow
          sequence"><uquote>[</uquote></refterm>, <refterm primary="] end flow
          sequence"><uquote>]</uquote></refterm>, <refterm primary="{ start
          flow mapping"><uquote>{</uquote></refterm>, <refterm primary="} end
          flow mapping"><uquote>}</uquote></refterm> and <refterm primary=",
          end flow entry"><uquote>,</uquote></refterm> characters. These
          characters would cause ambiguity with <refterm primary="style"
          secondary="flow" tertiary="collection">flow collection</refterm>
          structures.
        </para>

        <productionset>
          <production id="ns-anchor-char">
            <lhs>ns-anchor-char</lhs>
            <rhs>
              <nonterminal def="#ns-char"/>
              - <nonterminal def="#c-flow-indicator"/>
            </rhs>
          </production>

          <production id="ns-anchor-name">
            <lhs>ns-anchor-name</lhs>
            <rhs>
              <nonterminal def="#ns-anchor-char"/>+
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Node Anchors</title>

          <simplelist type="horiz" columns="2">
            <member>
<programlisting>First occurrence: <HL><hl1>&amp;<hl2>anchor</hl2></hl1></HL> Value<sbr/>
Second occurrence: *<hl2>anchor</hl2>
</programlisting>
<synopsis>Legend:
  <hl1><link linkend="c-ns-anchor-property">c-ns-anchor-property</link></hl1> <hl2><link linkend="ns-anchor-name">ns-anchor-name</link></hl2>
</synopsis>
            </member>
            <member>
<programlisting>%YAML 1.2<sbr/>
---
!!map {
  ? !!str "First occurrence"
  : &amp;A !!str "Value",
  ? !!str "Second occurrence"
  : *A,
}
</programlisting>
            </member>
          </simplelist>
        </example>
      </sect2>
    </sect1>
  </chapter>

  <chapter id="Flow">
    <title>Flow Styles</title>

    <para>
      YAML<q/>s <defterm primary="style" secondary="flow">flow styles</defterm>
      can be thought of as the natural extension of JSON to cover <refterm
      primary="line folding">folding</refterm> long content lines for
      readability, <refterm primary="tag">tagging</refterm> nodes to control
      <refterm primary="construct">construction</refterm> of <refterm
      primary="native data structure">native data structures</refterm>, and
      using <refterm primary="anchor">anchors</refterm> and <refterm
      primary="alias">aliases</refterm> to reuse <refterm
      primary="construct">constructed</refterm> object instances.
    </para>

    <sect1>
      <title>Alias Nodes</title>

      <para>
        Subsequent occurrences of a previously <refterm
        primary="serialize">serialized</refterm> node are <refterm
        primary="present">presented</refterm> as <defterm primary="alias">alias
        nodes</defterm>. The first occurrence of the <refterm
        primary="node">node</refterm> must be marked by an <refterm
        primary="anchor">anchor</refterm> to allow subsequent occurrences to be
        <refterm primary="present">presented</refterm> as alias nodes.
      </para>

      <para>
        An alias node is denoted by the <defterm primary="*
        alias"><uquote>*</uquote> indicator</defterm>. The alias refers to the
        most recent preceding <refterm primary="node">node</refterm> having the
        same <refterm primary="anchor">anchor</refterm>. It is an error for an
        alias node to use an <refterm primary="anchor">anchor</refterm> that
        does not previously occur in the <refterm
        primary="document">document</refterm>. It is not an error to specify an
        <refterm primary="anchor">anchor</refterm> that is not used by any
        alias node.
      </para>

      <para>
        Note that an alias node must not specify any <refterm primary="node"
        secondary="property">properties</refterm> or <refterm primary="content"
        >content</refterm>, as these were already specified at the first
        occurrence of the <refterm primary="node">node</refterm>.
      </para>

      <productionset>
        <production id="c-ns-alias-node">
          <lhs>c-ns-alias-node</lhs>
          <rhs>
            <nonterminal def="#c-alias"><quote>*</quote></nonterminal>
            <nonterminal def="#ns-anchor-name"/>
          </rhs>
        </production>
      </productionset>

      <example>
        <title>Alias Nodes</title>

        <simplelist type="horiz" columns="2">
          <member>
<programlisting>First occurrence: &amp;<hl2>anchor</hl2> Foo<sbr/>
Second occurrence: <HL><hl1>*<hl2>anchor</hl2></hl1></HL>
Override anchor: &amp;<hl2>anchor</hl2> Bar
Reuse anchor: <HL><hl1>*<hl2>anchor</hl2></hl1></HL>
</programlisting>
<synopsis>Legend:
  <hl1><link linkend="c-ns-alias-node">c-ns-alias-node</link></hl1> <hl2><link linkend="ns-anchor-name">ns-anchor-name</link></hl2>
</synopsis>
          </member>
          <member>
<programlisting>%YAML 1.2<sbr/>
---
!!map {
  ? !!str "First occurrence"
  : &amp;A !!str "Foo",
  ? !!str "Override anchor"
  : &amp;B !!str "Bar",
  ? !!str "Second occurrence"
  : *A,
  ? !!str "Reuse anchor"
  : *B,
}
</programlisting>
          </member>
        </simplelist>
      </example>
    </sect1>

    <sect1>
      <title>Empty Nodes</title>

      <para>
        YAML allows the <refterm primary="content">node content</refterm> to be
        omitted in many cases. <refterm primary="node">Nodes</refterm> with
        empty <refterm primary="content">content</refterm> are interpreted as
        if they were <refterm primary="style" secondary="flow"
        tertiary="plain">plain scalars</refterm> with an empty value. Such
        <refterm primary="node">nodes</refterm> are commonly resolved to a
        <refterm primary="tag" secondary="repository"
        tertiary="null"><uquote>null</uquote></refterm> value.
      </para>

      <productionset>
        <production id="e-scalar">
          <lhs>e-scalar</lhs>
          <rhs>
            /* Empty */
          </rhs>
        </production>
      </productionset>

      <para>
        In the examples, empty <refterm primary="scalar">scalars</refterm> are
        sometimes displayed as the glyph <uquote>&deg;</uquote> for clarity.
        Note that this glyph corresponds to a position in the characters
        <refterm primary="stream">stream</refterm> rather than to an actual
        character.
      </para>

      <example>
        <title>Empty Content</title>

        <simplelist type="horiz" columns="2">
          <member>
<programlisting>{<sbr/>
  foo : !!str<hl1>&deg;</hl1>,
  !!str<hl1>&deg;</hl1> : bar,
}
</programlisting>
<synopsis>Legend:
  <hl1><link linkend="e-scalar">e-scalar</link></hl1>
</synopsis>
          </member>
          <member>
<programlisting>%YAML 1.2<sbr/>
---
!!map {
  ? !!str "foo" : !!str "",
  ? !!str ""    : !!str "bar",
}
</programlisting>
          </member>
        </simplelist>
      </example>

      <para>
        Both the <refterm primary="node" secondary="property">node<q/>s
        properties</refterm> and <refterm primary="content">node
        content</refterm> are optional. This allows for a <defterm
        primary="node" secondary="completely empty">completely empty
        node</defterm>. Completely empty nodes are only valid when following
        some explicit indication for their existence.
      </para>

      <productionset>
        <production id="e-node">
          <lhs>e-node</lhs>
          <rhs>
            <nonterminal def="#e-scalar"/>
          </rhs>
        </production>
      </productionset>

      <example>
        <title>Completely Empty Flow Nodes</title>

        <simplelist type="horiz" columns="2">
          <member>
<programlisting>{<sbr/>
  ? foo :<hl1>&deg;</hl1>,
  <hl1>&deg;</hl1>: bar,
}
</programlisting>
<synopsis>Legend:
  <hl1><link linkend="e-node">e-node</link></hl1>
</synopsis>
        </member>
        <member>
<programlisting>%YAML 1.2<sbr/>
---
!!map {
  ? !!str "foo" : !!null "",
  ? !!null ""   : !!str "bar",
}
</programlisting>
          </member>
        </simplelist>
      </example>
    </sect1>

    <sect1>
      <title>Flow Scalar Styles</title>

      <para>
        YAML provides three <defterm primary="style" secondary="flow"
        tertiary="scalar">flow scalar styles</defterm>: <refterm
        primary="style" secondary="flow"
        tertiary="double-quoted">double-quoted</refterm>, <refterm
        primary="style" secondary="flow"
        tertiary="single-quoted">single-quoted</refterm> and <refterm
        primary="style" secondary="flow" tertiary="plain">plain</refterm>
        (unquoted). Each provides a different trade-off between readability and
        expressive power.
      </para>

      <para>
        The <refterm primary="style" secondary="scalar">scalar style</refterm>
        is a <refterm primary="presentation" secondary="detail">presentation
        detail</refterm> and must not be used to convey <refterm
        primary="content">content</refterm> information, with the exception
        that <refterm primary="style" secondary="flow" tertiary="plain">plain
        scalars</refterm> are distinguished for the purpose of <refterm
        primary="tag" secondary="resolution">tag resolution</refterm>.
      </para>

      <sect2>
        <title>Double-Quoted Style</title>

        <para>
          The <defterm primary="style" secondary="flow"
          tertiary="double-quoted">double-quoted style</defterm> is specified
          by surrounding <defterm primary='" double-quoted
          style'><uquote>"</uquote> indicators</defterm>. This is the only
          <refterm primary="style">style</refterm> capable of expressing
          arbitrary strings, by using <refterm primary="\ escaping in
          double-quoted scalars"><uquote>\</uquote></refterm> <refterm
          primary="escaping" secondary="in double-quoted scalars">escape
          sequences</refterm>. This comes at the cost of having to escape the
          <refterm primary="\ escaping in double-quoted
          scalars"><uquote>\</uquote></refterm> and <uquote>"</uquote>
          characters.
        </para>

        <productionset>
          <production id="nb-double-char">
            <lhs>nb-double-char</lhs>
            <rhs>
              <nonterminal def="#c-ns-esc-char"/>
              | ( <nonterminal def="#nb-json"/>
              - <nonterminal def="#c-escape"><quote>\</quote></nonterminal>
              - <nonterminal
                  def="#c-double-quote"><quote>"</quote></nonterminal> )
            </rhs>
          </production>

          <production id="ns-double-char">
            <lhs>ns-double-char</lhs>
            <rhs>
              <nonterminal def="#nb-double-char"/>
              - <nonterminal def="#s-white"/>
            </rhs>
          </production>
        </productionset>

        <para>
          Double-quoted scalars are restricted to a single line when contained
          inside an <refterm primary="key" secondary="implicit">implicit
          key</refterm>.
        </para>

        <productionset>
          <production id="c-double-quoted(n,c)">
            <lhs>c-double-quoted(n,c)</lhs>
            <rhs>
              <nonterminal
                def="#c-double-quote"><quote>"</quote></nonterminal>
              <nonterminal def="#nb-double-text(n,c)"/>
              <nonterminal
                def="#c-double-quote"><quote>"</quote></nonterminal>
            </rhs>
          </production>

          <production id="nb-double-text(n,c)">
            <lhs>nb-double-text(n,c)</lhs>
            <rhs>
              <varname>c</varname> = flow-out&nbsp; &rArr;
              <nonterminal def="#nb-double-multi-line(n)"/><sbr/>
              <varname>c</varname> = flow-in&nbsp;&nbsp; &rArr;
              <nonterminal def="#nb-double-multi-line(n)"/><sbr/>
              <varname>c</varname> = block-key &rArr;
              <nonterminal def="#nb-double-one-line"/><sbr/>
              <varname>c</varname> = flow-key&nbsp; &rArr;
              <nonterminal def="#nb-double-one-line"/>
            </rhs>
          </production>

          <production id="nb-double-one-line">
            <lhs>nb-double-one-line</lhs>
            <rhs>
              <nonterminal def="#nb-double-char"/>*
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Double Quoted Implicit Keys</title>

          <simplelist type="horiz" columns="2">
            <member>
<programlisting><HL><hl2>"<hl1>implicit block key</hl1>"</hl2></HL> : [<sbr/>
  <HL><hl2>"<hl1>implicit flow key</hl1>"</hl2></HL> : value,
 ]
</programlisting>
<synopsis>Legend:
  <hl1><link linkend="nb-double-one-line">nb-double-one-line</link></hl1>
  <hl2><link linkend="c-double-quoted(n,c)">c-double-quoted(n,c)</link></hl2>
</synopsis>
            </member>
            <member>
<programlisting>%YAML 1.2<sbr/>
---
!!map {
  ? !!str "implicit block key"
  : !!seq [
    !!map {
      ? !!str "implicit flow key"
      : !!str "value",
    }
  ]
}
</programlisting>
            </member>
          </simplelist>
        </example>

        <para>
          In a multi-line double-quoted scalar, <refterm primary="line
          break">line breaks</refterm> are subject to <refterm
          primary="line folding" secondary="flow">flow line folding</refterm>,
          which discards any trailing <refterm primary="space"
          secondary="white">white space</refterm> characters. It is also
          possible to <defterm primary="escaping" secondary="non-content line
          break">escape</defterm> the <refterm primary="line break">line
          break</refterm> character. In this case, the <refterm primary="line
          break">line break</refterm> is excluded from the <refterm
          primary="content">content</refterm>, and the trailing <refterm
          primary="space" secondary="white">white space</refterm> characters
          are preserved. Combined with the ability to <refterm
          primary="escaping" secondary="in double-quoted
          scalars">escape</refterm> <refterm primary="space"
          secondary="white">white space</refterm> characters, this allows
          double-quoted lines to be broken at arbitrary positions.
        </para>

        <productionset>
          <production id="s-double-escaped(n)">
            <lhs>s-double-escaped(n)</lhs>
            <rhs>
              <nonterminal def="#s-white"/>*
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal>
              <nonterminal def="#b-non-content"/><sbr/>
              <nonterminal def="#l-empty(n,c)"
                >l-empty(n,flow-in)</nonterminal>*
              <nonterminal def="#s-flow-line-prefix(n)"
                >s-flow-line-prefix(n)</nonterminal>
            </rhs>
          </production>

          <production id="s-double-break(n)">
            <lhs>s-double-break(n)</lhs>
            <rhs>
              <nonterminal def="#s-double-escaped(n)"/>
              | <nonterminal def="#s-flow-folded(n)"/>
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Double Quoted Line Breaks</title>

          <simplelist type="horiz" columns="2">
            <member>
<programlisting>"folded<hl1>&middot;&darr;</hl1><sbr/>
to a space,<hl1>&rarr;&darr;
&middot;&darr;</hl1>
to a line feed, or<hl2>&middot;&rarr;\&darr;
&middot;</hl2>\&middot;&rarr;non-content"
</programlisting>
            </member>
            <member>
<programlisting>%YAML 1.2<sbr/>
---
!!str "folded to a space,\n\
      to a line feed, \
      or \t \tnon-content"
</programlisting>
            </member>
          </simplelist>
<synopsis>Legend:
  <hl1><link linkend="s-flow-folded(n)">s-flow-folded(n)</link></hl1> <hl2><link linkend="s-double-escaped(n)">s-double-escaped(n)</link></hl2>
</synopsis>
        </example>

        <para>
          All leading and trailing <refterm primary="space"
          secondary="white">white space</refterm> characters are excluded from
          the <refterm primary="content">content</refterm>. Each continuation
          line must therefore contain at least one non-<refterm primary="space"
          secondary="white">space</refterm> character. Empty lines, if any, are
          consumed as part of the <refterm primary="line folding">line
          folding</refterm>.
        </para>

        <productionset>
          <production id="nb-ns-double-in-line">
            <lhs>nb-ns-double-in-line</lhs>
            <rhs>
              ( <nonterminal def="#s-white"/>*
              <nonterminal def="#ns-double-char"/> )*
            </rhs>
          </production>

          <production id="s-double-next-line(n)">
            <lhs>s-double-next-line(n)</lhs>
            <rhs>
              <nonterminal def="#s-double-break(n)"/><sbr/>
              ( <nonterminal def="#ns-double-char"/>
              <nonterminal def="#nb-ns-double-in-line"/><sbr/>
              &nbsp;&nbsp;( <nonterminal def="#s-double-next-line(n)"/>
              | <nonterminal def="#s-white"/>* ) )?
            </rhs>
          </production>

          <production id="nb-double-multi-line(n)">
            <lhs>nb-double-multi-line(n)</lhs>
            <rhs>
              <nonterminal def="#nb-ns-double-in-line"/><sbr/>
              ( <nonterminal def="#s-double-next-line(n)"/>
              | <nonterminal def="#s-white"/>* )
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Double Quoted Lines</title>

          <simplelist type="horiz" columns="2">
            <member>
<programlisting>"<hl1>&middot;1st non-empty</hl1><HL><hl2>&darr;<sbr/>
&darr;
&middot;<hl1>2nd non-empty</hl1></hl2></HL><HL><hl2>&middot;
&rarr;<hl1>3rd non-empty</hl1></hl2></HL>&middot;"
</programlisting>
            </member>
            <member>
<programlisting>%YAML 1.2<sbr/>
---
!!str " 1st non-empty\n\
      2nd non-empty \
      3rd non-empty "
</programlisting>
            </member>
          </simplelist>
<synopsis>Legend:
  <hl1><link linkend="nb-ns-double-in-line">nb-ns-double-in-line</link></hl1> <hl2><link linkend="s-double-next-line(n)">s-double-next-line(n)</link></hl2>
</synopsis>
        </example>
      </sect2>

      <sect2>
        <title>Single-Quoted Style</title>

        <para>
          The <defterm primary="style" secondary="flow"
          tertiary="single-quoted">single-quoted style</defterm> is specified
          by surrounding <defterm primary="' single-quoted
          style"><uquote>'</uquote> indicators</defterm>. Therefore, within a
          single-quoted scalar, such characters need to be repeated. This is
          the only form of <defterm primary="escaping" secondary="in
          single-quoted scalars">escaping</defterm> performed in single-quoted
          scalars. In particular, the <uquote>\</uquote> and <uquote>"</uquote>
          characters may be freely used. This restricts single-quoted scalars
          to <refterm primary="printable character">printable</refterm>
          characters. In addition, it is only possible to break a long
          single-quoted line where a <refterm primary="space">space</refterm>
          character is surrounded by non-<refterm primary="space"
          secondary="white">spaces</refterm>.
        </para>

        <productionset>
          <production id="c-quoted-quote">
            <lhs>c-quoted-quote</lhs>
            <rhs>
              <nonterminal
                def="#c-single-quote"><quote>'</quote></nonterminal>
              <nonterminal
                def="#c-single-quote"><quote>'</quote></nonterminal>
            </rhs>
          </production>

          <production id="nb-single-char">
            <lhs>nb-single-char</lhs>
            <rhs>
              <nonterminal def="#c-quoted-quote"/>
              | ( <nonterminal def="#nb-json"/>
              - <nonterminal
                  def="#c-single-quote"><quote>'</quote></nonterminal> )
            </rhs>
          </production>

          <production id="ns-single-char">
            <lhs>ns-single-char</lhs>
            <rhs>
              <nonterminal def="#nb-single-char"/>
              - <nonterminal def="#s-white"/>
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Single Quoted Characters</title>

          <simplelist type="horiz" columns="2">
            <member>
<programlisting> 'here<hl1>''</hl1>s to "quotes"'<sbr/>
</programlisting>
<synopsis>Legend:
  <hl1><link linkend="c-quoted-quote">c-quoted-quote</link></hl1>
</synopsis>
            </member>
            <member>
<programlisting>%YAML 1.2<sbr/>
---
!!str "here's to \"quotes\""
</programlisting>
            </member>
          </simplelist>
        </example>

        <para>
          Single-quoted scalars are restricted to a single line when contained
          inside a <refterm primary="key" secondary="implicit">implicit
          key</refterm>.
        </para>

        <productionset>
          <production id="c-single-quoted(n,c)">
            <lhs>c-single-quoted(n,c)</lhs>
            <rhs>
              <nonterminal
                def="#c-single-quote"><quote>'</quote></nonterminal>
              <nonterminal def="#nb-single-text(n,c)"/>
              <nonterminal
                def="#c-single-quote"><quote>'</quote></nonterminal>
            </rhs>
          </production>

          <production id="nb-single-text(n,c)">
            <lhs>nb-single-text(n,c)</lhs>
            <rhs>
              <varname>c</varname> = flow-out&nbsp; &rArr;
              <nonterminal def="#nb-single-multi-line(n)"/><sbr/>
              <varname>c</varname> = flow-in&nbsp;&nbsp; &rArr;
              <nonterminal def="#nb-single-multi-line(n)"/><sbr/>
              <varname>c</varname> = block-key &rArr;
              <nonterminal def="#nb-single-one-line"/><sbr/>
              <varname>c</varname> = flow-key&nbsp; &rArr;
              <nonterminal def="#nb-single-one-line"/>
            </rhs>
          </production>

          <production id="nb-single-one-line">
            <lhs>nb-single-one-line</lhs>
            <rhs>
              <nonterminal def="#nb-single-char"/>*
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Single Quoted Implicit Keys</title>

          <simplelist type="horiz" columns="2">
            <member>
<programlisting><HL><hl2>'<hl1>implicit block key</hl1>'</hl2></HL> : [<sbr/>
  <HL><hl2>'<hl1>implicit flow key</hl1>'</hl2></HL> : value,
 ]
</programlisting>
<synopsis>Legend:
  <hl1><link linkend="nb-single-one-line">nb-single-one-line</link></hl1>
  <hl2><link linkend="c-single-quoted(n,c)">c-single-quoted(n,c)</link></hl2>
</synopsis>
            </member>
            <member>
<programlisting>%YAML 1.2<sbr/>
---
!!map {
  ? !!str "implicit block key"
  : !!seq [
    !!map {
      ? !!str "implicit flow key"
      : !!str "value",
    }
  ]
}
</programlisting>
            </member>
          </simplelist>
        </example>

        <pagebreak/>

        <para>
          All leading and trailing <refterm primary="space"
          secondary="white">white space</refterm> characters are excluded from
          the <refterm primary="content">content</refterm>. Each continuation
          line must therefore contain at least one non-<refterm primary="space"
          secondary="white">space</refterm> character. Empty lines, if any, are
          consumed as part of the <refterm primary="line folding">line
          folding</refterm>.
        </para>

        <productionset>
          <production id="nb-ns-single-in-line">
            <lhs>nb-ns-single-in-line</lhs>
            <rhs>
              ( <nonterminal def="#s-white"/>*
              <nonterminal def="#ns-single-char"/> )*
            </rhs>
          </production>

          <production id="s-single-next-line(n)">
            <lhs>s-single-next-line(n)</lhs>
            <rhs>
              <nonterminal def="#s-flow-folded(n)"/><sbr/>
              ( <nonterminal def="#ns-single-char"/>
              <nonterminal def="#nb-ns-single-in-line"/><sbr/>
              &nbsp;&nbsp;( <nonterminal def="#s-single-next-line(n)"/> |
              <nonterminal def="#s-white"/>* ) )?
            </rhs>
          </production>

          <production id="nb-single-multi-line(n)">
            <lhs>nb-single-multi-line(n)</lhs>
            <rhs>
              <nonterminal def="#nb-ns-single-in-line"/><sbr/>
              ( <nonterminal def="#s-single-next-line(n)"/>
              | <nonterminal def="#s-white"/>* )
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Single Quoted Lines</title>

          <simplelist type="horiz" columns="2">
            <member>
<programlisting>'<hl1>&middot;1st non-empty</hl1><HL><hl2>&darr;<sbr/>
&darr;
&middot;<hl1>2nd non-empty</hl1></hl2></HL><HL><hl2>&middot;
&rarr;<hl1>3rd non-empty</hl1></hl2></HL>&middot;'
</programlisting>
            </member>
            <member>
<programlisting>%YAML 1.2<sbr/>
---
!!str " 1st non-empty\n\
      2nd non-empty \
      3rd non-empty "
</programlisting>
            </member>
          </simplelist>
<synopsis>Legend:
  <hl1><link linkend="nb-ns-single-in-line">nb-ns-single-in-line(n)</link></hl1> <hl2><link linkend="s-single-next-line(n)">s-single-next-line(n)</link></hl2>
</synopsis>
        </example>

      </sect2>

      <sect2>
        <title>Plain Style</title>

        <para>
          The <defterm primary="style" secondary="flow"
          tertiary="plain">plain</defterm> (unquoted) style has no identifying
          <refterm primary="indicator">indicators</refterm> and provides no
          form of escaping. It is therefore the most readable, most limited and
          most <refterm primary="context">context</refterm> sensitive <refterm
          primary="style">style</refterm>. In addition to a restricted
          character set, a plain scalar must not be empty, or contain leading
          or trailing <refterm primary="space" secondary="white">white
          space</refterm> characters. It is only possible to break a long plain
          line where a <refterm primary="space">space</refterm> character is
          surrounded by non-<refterm primary="space"
          secondary="white">spaces</refterm>.
        </para>

        <para>
          Plain scalars must not begin with most <refterm
          primary="indicator">indicators</refterm>, as this would cause
          ambiguity with other YAML constructs. However, the <refterm
          primary=": mapping value"><uquote>:</uquote></refterm>, <refterm
          primary="? mapping key"><uquote>?</uquote></refterm> and <refterm
          primary="- block sequence entry"><uquote>-</uquote></refterm>
          <refterm primary="indicator">indicators</refterm> may be used as the
          first character if followed by a non-<refterm primary="space"
          secondary="white">space</refterm> <quote>safe</quote> character, as
          this causes no ambiguity.
        </para>

        <productionset>
          <production id="ns-plain-first(c)">
            <lhs>ns-plain-first(c)</lhs>
            <rhs>
              &nbsp;&nbsp;( <nonterminal def="#ns-char"/>
                - <nonterminal def="#c-indicator"/> )<sbr/>
              | ( ( <nonterminal
                  def="#c-mapping-key"><quote>?</quote></nonterminal>
              | <nonterminal
                  def="#c-mapping-value"><quote>:</quote></nonterminal>
              | <nonterminal
                  def="#c-sequence-entry"><quote>-</quote></nonterminal> )<sbr/>
              &nbsp;&nbsp;&nbsp;&nbsp;/* Followed by an
                  <nonterminal def="#ns-plain-safe(c)"/>) */ )
            </rhs>
          </production>
        </productionset>

        <para>
          Plain scalars must never contain the <refterm primary=": mapping
          value"><uquote>:&nbsp;</uquote></refterm> and <refterm primary="#
          comment"><uquote>&nbsp;#</uquote></refterm> character combinations.
          Such combinations would cause ambiguity with <refterm
          primary="mapping">mapping</refterm> <refterm primary="key: value
          pair">key:&nbsp;value pairs</refterm> and <refterm
          primary="comment">comments</refterm>. In addition, inside <refterm
          primary="style" secondary="flow" tertiary="collection">flow
          collections</refterm>, or when used as <refterm primary="key"
          secondary="implicit">implicit keys</refterm>, plain scalars must not
          contain the <refterm primary="[ start flow
          sequence"><uquote>[</uquote></refterm>, <refterm primary="] end flow
          sequence"><uquote>]</uquote></refterm>, <refterm primary="{ start
          flow mapping"><uquote>{</uquote></refterm>, <refterm primary="} end
          flow mapping"><uquote>}</uquote></refterm> and <refterm primary=",
          end flow entry"><uquote>,</uquote></refterm> characters. These
          characters would cause ambiguity with <refterm primary="style"
          secondary="flow" tertiary="collection">flow collection</refterm>
          structures.
        </para>

        <productionset>
          <production id="ns-plain-safe(c)">
            <lhs>ns-plain-safe(c)</lhs>
            <rhs>
              <varname>c</varname> = flow-out&nbsp; &rArr; <nonterminal
              def="#ns-plain-safe-out"/><sbr/>
              <varname>c</varname> = flow-in&nbsp;&nbsp; &rArr; <nonterminal
              def="#ns-plain-safe-in"/><sbr/>
              <varname>c</varname> = block-key &rArr; <nonterminal
              def="#ns-plain-safe-out"/><sbr/>
              <varname>c</varname> = flow-key&nbsp; &rArr; <nonterminal
              def="#ns-plain-safe-in"/>
            </rhs>
          </production>

          <production id="ns-plain-safe-out">
            <lhs>ns-plain-safe-out</lhs>
            <rhs>
              <nonterminal def="#ns-char"/>
            </rhs>
          </production>

          <production id="ns-plain-safe-in">
            <lhs>ns-plain-safe-in</lhs>
            <rhs>
              <nonterminal def="#ns-char"/>
              - <nonterminal def="#c-flow-indicator"/>
            </rhs>
          </production>

          <production id="ns-plain-char(c)">
            <lhs>ns-plain-char(c)</lhs>
            <rhs>
              &nbsp;&nbsp;( <nonterminal def="#ns-plain-safe(c)"/>
              - <nonterminal
                def="#c-mapping-value"><quote>:</quote></nonterminal>
              - <nonterminal
                def="#c-comment"><quote>#</quote></nonterminal> )<sbr/>
              | ( /* An <nonterminal def="#ns-char"/> preceding */ <nonterminal
                  def="#c-comment"><quote>#</quote></nonterminal> )<sbr/>
              | ( <nonterminal
                  def="#c-mapping-value"><quote>:</quote></nonterminal>
                  /* Followed by an
                  <nonterminal def="#ns-plain-safe(c)"/> */ )
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Plain Characters</title>

          <simplelist type="horiz" columns="2">
            <member>
<programlisting># Outside flow collection:<sbr/>
- <hl1>:</hl1><hl2>:</hl2>vector
- "<hl3>:</hl3> - ()"
- Up<hl2>,</hl2> up, and away!
- <hl1>-</hl1>123
- http<hl2>:</hl2>//example.com/foo<hl2>#</hl2>bar
# Inside flow collection:
- [ <hl1>:</hl1><hl2>:</hl2>vector,
  "<hl3>:</hl3> - ()",
  "Up<hl4>,</hl4> up and away!",
  <hl1>-</hl1>123,
  http<hl2>:</hl2>//example.com/foo<hl2>#</hl2>bar ]
</programlisting>
            </member>
            <member>
<programlisting>%YAML 1.2<sbr/>
---
!!seq [
  !!str "::vector",
  !!str ": - ()",
  !!str "Up, up, and away!",
  !!int "-123",
  !!str "http://example.com/foo#bar",
  !!seq [
    !!str "::vector",
    !!str ": - ()",
    !!str "Up, up, and away!",
    !!int "-123",
    !!str "http://example.com/foo#bar",
  ],
]
</programlisting>
            </member>
          </simplelist>
<synopsis>Legend:
  <hl1><link linkend="ns-plain-first(c)">ns-plain-first(c)</link></hl1> <hl3>Not ns-plain-first(c)</hl3> <hl2><link linkend="ns-plain-char(c)">ns-plain-char(c)</link></hl2> <hl4>Not ns-plain-char(c)</hl4>
</synopsis>
        </example>

        <para>
          Plain scalars are further restricted to a single line when contained
          inside an <refterm primary="key" secondary="implicit">implicit
          key</refterm>.
        </para>

        <productionset>
          <production id="ns-plain(n,c)">
            <lhs>ns-plain(n,c)</lhs>
            <rhs>
              <varname>c</varname> = flow-out&nbsp; &rArr;
                <nonterminal def="#ns-plain-multi-line(n,c)"/><sbr/>
              <varname>c</varname> = flow-in&nbsp;&nbsp; &rArr;
                <nonterminal def="#ns-plain-multi-line(n,c)"/><sbr/>
              <varname>c</varname> = block-key &rArr;
                <nonterminal def="#ns-plain-one-line(c)"/><sbr/>
              <varname>c</varname> = flow-key&nbsp; &rArr;
                <nonterminal def="#ns-plain-one-line(c)"/>
            </rhs>
          </production>

          <production id="nb-ns-plain-in-line(c)">
            <lhs>nb-ns-plain-in-line(c)</lhs>
            <rhs>
              ( <nonterminal def="#s-white"/>*
              <nonterminal def="#ns-plain-char(c)"/> )*
            </rhs>
          </production>

          <production id="ns-plain-one-line(c)">
            <lhs>ns-plain-one-line(c)</lhs>
            <rhs>
              <nonterminal def="#ns-plain-first(c)"/>
              <nonterminal def="#nb-ns-plain-in-line(c)"/>
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Plain Implicit Keys</title>

          <simplelist type="horiz" columns="2">
            <member>
<programlisting><hl1>implicit block key</hl1> : [<sbr/>
  <hl1>implicit flow key</hl1> : value,
 ]
</programlisting>
<synopsis>Legend:
  <hl1><link linkend="ns-plain-one-line(c)">ns-plain-one-line(c)</link></hl1>
</synopsis>
            </member>
            <member>
<programlisting>%YAML 1.2<sbr/>
---
!!map {
  ? !!str "implicit block key"
  : !!seq [
    !!map {
      ? !!str "implicit flow key"
      : !!str "value",
    }
  ]
}
</programlisting>
            </member>
          </simplelist>
        </example>

        <para>
          All leading and trailing <refterm primary="space"
          secondary="white">white space</refterm> characters are excluded from
          the <refterm primary="content">content</refterm>. Each continuation
          line must therefore contain at least one non-<refterm primary="space"
          secondary="white">space</refterm> character. Empty lines, if any, are
          consumed as part of the <refterm primary="line folding">line
          folding</refterm>.
        </para>

        <productionset>
          <production id="s-ns-plain-next-line(n,c)">
            <lhs>s-ns-plain-next-line(n,c)</lhs>
            <rhs>
              <nonterminal def="#s-flow-folded(n)"/><sbr/>
              <nonterminal def="#ns-plain-char(c)"/>
              <nonterminal def="#nb-ns-plain-in-line(c)"/>
            </rhs>
          </production>

          <production id="ns-plain-multi-line(n,c)">
            <lhs>ns-plain-multi-line(n,c)</lhs>
            <rhs>
              <nonterminal def="#ns-plain-one-line(c)"/><sbr/>
              <nonterminal def="#s-ns-plain-next-line(n,c)"/>*
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Plain Lines</title>

          <simplelist type="horiz" columns="2">
            <member>
<programlisting><hl1>1st non-empty</hl1><HL><hl2>&darr;<sbr/>
&darr;
&middot;<hl1>2nd non-empty</hl1></hl2></HL><HL><hl2>&middot;
&rarr;<hl1>3rd non-empty</hl1></hl2></HL>
</programlisting>
            </member>
            <member>
<programlisting>%YAML 1.2<sbr/>
---
!!str "1st non-empty\n\
      2nd non-empty \
      3rd non-empty"
</programlisting>
            </member>
          </simplelist>
<synopsis>Legend:
  <hl1><link linkend="nb-ns-plain-in-line(c)">nb-ns-plain-in-line(c)</link></hl1> <hl2><link linkend="s-ns-plain-next-line(n,c)">s-ns-plain-next-line(n,c)</link></hl2>
</synopsis>
        </example>
      </sect2>
    </sect1>

    <sect1>
      <title>Flow Collection Styles</title>

      <para>
        A <defterm primary="style" secondary="flow" tertiary="collection">flow
        collection</defterm> may be nested within a <refterm primary="style"
        secondary="block" tertiary="collection">block collection</refterm>
        (<refterm primary="context"
        secondary="flow-out"><userinput>flow-out</userinput>
        context</refterm>), nested within another flow collection (<refterm
        primary="context" secondary="flow-in"><userinput>flow-in</userinput>
        context</refterm>), or be a part of an <refterm primary="key"
        secondary="implicit">implicit key</refterm> (<refterm primary="context"
        secondary="flow-key"><userinput>flow-key</userinput> context</refterm>
        or <refterm primary="context"
        secondary="block-key"><userinput>block-key</userinput>
        context</refterm>). Flow collection entries are terminated by the
        <defterm primary=", end flow entry"><uquote>,</uquote>
        indicator</defterm>. The final <uquote>,</uquote> may be omitted. This
        does not cause ambiguity because flow collection entries can never be
        <refterm primary="node" secondary="completely empty">completely
        empty</refterm>.
      </para>

      <productionset>
        <production id="in-flow(c)">
          <lhs>in-flow(c)</lhs>
          <rhs>
            <varname>c</varname> = flow-out&nbsp; &rArr; flow-in<sbr/>
            <varname>c</varname> = flow-in&nbsp;&nbsp; &rArr; flow-in<sbr/>
            <varname>c</varname> = block-key &rArr; flow-key<sbr/>
            <varname>c</varname> = flow-key&nbsp; &rArr; flow-key
          </rhs>
        </production>
      </productionset>

      <sect2>
        <title>Flow Sequences</title>

        <para>
          <defterm primary="style" secondary="flow" tertiary="sequence">Flow
          sequence content</defterm> is denoted by surrounding <defterm
          primary="[ start flow sequence"><uquote>[</uquote></defterm> and
          <defterm primary="] end flow sequence"><uquote>]</uquote></defterm>
          characters.
        </para>

        <productionset>
          <production id="c-flow-sequence(n,c)">
            <lhs>c-flow-sequence(n,c)</lhs>
            <rhs>
              <nonterminal
                def="#c-sequence-start"><quote>[</quote></nonterminal>
              <nonterminal def="#s-separate(n,c)"/>?<sbr/>
              <nonterminal def="#ns-s-flow-seq-entries(n,c)"
                >ns-s-flow-seq-entries(n,</nonterminal
                  ><nonterminal def="#in-flow(c)"
                  >in-flow(c)</nonterminal><nonterminal
                    def="#ns-s-flow-seq-entries(n,c)">)</nonterminal>?
              <nonterminal
                def="#c-sequence-end"><quote>]</quote></nonterminal>
            </rhs>
          </production>
        </productionset>

        <para>
          Sequence entries are separated by a <refterm primary=", end flow
          entry"><uquote>,</uquote></refterm> character.
        </para>

        <productionset>
          <production id="ns-s-flow-seq-entries(n,c)">
            <lhs>ns-s-flow-seq-entries(n,c)</lhs>
            <rhs>
              <nonterminal def="#ns-flow-seq-entry(n,c)"/>
              <nonterminal def="#s-separate(n,c)"/>?<sbr/>
              ( <nonterminal
                  def="#c-collect-entry"><quote>,</quote></nonterminal>
                <nonterminal def="#s-separate(n,c)"/>?<sbr/>
              &nbsp;&nbsp;<nonterminal
                def="#ns-s-flow-seq-entries(n,c)"/>? )?
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Flow Sequence</title>

          <simplelist type="horiz" columns="2">
            <member>
<programlisting>- <hl1>[</hl1> <hl2>one</hl2>, <hl2>two</hl2>, <hl1>]</hl1><sbr/>
- <hl1>[</hl1><hl2>three</hl2> ,<hl2>four</hl2><hl1>]</hl1>
</programlisting>
<synopsis>Legend:
  <hl1><link linkend="c-sequence-start">c-sequence-start</link></hl1> <hl1><link linkend="c-sequence-end">c-sequence-end</link></hl1>
  <hl2><link linkend="ns-flow-seq-entry(n,c)">ns-flow-seq-entry(n,c)</link></hl2>
</synopsis>
            </member>
            <member>
<programlisting>%YAML 1.2<sbr/>
---
!!seq [
  !!seq [
    !!str "one",
    !!str "two",
  ],
  !!seq [
    !!str "three",
    !!str "four",
  ],
]
</programlisting>
            </member>
          </simplelist>
        </example>

        <para>
          Any <refterm primary="style" secondary="flow">flow node</refterm> may
          be used as a flow sequence entry. In addition, YAML provides a
          <refterm primary="style" secondary="single key:value pair
          mapping">compact notation</refterm> for the case where a flow
          sequence entry is a <refterm primary="mapping">mapping</refterm> with
          a <refterm primary="style" secondary="single key:value pair
          mapping">single key:&nbsp;value pair</refterm>.
        </para>

        <productionset>
          <production id="ns-flow-seq-entry(n,c)">
            <lhs>ns-flow-seq-entry(n,c)</lhs>
            <rhs>
              <nonterminal def="#ns-flow-pair(n,c)"/>
              | <nonterminal def="#ns-flow-node(n,c)"/>
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Flow Sequence Entries</title>

          <simplelist type="horiz" columns="2">
            <member>
<programlisting>[<sbr/>
<hl1>"double
 quoted"</hl1>, <hl1>'single
           quoted'</hl1>,
<hl1>plain
 text</hl1>, <hl1>[ nested ]</hl1>,
<hl2>single: pair</hl2>,
]
</programlisting>
<synopsis>Legend:
  <hl1><link linkend="ns-flow-node(n,c)">ns-flow-node(n,c)</link></hl1> <hl2><link linkend="ns-flow-pair(n,c)">ns-flow-pair(n,c)</link></hl2>
</synopsis>
            </member>
            <member>
<programlisting>%YAML 1.2<sbr/>
---
!!seq [
  !!str "double quoted",
  !!str "single quoted",
  !!str "plain text",
  !!seq [
    !!str "nested",
  ],
  !!map {
    ? !!str "single"
    : !!str "pair",
  },
]
</programlisting>
            </member>
          </simplelist>
        </example>
      </sect2>

      <sect2>
        <title>Flow Mappings</title>

        <para>
          <defterm primary="style" secondary="flow" tertiary="mapping">Flow
          mappings</defterm> are denoted by surrounding <defterm primary="{
          start flow mapping"><uquote>{</uquote></defterm> and <defterm
          primary="} end flow mapping"><uquote>}</uquote></defterm> characters.
        </para>

        <productionset>
          <production id="c-flow-mapping(n,c)">
            <lhs>c-flow-mapping(n,c)</lhs>
            <rhs>
              <nonterminal
                def="#c-mapping-start"><quote>{</quote></nonterminal>
              <nonterminal def="#s-separate(n,c)"/>?<sbr/>
              <nonterminal def="#ns-s-flow-map-entries(n,c)"
                >ns-s-flow-map-entries(n,</nonterminal
                  ><nonterminal def="#in-flow(c)"
                  >in-flow(c)</nonterminal><nonterminal
                    def="#ns-s-flow-map-entries(n,c)">)</nonterminal>?
              <nonterminal
                def="#c-mapping-end"><quote>}</quote></nonterminal>
            </rhs>
          </production>
        </productionset>

        <para>
          Mapping entries are separated by a <refterm primary=", end flow
          entry"><uquote>,</uquote></refterm> character.
        </para>

        <productionset>
          <production id="ns-s-flow-map-entries(n,c)">
            <lhs>ns-s-flow-map-entries(n,c)</lhs>
            <rhs>
              <nonterminal def="#ns-flow-map-entry(n,c)"/>
              <nonterminal def="#s-separate(n,c)"/>?<sbr/>
                ( <nonterminal
                  def="#c-collect-entry"><quote>,</quote></nonterminal>
                  <nonterminal def="#s-separate(n,c)"/>?<sbr/>
                &nbsp;&nbsp;<nonterminal
                  def="#ns-s-flow-map-entries(n,c)"/>? )?
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Flow Mappings</title>

          <simplelist type="horiz" columns="2">
            <member>
<programlisting>- <hl1>{</hl1> <hl2>one : two</hl2> , <hl2>three: four</hl2> , <hl1>}</hl1><sbr/>
- <hl1>{</hl1><hl2>five: six</hl2>,<hl2>seven : eight</hl2><hl1>}</hl1>
</programlisting>
<synopsis>Legend:
  <hl1><link linkend="c-mapping-start">c-mapping-start</link></hl1> <hl1><link linkend="c-mapping-end">c-mapping-end</link></hl1>
  <hl2><link linkend="ns-flow-map-entry(n,c)">ns-flow-map-entry(n,c)</link></hl2>
</synopsis>
            </member>
            <member>
<programlisting>%YAML 1.2<sbr/>
---
!!seq [
  !!map {
    ? !!str "one"   : !!str "two",
    ? !!str "three" : !!str "four",
  },
  !!map {
    ? !!str "five"  : !!str "six",
    ? !!str "seven" : !!str "eight",
  },
]
</programlisting>
            </member>
          </simplelist>
        </example>

        <para>
          If the optional <defterm primary="? mapping key"><uquote>?</uquote>
          mapping key indicator</defterm> is specified, the rest of the entry
          may be <refterm primary="node" secondary="completely
          empty">completely empty</refterm>.
        </para>

        <productionset>
          <production id="ns-flow-map-entry(n,c)">
            <lhs>ns-flow-map-entry(n,c)</lhs>
            <rhs>
              &nbsp;&nbsp;(
              <nonterminal
                def="#c-mapping-key"><quote>?</quote></nonterminal>
              <nonterminal def="#s-separate(n,c)"/><sbr/>
              &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal
                def="#ns-flow-map-explicit-entry(n,c)"/> )<sbr/>
              | <nonterminal def="#ns-flow-map-implicit-entry(n,c)"/>
            </rhs>
          </production>

          <production id="ns-flow-map-explicit-entry(n,c)">
            <lhs>ns-flow-map-explicit-entry(n,c)</lhs>
            <rhs>
              &nbsp;&nbsp;<nonterminal
                def="#ns-flow-map-implicit-entry(n,c)"/><sbr/>
              | ( <nonterminal def="#e-node"/> /* Key */<sbr/>
              &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal
                def="#e-node"/> /* Value */ )
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Flow Mapping Entries</title>

          <simplelist type="horiz" columns="2">
            <member>
<programlisting>{<sbr/>
? <hl2>explicit: entry</hl2>,
<hl1>implicit: entry</hl1>,
?<hl3>&deg;</hl3><hl3>&deg;</hl3>
}
</programlisting>
<synopsis>Legend:
  <hl1><link linkend="ns-flow-map-explicit-entry(n,c)">ns-flow-map-explicit-entry(n,c)</link></hl1>
  <hl2><link linkend="ns-flow-map-implicit-entry(n,c)">ns-flow-map-implicit-entry(n,c)</link></hl2>
  <hl3><link linkend="e-node">e-node</link></hl3>
</synopsis>
            </member>
            <member>
<programlisting>%YAML 1.2<sbr/>
---
!!map {
  ? !!str "explicit" : !!str "entry",
  ? !!str "implicit" : !!str "entry",
  ? !!null "" : !!null "",
}
</programlisting>
            </member>
          </simplelist>
        </example>

        <para>
          Normally, YAML insists the <defterm primary=": mapping
          value"><uquote>:</uquote> mapping value indicator</defterm> be
          <refterm primary="space" secondary="separation">separated</refterm>
          from the <refterm primary="value">value</refterm> by <refterm
          primary="space" secondary="white">white space</refterm>. A benefit of
          this restriction is that the <uquote>:</uquote> character can be used
          inside <refterm primary="style" secondary="flow"
          tertiary="plain">plain scalars</refterm>, as long as it is not
          followed by <refterm primary="space" secondary="white">white
          space</refterm>. This allows for unquoted URLs and timestamps. It is
          also a potential source for confusion as <uquote>a:1</uquote> is a
          <refterm primary="style" secondary="flow" tertiary="plain">plain
          scalar</refterm> and not a <refterm primary="key: value
          pair">key:&nbsp;value pair</refterm>.
        </para>

        <para>
          Note that the <refterm primary="value">value</refterm> may be
          <refterm primary="node" secondary="completely empty">completely
          empty</refterm> since its existence is indicated by the
          <uquote>:</uquote>.
        </para>

        <productionset>
          <production id="ns-flow-map-implicit-entry(n,c)">
            <lhs>ns-flow-map-implicit-entry(n,c)</lhs>
            <rhs>
              &nbsp;&nbsp;<nonterminal
                  def="#ns-flow-map-yaml-key-entry(n,c)"/><sbr/>
              | <nonterminal
                  def="#c-ns-flow-map-empty-key-entry(n,c)"/><sbr/>
              | <nonterminal
                  def="#c-ns-flow-map-json-key-entry(n,c)"/>
            </rhs>
          </production>

          <production id="ns-flow-map-yaml-key-entry(n,c)">
            <lhs>ns-flow-map-yaml-key-entry(n,c)</lhs>
            <rhs>
              <nonterminal def="#ns-flow-yaml-node(n,c)"/><sbr/>
              ( ( <nonterminal def="#s-separate(n,c)"/>?<sbr/>
              &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal
                    def="#c-ns-flow-map-separate-value(n,c)"/> )<sbr/>
              | <nonterminal def="#e-node"/> )
            </rhs>
          </production>

          <production id="c-ns-flow-map-empty-key-entry(n,c)">
            <lhs>c-ns-flow-map-empty-key-entry(n,c)</lhs>
            <rhs>
              <nonterminal def="#e-node"/> /* Key */<sbr/>
              <nonterminal def="#c-ns-flow-map-separate-value(n,c)"/>
            </rhs>
          </production>

          <production id="c-ns-flow-map-separate-value(n,c)">
            <lhs>c-ns-flow-map-separate-value(n,c)</lhs>
            <rhs>
              <nonterminal
                def="#c-mapping-value"><quote>:</quote></nonterminal>
                /* Not followed by an<sbr/>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<nonterminal
                  def="#ns-plain-safe(c)"/> */<sbr/>
              ( ( <nonterminal def="#s-separate(n,c)"/>
              <nonterminal def="#ns-flow-node(n,c)"/> )<sbr/>
              | <nonterminal def="#e-node"/> /* Value */ )
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Flow Mapping Separate Values</title>

          <simplelist type="horiz" columns="2">
            <member>
<programlisting>{<sbr/>
<hl1>unquoted</hl1>&middot;<hl2>:&middot;"separate"</hl2>,
<hl1>http://foo.com</hl1>,
<hl1>omitted value</hl1><HL><hl2>:<hl3>&deg;</hl3></hl2></HL>,
<hl3>&deg;</hl3><hl2>:&middot;omitted key</hl2>,
}
</programlisting>
<synopsis>Legend:
  <hl1><link linkend="ns-flow-yaml-node(n,c)">ns-flow-yaml-node(n,c)</link></hl1> <hl3><link linkend="e-node">e-node</link></hl3>
  <hl2><link linkend="c-ns-flow-map-separate-value(n,c)">c-ns-flow-map-separate-value(n,c)</link></hl2>
</synopsis>
            </member>
            <member>
<programlisting>%YAML 1.2<sbr/>
---
!!map {
  ? !!str "unquoted" : !!str "separate",
  ? !!str "http://foo.com" : !!null "",
  ? !!str "omitted value" : !!null "",
  ? !!null "" : !!str "omitted key",
}
</programlisting>
            </member>
          </simplelist>
        </example>

        <pagebreak/>

        <para>
          To ensure <refterm primary="JSON compatibility">JSON
          compatibility</refterm>, if a <refterm primary="key">key</refterm>
          inside a flow mapping is <refterm
          primary="JSON-like">JSON-like</refterm>, YAML allows the following
          <refterm primary="value">value</refterm> to be specified adjacent to
          the <uquote>:</uquote>. This causes no ambiguity, as all <refterm
          primary="JSON-like">JSON-like</refterm> <refterm
          primary="key">keys</refterm> are surrounded by <refterm
          primary="indicator">indicators</refterm>. However, as this greatly
          reduces readability, YAML <refterm
          primary="processor">processors</refterm> should <refterm
          primary="space" secondary="separation">separate</refterm> the
          <refterm primary="value">value</refterm> from the <uquote>:</uquote>
          on output, even in this case.
        </para>

        <productionset>
          <production id="c-ns-flow-map-json-key-entry(n,c)">
            <lhs>c-ns-flow-map-json-key-entry(n,c)</lhs>
            <rhs>
              <nonterminal def="#c-flow-json-node(n,c)"/><sbr/>
              ( ( <nonterminal def="#s-separate(n,c)"/>?<sbr/>
              &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal
                    def="#c-ns-flow-map-adjacent-value(n,c)"/> )<sbr/>
              | <nonterminal def="#e-node"/> )
            </rhs>
          </production>

          <production id="c-ns-flow-map-adjacent-value(n,c)">
            <lhs>c-ns-flow-map-adjacent-value(n,c)</lhs>
            <rhs>
              <nonterminal
                def="#c-mapping-value"><quote>:</quote></nonterminal>
              ( ( <nonterminal def="#s-separate(n,c)"/>?<sbr/>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<nonterminal
                def="#ns-flow-node(n,c)"/> )<sbr/>
              &nbsp;&nbsp;&nbsp;&nbsp;|
              <nonterminal def="#e-node"/> ) /* Value */
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Flow Mapping Adjacent Values</title>

          <simplelist type="horiz" columns="2">
            <member>
<programlisting>{<sbr/>
<hl1>"adjacent"</hl1>:<hl2>value</hl2>,
<hl1>"readable"</hl1>:<hl2>&middot;value</hl2>,
<hl1>"empty"</hl1>:<hl3>&deg;</hl3>
}
</programlisting>
<synopsis>Legend:
  <hl1><link linkend="c-flow-json-node(n,c)">c-flow-json-node(n,c)</link></hl1> <hl3><link linkend="e-node">e-node</link></hl3>
  <hl2><link linkend="c-ns-flow-map-adjacent-value(n,c)">c-ns-flow-map-adjacent-value(n,c)</link></hl2>
</synopsis>
            </member>
            <member>
<programlisting>%YAML 1.2<sbr/>
---
!!map {
  ? !!str "adjacent" : !!str "value",
  ? !!str "readable" : !!str "value",
  ? !!str "empty"    : !!null "",
}
</programlisting>
            </member>
          </simplelist>
        </example>

        <para>
          A more compact notation is usable inside <refterm primary="style"
          secondary="flow" tertiary="sequence">flow sequences</refterm>, if the
          <refterm primary="mapping">mapping</refterm> contains a <defterm
          primary="style" secondary="single key:value pair mapping">single
          key:&nbsp;value pair</defterm>. This notation does not require the
          surrounding <uquote>{</uquote> and <uquote>}</uquote> characters.
          Note that it is not possible to specify any <refterm primary="node"
          secondary="property">node properties</refterm> for the <refterm
          primary="mapping">mapping</refterm> in this case.
        </para>

        <example>
          <title>Single Pair Flow Mappings</title>

          <simplelist type="horiz" columns="2">
            <member>
<programlisting>[<sbr/>
<hl1>foo: bar</hl1>
]
</programlisting>
<synopsis>Legend:
  <hl1><link linkend="ns-flow-pair(n,c)">ns-flow-pair(n,c)</link></hl1>
</synopsis>
            </member>
            <member>
<programlisting>%YAML 1.2<sbr/>
---
!!seq [
  !!map { ? !!str "foo" : !!str "bar" }
]
</programlisting>
            </member>
          </simplelist>
        </example>

        <para>
          If the <uquote>?</uquote> indicator is explicitly specified, <refterm
          primary="parse">parsing</refterm> is unambiguous, and the syntax is
          identical to the general case.
        </para>

        <productionset>
          <production id="ns-flow-pair(n,c)">
            <lhs>ns-flow-pair(n,c)</lhs>
            <rhs>
              &nbsp;&nbsp;(
              <nonterminal
                def="#c-mapping-key"><quote>?</quote></nonterminal>
              <nonterminal def="#s-separate(n,c)"/><sbr/>
              &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal
                def="#ns-flow-map-explicit-entry(n,c)"/> )<sbr/>
              | <nonterminal def="#ns-flow-pair-entry(n,c)"/>
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Single Pair Explicit Entry</title>

          <simplelist type="horiz" columns="2">
            <member>
<programlisting>[<sbr/>
? <hl1>foo
 bar : baz</hl1>
]
</programlisting>
<synopsis>Legend:
  <hl1><link linkend="ns-flow-map-explicit-entry(n,c)">ns-flow-map-explicit-entry(n,c)</link></hl1>
</synopsis>
            </member>
            <member>
<programlisting>%YAML 1.2<sbr/>
---
!!seq [
  !!map {
    ? !!str "foo bar"
    : !!str "baz",
  },
]
</programlisting>
            </member>
          </simplelist>
        </example>

        <para>
          If the <uquote>?</uquote> indicator is omitted, <refterm
          primary="parse">parsing</refterm> needs to see past the <defterm
          primary="key" secondary="implicit">implicit key</defterm> to
          recognize it as such. To limit the amount of lookahead required, the
          <uquote>:</uquote> indicator must appear at most 1024 Unicode
          characters beyond the start of the <refterm
          primary="key">key</refterm>. In addition, the <refterm
          primary="key">key</refterm> is restricted to a single line.
        </para>

        <para>
          Note that YAML allows arbitrary <refterm
          primary="node">nodes</refterm> to be used as <refterm
          primary="key">keys</refterm>. In particular, a <refterm
          primary="key">key</refterm> may be a <refterm
          primary="sequence">sequence</refterm> or a <refterm
          primary="mapping">mapping</refterm>. Thus, without the above
          restrictions, practical one-pass <refterm
          primary="parse">parsing</refterm> would have been impossible to
          implement.
        </para>

        <productionset>
          <production id="ns-flow-pair-entry(n,c)">
            <lhs>ns-flow-pair-entry(n,c)</lhs>
            <rhs>
              &nbsp;&nbsp;<nonterminal
                  def="#ns-flow-pair-yaml-key-entry(n,c)"/><sbr/>
              | <nonterminal
                  def="#c-ns-flow-map-empty-key-entry(n,c)"/><sbr/>
              | <nonterminal
                  def="#c-ns-flow-pair-json-key-entry(n,c)"/>
            </rhs>
          </production>

          <production id="ns-flow-pair-yaml-key-entry(n,c)">
            <lhs>ns-flow-pair-yaml-key-entry(n,c)</lhs>
            <rhs>
              <nonterminal def="#ns-s-implicit-yaml-key(c)"
                >ns-s-implicit-yaml-key(flow-key)</nonterminal><sbr/>
              <nonterminal def="#c-ns-flow-map-separate-value(n,c)"/>
            </rhs>
          </production>

          <production id="c-ns-flow-pair-json-key-entry(n,c)">
            <lhs>c-ns-flow-pair-json-key-entry(n,c)</lhs>
            <rhs>
              <nonterminal def="#c-s-implicit-json-key(c)"
                >c-s-implicit-json-key(flow-key)</nonterminal><sbr/>
              <nonterminal def="#c-ns-flow-map-adjacent-value(n,c)"/>
            </rhs>
          </production>

          <production id="ns-s-implicit-yaml-key(c)">
            <lhs>ns-s-implicit-yaml-key(c)</lhs>
            <rhs>
              <nonterminal def="#ns-flow-yaml-node(n,c)"
                >ns-flow-yaml-node(n/a,c)</nonterminal>
              <nonterminal def="#s-separate-in-line"/>?<sbr/>
              /* At most 1024 characters altogether */
            </rhs>
          </production>

          <production id="c-s-implicit-json-key(c)">
            <lhs>c-s-implicit-json-key(c)</lhs>
            <rhs>
              <nonterminal def="#c-flow-json-node(n,c)"
                >c-flow-json-node(n/a,c)</nonterminal>
              <nonterminal def="#s-separate-in-line"/>?<sbr/>
              /* At most 1024 characters altogether */
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Single Pair Implicit Entries</title>

          <simplelist type="horiz" columns="2">
            <member>
<programlisting>- [ <hl1>YAML&middot;</hl1><hl4>: separate</hl4> ]<sbr/>
- [ <hl2>&deg;</hl2><hl4>: empty key entry</hl4> ]
- [ <hl3>{JSON: like}</hl3><hl4>:adjacent</hl4> ]
</programlisting>
<synopsis>Legend:
  <hl1><link linkend="ns-s-implicit-yaml-key(c)">ns-s-implicit-yaml-key</link></hl1>
  <hl3><link linkend="c-s-implicit-json-key(c)">c-s-implicit-json-key</link></hl3>
  <hl2><link linkend="e-node">e-node</link></hl2> <hl4>Value</hl4>
</synopsis>
            </member>
            <member>
<programlisting>%YAML 1.2<sbr/>
---
!!seq [
  !!seq [
    !!map {
      ? !!str "YAML"
      : !!str "separate"
    },
  ],
  !!seq [
    !!map {
      ? !!null ""
      : !!str "empty key entry"
    },
  ],
  !!seq [
    !!map {
      ? !!map {
        ? !!str "JSON"
        : !!str "like"
      } : "adjacent",
    },
  ],
]
</programlisting>
            </member>
          </simplelist>
        </example>

        <example>
          <title>Invalid Implicit Keys</title>

          <simplelist type="horiz" columns="2">
            <member>
<screen>[ <hl1>foo<sbr/>
 bar</hl1>: invalid,
 <hl2>"foo<emphasis>...&gt;1K characters...</emphasis>bar"</hl2>: invalid ]
</screen>
          </member>
          <member>
<screen>ERROR:<sbr/>
- The <hl1>foo bar</hl1> key spans multiple lines
- The <hl2>foo...bar</hl2> key is too long
</screen>
            </member>
          </simplelist>
        </example>
      </sect2>
    </sect1>

    <sect1>
      <title>Flow Nodes</title>

      <para>
        <defterm primary="JSON-like">JSON-like</defterm> <refterm
        primary="style" secondary="flow">flow styles</refterm> all have
        explicit start and end <refterm
        primary="indicator">indicators</refterm>. The only <refterm
        primary="style" secondary="flow">flow style</refterm> that does not
        have this property is the <refterm primary="style" secondary="flow"
        tertiary="plain">plain scalar</refterm>. Note that none of the
        <quote>JSON-like</quote> styles is actually acceptable by JSON. Even
        the <refterm primary="style" secondary="flow"
        tertiary="double-quoted">double-quoted style</refterm> is a superset of
        the JSON string format.
      </para>

      <productionset>
        <production id="ns-flow-yaml-content(n,c)">
          <lhs>ns-flow-yaml-content(n,c)</lhs>
          <rhs>
            <nonterminal def="#ns-plain(n,c)"/>
          </rhs>
        </production>

        <production id="c-flow-json-content(n,c)">
          <lhs>c-flow-json-content(n,c)</lhs>
          <rhs>
            &nbsp;&nbsp;<nonterminal def="#c-flow-sequence(n,c)"/>
            | <nonterminal def="#c-flow-mapping(n,c)"/><sbr/>
            | <nonterminal def="#c-single-quoted(n,c)"/>
            | <nonterminal def="#c-double-quoted(n,c)"/>
          </rhs>
        </production>

        <production id="ns-flow-content(n,c)">
          <lhs>ns-flow-content(n,c)</lhs>
          <rhs>
            <nonterminal def="#ns-flow-yaml-content(n,c)"/>
            | <nonterminal def="#c-flow-json-content(n,c)"/>
          </rhs>
        </production>
      </productionset>

      <example>
        <title>Flow Content</title>

        <simplelist type="horiz" columns="2">
          <member>
<programlisting>- <hl1>[ a, b ]</hl1><sbr/>
- <hl1>{ a: b }</hl1>
- <hl1>"a"</hl1>
- <hl1>'b'</hl1>
- <hl2>c</hl2>
</programlisting>
<synopsis>Legend:
  <hl1><link linkend="c-flow-json-content(n,c)">c-flow-json-content(n,c)</link></hl1>
  <hl2><link linkend="ns-flow-yaml-content(n,c)">ns-flow-yaml-content(n,c)</link></hl2>
</synopsis>
          </member>
          <member>
<programlisting>%YAML 1.2<sbr/>
---
!!seq [
  !!seq [ !!str "a", !!str "b" ],
  !!map { ? !!str "a" : !!str "b" },
  !!str "a",
  !!str "b",
  !!str "c",
]
</programlisting>
          </member>
        </simplelist>
      </example>

      <para>
        A complete <refterm primary="style" secondary="flow">flow</refterm>
        <refterm primary="node">node</refterm> also has optional <refterm
        primary="node" secondary="property">node properties</refterm>, except
        for <refterm primary="alias">alias nodes</refterm> which refer to the
        <refterm primary="anchor">anchored</refterm> <refterm primary="node"
        secondary="property">node properties</refterm>.
      </para>

      <productionset>
        <production id="ns-flow-yaml-node(n,c)">
          <lhs>ns-flow-yaml-node(n,c)</lhs>
          <rhs>
            &nbsp;&nbsp;<nonterminal def="#c-ns-alias-node"/><sbr/>
            | <nonterminal def="#ns-flow-yaml-content(n,c)"/><sbr/>
            | ( <nonterminal def="#c-ns-properties(n,c)"/><sbr/>
            &nbsp;&nbsp;&nbsp;&nbsp;( (
              <nonterminal def="#s-separate(n,c)"/><sbr/>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<nonterminal
              def="#ns-flow-yaml-content(n,c)"/> )<sbr/>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
              <nonterminal def="#e-scalar"/> ) )
          </rhs>
        </production>

        <production id="c-flow-json-node(n,c)">
          <lhs>c-flow-json-node(n,c)</lhs>
          <rhs>
            ( <nonterminal def="#c-ns-properties(n,c)"/>
              <nonterminal def="#s-separate(n,c)"/> )?<sbr/>
            <nonterminal def="#c-flow-json-content(n,c)"/>
          </rhs>
        </production>

        <production id="ns-flow-node(n,c)">
          <lhs>ns-flow-node(n,c)</lhs>
          <rhs>
            &nbsp;&nbsp;<nonterminal def="#c-ns-alias-node"/><sbr/>
            | <nonterminal def="#ns-flow-content(n,c)"/><sbr/>
            | ( <nonterminal def="#c-ns-properties(n,c)"/><sbr/>
            &nbsp;&nbsp;&nbsp;&nbsp;( (
              <nonterminal def="#s-separate(n,c)"/><sbr/>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<nonterminal
              def="#ns-flow-content(n,c)"/> )<sbr/>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
              <nonterminal def="#e-scalar"/> ) )
          </rhs>
        </production>
      </productionset>

      <example>
        <title>Flow Nodes</title>

        <simplelist type="horiz" columns="2">
          <member>
<programlisting>- <hl1>!!str "a"</hl1><sbr/>
- <hl1>'b'</hl1>
- <hl1>&amp;anchor "c"</hl1>
- <hl2>*anchor</hl2>
- <hl2>!!str&deg;</hl2>
</programlisting>
<synopsis>Legend:
  <hl1><link linkend="c-flow-json-node(n,c)">c-flow-json-node(n,c)</link></hl1>
  <hl2><link linkend="ns-flow-yaml-node(n,c)">ns-flow-yaml-node(n,c)</link></hl2>
</synopsis>
          </member>
          <member>
<programlisting>%YAML 1.2<sbr/>
---
!!seq [
  !!str "a",
  !!str "b",
  &amp;A !!str "c",
  *A,
  !!str "",
]
</programlisting>
          </member>
        </simplelist>
      </example>
    </sect1>
  </chapter>

  <chapter id="Block">
    <title>Block Styles</title>

    <para>
      YAML<q/>s <defterm primary="style" secondary="block">block
      styles</defterm> employ <refterm primary="space"
      secondary="indentation">indentation</refterm> rather than <refterm
      primary="indicator">indicators</refterm> to denote structure. This
      results in a more human readable (though less compact) notation.
    </para>

    <sect1>
      <title>Block Scalar Styles</title>

      <para>
        YAML provides two <defterm primary="style" secondary="block"
        tertiary="scalar">block scalar styles</defterm>, <refterm
        primary="style" secondary="block" tertiary="literal">literal</refterm>
        and <refterm primary="style" secondary="block"
        tertiary="folded">folded</refterm>. Each provides a different trade-off
        between readability and expressive power.
      </para>

      <sect2>
        <title>Block Scalar Headers</title>

        <para>
          <refterm primary="style" secondary="block" tertiary="scalar">Block
          scalars</refterm> are controlled by a few <refterm
          primary="indicator">indicators</refterm> given in a <defterm
          primary="block scalar header">header</defterm> preceding the <refterm
          primary="content">content</refterm> itself. This header is followed
          by a non-content <refterm primary="line break">line break</refterm>
          with an optional <refterm primary="comment">comment</refterm>. This
          is the only case where a <refterm primary="comment">comment</refterm>
          must not be followed by additional <refterm
          primary="comment">comment</refterm> lines.
        </para>

        <productionset>
          <production id="c-b-block-header(m,t)">
            <lhs>c-b-block-header(m,t)</lhs>
            <rhs>
              ( (
                <nonterminal def="#c-indentation-indicator(m)"/><sbr/>
              &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal
                def="#c-chomping-indicator(t)"/> )<sbr/>
              | ( <nonterminal def="#c-chomping-indicator(t)"/><sbr/>
              &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal
                def="#c-indentation-indicator(m)"/> ) )<sbr/>
              <nonterminal def="#s-b-comment"/>
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Block Scalar Header</title>

          <simplelist type="horiz" columns="2">
            <member>
<programlisting>- |<hl1> # Empty header&darr;</hl1><sbr/>
 literal
- &gt;<hl1>1 # Indentation indicator&darr;</hl1>
 &middot;folded
- |<hl1>+ # Chomping indicator&darr;</hl1>
 keep

- &gt;<hl1>1- # Both indicators&darr;</hl1>
 &middot;strip

</programlisting>
            </member>
            <member>
<programlisting>%YAML 1.2<sbr/>
---
!!seq [
  !!str "literal\n",
  !!str "&middot;folded\n",
  !!str "keep\n\n",
  !!str "&middot;strip",
]
</programlisting>
<synopsis>&nbsp;Legend:
   <hl1><link linkend="c-b-block-header(m,t)">c-b-block-header(m,t)</link></hl1>
</synopsis>
            </member>
          </simplelist>
        </example>

        <sect3>
          <title>Block Indentation Indicator</title>

          <para>
            Typically, the <refterm primary="space"
            secondary="indentation">indentation</refterm> level of a <refterm
            primary="style" secondary="block" tertiary="scalar">block
            scalar</refterm> is detected from its first non-<refterm
            primary="empty line">empty</refterm> line. It is an error for any
            of the leading <refterm primary="empty line">empty lines</refterm>
            to contain more <refterm primary="space">spaces</refterm> than the
            first non-<refterm primary="empty line">empty line</refterm>.
          </para>

          <para>
            Detection fails when the first non-<refterm primary="empty
            line">empty line</refterm> contains leading content <refterm
            primary="space">space</refterm> characters. <refterm
            primary="content">Content</refterm> may safely start with a
            <refterm primary="tab">tab</refterm> or a <refterm primary="#
            comment"><uquote>#</uquote></refterm> character.
          </para>

          <para>
            When detection would fail, YAML requires that the <refterm
            primary="space" secondary="indentation">indentation</refterm> level
            for the <refterm primary="content">content</refterm> be given using
            an explicit <defterm primary="indicator"
            secondary="indentation">indentation indicator</defterm>. This level
            is specified as the integer number of the additional <refterm
            primary="space" secondary="indentation">indentation</refterm>
            spaces used for the <refterm primary="content">content</refterm>,
            relative to its parent <refterm primary="node">node</refterm>.
          </para>

          <para>
            It is always valid to specify an indentation indicator for a
            <refterm primary="style" secondary="block" tertiary="scalar">block
            scalar</refterm> node, though a YAML <refterm
            primary="processor">processor</refterm> should only emit an
            explicit indentation indicator for cases where detection will fail.
          </para>

          <productionset>
            <production id="c-indentation-indicator(m)">
              <lhs>c-indentation-indicator(m)</lhs>
              <rhs>
                <nonterminal def="#ns-dec-digit"/>
                  &rArr; m = <nonterminal def="#ns-dec-digit"/> - #x30<sbr/>
                /* Empty */&nbsp; &rArr; m = auto-detect()
              </rhs>
            </production>
          </productionset>

          <example>
            <title>Block Indentation Indicator</title>

            <simplelist type="horiz" columns="2">
              <member>
<programlisting>- |<hl1>&deg;</hl1><sbr/>
<hl2>&middot;</hl2>detected
- &gt;<hl1>&deg;</hl1>
<hl2>&middot;</hl2>
<hl2>&middot;&middot;</hl2>
<hl2>&middot;&middot;</hl2># detected
- |<hl1>1</hl1>
<hl2>&middot;</hl2>&middot;explicit
- &gt;<hl1>&deg;</hl1>
<hl2>&middot;</hl2>&rarr;
<hl2>&middot;</hl2>detected
</programlisting>
              </member>
              <member>
<programlisting>%YAML 1.2<sbr/>
---
!!seq [
  !!str "detected\n",
  !!str "\n\n# detected\n",
  !!str "&middot;explicit\n",
  !!str "\t&middot;detected\n",
]
</programlisting>
<synopsis>&nbsp;Legend:
   <hl1><link linkend="c-indentation-indicator(m)">c-indentation-indicator(m)</link></hl1>
   <hl2><link linkend="s-indent(n)">s-indent(n)</link></hl2>
</synopsis>
              </member>
            </simplelist>
          </example>

          <example>
            <title>Invalid Block Scalar Indentation Indicators</title>

            <simplelist type="horiz" columns="2">
              <member>
<screen>- |<sbr/>
&middot;<hl1>&middot;</hl1>
&middot;text
- &gt;
&middot;&middot;text
<hl2>&middot;</hl2>text
- |2
<hl3>&middot;</hl3>text
</screen>
              </member>
              <member>
<screen>ERROR:<sbr/>
- A leading all-space line must
  not have too many <hl1>spaces</hl1>.
- A following text line must
  not be <hl2>less indented</hl2>.
- The text is <hl3>less indented</hl3>
  than the indicated level.
</screen>
              </member>
            </simplelist>
          </example>
        </sect3>

        <sect3>
          <title>Block Chomping Indicator</title>

          <para>
            <defterm primary="chomping">Chomping</defterm> controls how final
            <refterm primary="line break">line breaks</refterm> and trailing
            <refterm primary="empty line">empty lines</refterm> are
            interpreted. YAML provides three chomping methods:
          </para>

          <variablelist>
            <varlistentry>
              <term>Strip</term>

              <listitem>
                <defterm primary="chomping"
                secondary="strip">Stripping</defterm> is specified by the
                <defterm primary="- strip chomping"><uquote>-</uquote>
                chomping indicator</defterm>. In this case, the final
                <refterm primary="line break">line break</refterm> and any
                trailing <refterm primary="empty line">empty lines</refterm>
                are excluded from the <refterm primary="scalar">scalar<q/>s
                content</refterm>.
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Clip</term>

              <listitem>
                <defterm primary="chomping"
                secondary="clip">Clipping</defterm> is the default behavior
                used if no explicit chomping indicator is specified. In this
                case, the final <refterm primary="line break">line
                break</refterm> character is preserved in the <refterm
                primary="scalar">scalar<q/>s content</refterm>. However, any
                trailing <refterm primary="empty line">empty lines</refterm>
                are excluded from the <refterm primary="scalar">scalar<q/>s
                content</refterm>.
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Keep</term>

              <listitem>
                <defterm primary="chomping" secondary="keep">Keeping</defterm>
                is specified by the <defterm primary="+ keep
                chomping"><uquote>+</uquote> chomping indicator</defterm>. In
                this case, the final <refterm primary="line break">line
                break</refterm> and any trailing <refterm primary="empty
                line">empty lines</refterm> are considered to be part of the
                <refterm primary="scalar">scalar<q/>s content</refterm>. These
                additional lines are not subject to <refterm primary="line
                folding">folding</refterm>.
              </listitem>
            </varlistentry>
          </variablelist>

          <para>
            The chomping method used is a <refterm primary="presentation"
            secondary="detail">presentation detail</refterm> and must not be
            used to convey <refterm primary="content">content</refterm>
            information.
          </para>

          <productionset>
            <production id="c-chomping-indicator(t)">
              <lhs>c-chomping-indicator(t)</lhs>
              <rhs>
                <quote>-</quote
                  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &rArr;
                  <varname>t</varname> = strip<sbr/>
                <quote>+</quote
                  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &rArr;
                <varname>t</varname> = keep<sbr/>
                /* Empty */ &rArr;
                  <varname>t</varname> = clip
              </rhs>
            </production>
          </productionset>

          <para>
            The interpretation of the final <refterm primary="line break">line
            break</refterm> of a <refterm primary="style" secondary="block"
            tertiary="scalar">block scalar</refterm> is controlled by the
            chomping indicator specified in the <refterm primary="block scalar
            header">block scalar header</refterm>.
          </para>

          <productionset>
            <production id="b-chomped-last(t)">
              <lhs>b-chomped-last(t)</lhs>
              <rhs>
                <varname>t</varname> = strip &rArr;
                <nonterminal def="#b-non-content"/> | /* End of file */<sbr/>
                <varname>t</varname> = clip&nbsp; &rArr;
                <nonterminal def="#b-as-line-feed"/> | /* End of file */<sbr/>
                <varname>t</varname> = keep&nbsp; &rArr;
                <nonterminal def="#b-as-line-feed"/> | /* End of file */
              </rhs>
            </production>
          </productionset>

          <example>
            <title>Chomping Final Line Break</title>

            <simplelist type="horiz" columns="2">
              <member>
<programlisting>strip: |-<sbr/>
  text<hl1>&darr;</hl1>
clip: |
  text<hl2>&darr;</hl2>
keep: |+
  text<hl2>&darr;</hl2>
</programlisting>
<synopsis>Legend:
  <hl1><link linkend="b-non-content">b-non-content</link></hl1> <hl2><link linkend="b-as-line-feed">b-as-line-feed</link></hl2>
</synopsis>
              </member>
              <member>
<programlisting>%YAML 1.2<sbr/>
---
!!map {
  ? !!str "strip"
  : !!str "text",
  ? !!str "clip"
  : !!str "text\n",
  ? !!str "keep"
  : !!str "text\n",
}
</programlisting>
              </member>
            </simplelist>
          </example>

          <para>
            The interpretation of the trailing <refterm primary="empty
            line">empty lines</refterm> following a <refterm primary="style"
            secondary="block" tertiary="scalar">block scalar</refterm> is also
            controlled by the chomping indicator specified in the <refterm
            primary="block scalar header">block scalar header</refterm>.
          </para>

          <productionset>
            <production id="l-chomped-empty(n,t)">
              <lhs>l-chomped-empty(n,t)</lhs>
              <rhs>
                <varname>t</varname> = strip &rArr;
                <nonterminal def="#l-strip-empty(n)"/><sbr/>
                <varname>t</varname> = clip&nbsp; &rArr;
                <nonterminal def="#l-strip-empty(n)"/><sbr/>
                <varname>t</varname> = keep&nbsp; &rArr;
                <nonterminal def="#l-keep-empty(n)"/>
              </rhs>
            </production>

            <production id="l-strip-empty(n)">
              <lhs>l-strip-empty(n)</lhs>
              <rhs>
                ( <nonterminal
                    def="#s-indent(n)">s-indent(&le;n)</nonterminal>
                <nonterminal def="#b-non-content"/> )*<sbr/>
                <nonterminal def="#l-trail-comments(n)"/>?
              </rhs>
            </production>

            <production id="l-keep-empty(n)">
              <lhs>l-keep-empty(n)</lhs>
              <rhs>
                <nonterminal def="#l-empty(n,c)"
                  >l-empty(n,block-in)</nonterminal>*<sbr/>
                <nonterminal def="#l-trail-comments(n)"/>?
              </rhs>
            </production>
          </productionset>

          <para>
            Explicit <refterm primary="comment">comment</refterm> lines may
            follow the trailing <refterm primary="empty line">empty
            lines</refterm>. To prevent ambiguity, the first such <refterm
            primary="comment">comment</refterm> line must be less <refterm
            primary="space" secondary="indentation">indented</refterm> than the
            <refterm primary="style" secondary="block" tertiary="scalar">block
            scalar content</refterm>. Additional <refterm
            primary="comment">comment</refterm> lines, if any, are not so
            restricted. This is the only case where the <refterm
            primary="space" secondary="indentation">indentation</refterm> of
            <refterm primary="comment">comment</refterm> lines is constrained.
          </para>

          <productionset>
            <production id="l-trail-comments(n)">
              <lhs>l-trail-comments(n)</lhs>
              <rhs>
                <nonterminal
                  def="#s-indent(n)">s-indent(&lt;n)</nonterminal>
                <nonterminal def="#c-nb-comment-text"/>
                <nonterminal def="#b-comment"/><sbr/>
                <nonterminal def="#l-comment"/>*
              </rhs>
            </production>
          </productionset>

          <example>
            <title>Chomping Trailing Lines</title>

            <simplelist type="horiz" columns="2">
              <member>
<programlisting> # Strip<sbr/>
  # Comments:
strip: |-
  # text&darr;
<HL><hl1>&middot;&middot;&dArr;
<hl3>&middot;# Clip
&middot;&middot;# comments:
&darr;</hl3></hl1></HL>
clip: |
  # text&darr;
<HL><hl1>&middot;&darr;
<hl3>&middot;# Keep
&middot;&middot;# comments:
&darr;</hl3></hl1></HL>
keep: |+
  # text&darr;
<HL><hl2>&darr;
<hl3>&middot;# Trail
&middot;&middot;# comments.</hl3></hl2></HL>
</programlisting>
              </member>
              <member>
<programlisting>%YAML 1.2<sbr/>
---
!!map {
  ? !!str "strip"
  : !!str "# text",
  ? !!str "clip"
  : !!str "# text\n",
  ? !!str "keep"
  : !!str "# text\n\n",
}
</programlisting>
<synopsis>&nbsp;Legend:
   <hl1><link linkend="l-strip-empty(n)">l-strip-empty(n)</link></hl1>
   <hl2><link linkend="l-keep-empty(n)">l-keep-empty(n)</link></hl2>
   <hl3><link linkend="l-trail-comments(n)">l-trail-comments(n)</link></hl3>
</synopsis>
              </member>
            </simplelist>
          </example>

          <para>
            If a <refterm primary="style" secondary="block"
            tertiary="scalar">block scalar</refterm> consists only of <refterm
            primary="empty line">empty lines</refterm>, then these lines are
            considered as trailing lines and hence are affected by chomping.
          </para>

          <example>
            <title>Empty Scalar Chomping</title>

            <simplelist type="horiz" columns="2">
              <member>
<programlisting>strip: >-<sbr/>
<hl1>&darr;</hl1>
clip: >
<hl1>&darr;</hl1>
keep: |+
<hl2>&darr;</hl2>
</programlisting>
<synopsis>Legend:
  <hl1><link linkend="l-strip-empty(n)">l-strip-empty(n)</link></hl1> <hl2><link linkend="l-keep-empty(n)">l-keep-empty(n)</link></hl2>
</synopsis>
              </member>
              <member>
<programlisting>%YAML 1.2<sbr/>
---
!!map {
  ? !!str "strip"
  : !!str "",
  ? !!str "clip"
  : !!str "",
  ? !!str "keep"
  : !!str "\n",
}
</programlisting>
              </member>
            </simplelist>
          </example>
        </sect3>
      </sect2>

      <sect2>
        <title>Literal Style</title>

        <para>
          The <defterm primary="style" secondary="block"
          tertiary="literal">literal style</defterm> is denoted by the <defterm
          primary="| literal style"><uquote>|</uquote> indicator</defterm>. It
          is the simplest, most restricted, and most readable <refterm
          primary="style" secondary="scalar">scalar style</refterm>.
        </para>

        <productionset>
          <production id="c-l+literal(n)">
            <lhs>c-l+literal(n)</lhs>
            <rhs>
              <nonterminal def="#c-literal"><quote>|</quote></nonterminal>
              <nonterminal def="#c-b-block-header(m,t)"
                >c-b-block-header(m,t)</nonterminal><sbr/>
              <nonterminal def="#l-literal-content(n,t)"
                >l-literal-content(n+m,t)</nonterminal>
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Literal Scalar</title>

          <simplelist type="horiz" columns="2">
            <member>
<programlisting><hl1>|&darr;<sbr/>
&middot;literal&darr;
&middot;&rarr;text&darr;
&darr;</hl1>
</programlisting>
<synopsis>Legend:
  <hl1><link linkend="c-l+literal(n)">c-l+literal(n)</link></hl1>
</synopsis>
            </member>
            <member>
<programlisting>%YAML 1.2<sbr/>
---
!!str "literal\n\ttext\n"
</programlisting>
            </member>
          </simplelist>
        </example>

        <para>
          Inside literal scalars, all (<refterm primary="space"
          secondary="indentation">indented</refterm>) characters are considered
          to be <refterm primary="content">content</refterm>, including
          <refterm primary="space" secondary="white">white space</refterm>
          characters. Note that all <refterm primary="line break">line
          break</refterm> characters are <refterm primary="line break"
          secondary="normalization">normalized</refterm>. In addition, <refterm
          primary="empty line">empty lines</refterm> are not <refterm
          primary="style" secondary="block" tertiary="folded">folded</refterm>,
          though final <refterm primary="line break">line breaks</refterm> and
          trailing <refterm primary="empty line">empty lines</refterm> are
          <refterm primary="chomping">chomped</refterm>.
        </para>

        <para>
          There is no way to escape characters inside literal scalars. This
          restricts them to <refterm primary="printable
          character">printable</refterm> characters. In addition, there is no
          way to break a long literal line.
        </para>

        <productionset>
          <production id="l-nb-literal-text(n)">
            <lhs>l-nb-literal-text(n)</lhs>
            <rhs>
              <nonterminal def="#l-empty(n,c)"
                >l-empty(n,block-in)</nonterminal>*<sbr/>
              <nonterminal def="#s-indent(n)"/>
              <nonterminal def="#nb-char"/>+
            </rhs>
          </production>

          <production id="b-nb-literal-next(n)">
            <lhs>b-nb-literal-next(n)</lhs>
            <rhs>
              <nonterminal def="#b-as-line-feed"/><sbr/>
              <nonterminal def="#l-nb-literal-text(n)"/>
            </rhs>
          </production>

          <production id="l-literal-content(n,t)">
            <lhs>l-literal-content(n,t)</lhs>
            <rhs>
              ( <nonterminal def="#l-nb-literal-text(n)"/>
              <nonterminal def="#b-nb-literal-next(n)"/>*<sbr/>
              &nbsp;&nbsp;<nonterminal def="#b-chomped-last(t)"/> )?<sbr/>
              <nonterminal def="#l-chomped-empty(n,t)"/>
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Literal Content</title>

          <simplelist type="horiz" columns="2">
            <member>
<programlisting>|<sbr/>
<hl1>&middot;
&middot;&middot;
&middot;&middot;literal</hl1><HL><hl2>&darr;
<hl1>&middot;&middot;&middot;</hl1></hl2></HL><HL><hl2>&darr;
<hl1>&middot;&middot;
&middot;&middot;text</hl1></hl2></HL><hl3>&darr;</hl3>
<hl4>&darr;
&middot;# Comment</hl4>
</programlisting>
            </member>
            <member>
<programlisting>%YAML 1.2<sbr/>
---
!!str "\n\nliteral\n&middot;\n\ntext\n"
</programlisting>
<synopsis>&nbsp;Legend:
   <hl1><link linkend="l-nb-literal-text(n)">l-nb-literal-text(n)</link></hl1>
   <hl2><link linkend="b-nb-literal-next(n)">b-nb-literal-next(n)</link></hl2>
   <hl3><link linkend="b-chomped-last(t)">b-chomped-last(t)</link></hl3>
   <hl4><link linkend="l-chomped-empty(n,t)">l-chomped-empty(n,t)</link></hl4>
</synopsis>
            </member>
          </simplelist>
        </example>
      </sect2>

      <sect2>
        <title>Folded Style</title>

        <para>
          The <defterm primary="style" secondary="block"
          tertiary="folded">folded style</defterm> is denoted by the <defterm
          primary="> folded style"><uquote>&gt;</uquote> indicator</defterm>.
          It is similar to the <refterm primary="style" secondary="block"
          tertiary="literal">literal style</refterm>; however, folded scalars
          are subject to <refterm primary="line folding" secondary="block">line
          folding</refterm>.
        </para>

        <productionset>
          <production id="c-l+folded(n)">
            <lhs>c-l+folded(n)</lhs>
            <rhs>
              <nonterminal def="#c-folded"><quote>&gt;</quote></nonterminal>
              <nonterminal def="#c-b-block-header(m,t)"
                >c-b-block-header(m,t)</nonterminal><sbr/>
              <nonterminal def="#l-folded-content(n,t)"
                >l-folded-content(n+m,t)</nonterminal>
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Folded Scalar</title>

          <simplelist type="horiz" columns="2">
            <member>
<programlisting><hl1>&gt;&darr;<sbr/>
&middot;folded&darr;
&middot;text&darr;
&darr;</hl1>
</programlisting>
            </member>
            <member>
<programlisting>%YAML 1.2<sbr/>
---
!!str "folded text\n"
</programlisting>
<synopsis>Legend:
  <hl1><link linkend="c-l+folded(n)">c-l+folded(n)</link></hl1>
</synopsis>
            </member>
          </simplelist>
        </example>

        <para>
          <refterm primary="line folding">Folding</refterm> allows long lines
          to be broken anywhere a single <refterm
          primary="space">space</refterm> character separates two non-<refterm
          primary="space" secondary="white">space</refterm> characters.
        </para>

        <productionset>
          <production id="s-nb-folded-text(n)">
            <lhs>s-nb-folded-text(n)</lhs>
            <rhs>
              <nonterminal def="#s-indent(n)"/>
              <nonterminal def="#ns-char"/>
              <nonterminal def="#nb-char"/>*
            </rhs>
          </production>

          <production id="l-nb-folded-lines(n)">
            <lhs>l-nb-folded-lines(n)</lhs>
            <rhs>
              <nonterminal def="#s-nb-folded-text(n)"/><sbr/>
              ( <nonterminal def="#b-l-folded(n,c)"
                  >b-l-folded(n,block-in)</nonterminal>
              <nonterminal def="#s-nb-folded-text(n)"/> )*
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Folded Lines</title>

          <simplelist type="horiz" columns="2">
            <member>
<programlisting>&gt;<sbr/>

<HL><hl2><hl1>&middot;folded</hl1>&darr;
<hl1>&middot;line</hl1>&darr;
&darr;
<hl1>&middot;next</hl1>
<hl1>&middot;line</hl1></hl2></HL>&darr;
   * bullet

   * list
   * lines

<HL><hl2><hl1>&middot;last</hl1>&darr;
<hl1>&middot;line</hl1></hl2></HL>&darr;

# Comment
</programlisting>
            </member>
            <member>
<programlisting>%YAML 1.2<sbr/>
---
!!str "\n\
      folded line\n\
      next line\n\
      \  * bullet\n
      \n\
      \  * list\n\
      \  * lines\n\
      \n\
      last line\n"
</programlisting>
<synopsis>&nbsp;Legend:
   <hl1><link linkend="s-nb-folded-text(n)">s-nb-folded-text(n)</link></hl1>
   <hl2><link linkend="l-nb-folded-lines(n)">l-nb-folded-lines(n)</link></hl2>
</synopsis>
            </member>
          </simplelist>
        </example>

        <para>
          (The following three examples duplicate this example, each
          highlighting different productions.)
        </para>

        <para>
          Lines starting with <refterm primary="space" secondary="white">white
          space</refterm> characters (<defterm
          primary="more-indented">more-indented</defterm> lines) are not
          <refterm primary="line folding">folded</refterm>.
        </para>

        <productionset>
          <production id="s-nb-spaced-text(n)">
            <lhs>s-nb-spaced-text(n)</lhs>
            <rhs>
              <nonterminal def="#s-indent(n)"/>
              <nonterminal def="#s-white"/>
              <nonterminal def="#nb-char"/>*
            </rhs>
          </production>

          <production id="b-l-spaced(n)">
            <lhs>b-l-spaced(n)</lhs>
            <rhs>
              <nonterminal def="#b-as-line-feed"/><sbr/>
              <nonterminal def="#l-empty(n,c)"
                >l-empty(n,block-in)</nonterminal>*
            </rhs>
          </production>

          <production id="l-nb-spaced-lines(n)">
            <lhs>l-nb-spaced-lines(n)</lhs>
            <rhs>
              <nonterminal def="#s-nb-spaced-text(n)"/><sbr/>
              ( <nonterminal def="#b-l-spaced(n)"/>
              <nonterminal def="#s-nb-spaced-text(n)"/> )*<sbr/>
            </rhs>
          </production>
        </productionset>

        <example>
          <title>More Indented Lines</title>

          <simplelist type="horiz" columns="2">
            <member>
<programlisting>&gt;<sbr/>

 folded
 line

 next
 line
<HL><hl2><hl1>&middot;&middot;&middot;* bullet</hl1>&darr;
&darr;
<hl1>&middot;&middot;&middot;* list</hl1>&darr;
<hl1>&middot;&middot;&middot;* lines</hl1></hl2></HL>&darr;

 last
 line

# Comment
</programlisting>
            </member>
            <member>
<programlisting>%YAML 1.2<sbr/>
---
!!str "\n\
      folded line\n\
      next line\n\
      \  * bullet\n
      \n\
      \  * list\n\
      \  * lines\n\
      \n\
      last line\n"
</programlisting>
<synopsis>&nbsp;Legend:
   <hl1><link linkend="s-nb-spaced-text(n)">s-nb-spaced-text(n)</link></hl1>
   <hl2><link linkend="l-nb-spaced-lines(n)">l-nb-spaced-lines(n)</link></hl2>
</synopsis>
            </member>
          </simplelist>
        </example>

        <para>
          <refterm primary="line break">Line breaks</refterm> and <refterm
          primary="empty line">empty lines</refterm> separating folded and
          more-indented lines are also not <refterm primary="line
          folding">folded</refterm>.
        </para>

        <productionset>
          <production id="l-nb-same-lines(n)">
            <lhs>l-nb-same-lines(n)</lhs>
            <rhs>
              <nonterminal def="#l-empty(n,c)"
                >l-empty(n,block-in)</nonterminal>*<sbr/>
              ( <nonterminal def="#l-nb-folded-lines(n)"/>
              | <nonterminal def="#l-nb-spaced-lines(n)"/> )
            </rhs>
          </production>

          <production id="l-nb-diff-lines(n)">
            <lhs>l-nb-diff-lines(n)</lhs>
            <rhs>
              <nonterminal def="#l-nb-same-lines(n)"/><sbr/>
              ( <nonterminal def="#b-as-line-feed"/>
              <nonterminal def="#l-nb-same-lines(n)"/> )*
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Empty Separation Lines</title>

          <simplelist type="horiz" columns="2">
            <member>
<programlisting>&gt;<sbr/>
<hl2>&darr;</hl2>
 folded
 line<hl1>&darr;</hl1>
<hl2>&darr;</hl2>
 next
 line<hl1>&darr;</hl1>
   * bullet

   * list
   * line<hl1>&darr;</hl1>
<hl2>&darr;</hl2>
 last
 line

# Comment
</programlisting>
            </member>
            <member>
<programlisting>%YAML 1.2<sbr/>
---
!!str "\n\
      folded line\n\
      next line\n\
      \  * bullet\n
      \n\
      \  * list\n\
      \  * lines\n\
      \n\
      last line\n"
</programlisting>
<synopsis>&nbsp;Legend:
   <hl1><link linkend="b-as-line-feed">b-as-line-feed</link></hl1>
   <hl2>(separation) <link linkend="l-empty(n,c)">l-empty(n,c)</link></hl2>
</synopsis>
            </member>
          </simplelist>
        </example>

        <para>
          The final <refterm primary="line break">line break</refterm>, and
          trailing <refterm primary="empty line">empty lines</refterm> if any,
          are subject to <refterm primary="chomping">chomping</refterm> and are
          never <refterm primary="line folding">folded</refterm>.
        </para>

        <productionset>
          <production id="l-folded-content(n,t)">
            <lhs>l-folded-content(n,t)</lhs>
            <rhs>
              ( <nonterminal def="#l-nb-diff-lines(n)"/>
              <nonterminal def="#b-chomped-last(t)"/> )?<sbr/>
              <nonterminal def="#l-chomped-empty(n,t)"/>
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Final Empty Lines</title>

          <simplelist type="horiz" columns="2">
            <member>
<programlisting>&gt;<sbr/>
 folded
 line

 next
 line
   * bullet

   * list
   * line

 last
 line<hl1>&darr;</hl1>
<hl2>&darr;
# Comment</hl2>
</programlisting>
            </member>
            <member>
<programlisting>%YAML 1.2<sbr/>
---
!!str "\n\
      folded line\n\
      next line\n\
      \  * bullet\n
      \n\
      \  * list\n\
      \  * lines\n\
      \n\
      last line\n"
</programlisting>
<synopsis>&nbsp;Legend:
   <hl1><link linkend="b-chomped-last(t)">b-chomped-last(t)</link></hl1> <hl2><link linkend="l-chomped-empty(n,t)">l-chomped-empty(n,t)</link></hl2>
</synopsis>
            </member>
          </simplelist>
        </example>
      </sect2>
    </sect1>

    <sect1>
      <title>Block Collection Styles</title>

      <para>
        For readability, <defterm primary="style" secondary="block"
        tertiary="collection">block collections styles</defterm> are not
        denoted by any <refterm primary="indicator">indicator</refterm>.
        Instead, YAML uses a lookahead method, where a block collection is
        distinguished from a <refterm primary="style" secondary="flow"
        tertiary="plain">plain scalar</refterm> only when a <refterm
        primary="key: value pair">key:&nbsp;value pair</refterm> or a <refterm
        primary="- block sequence entry">sequence entry</refterm> is seen.
      </para>

      <sect2>
        <title>Block Sequences</title>

        <para>
          A <defterm primary="style" secondary="block"
          tertiary="sequence">block sequence</defterm> is simply a series of
          <refterm primary="node">nodes</refterm>, each denoted by a leading
          <defterm primary="- block sequence entry"><uquote>-</uquote>
          indicator</defterm>. The <uquote>-</uquote> indicator must be
          <refterm primary="space" secondary="separation">separated</refterm>
          from the <refterm primary="node">node</refterm> by <refterm
          primary="space" secondary="white">white space</refterm>. This allows
          <uquote>-</uquote> to be used as the first character in a <refterm
          primary="style" secondary="flow" tertiary="plain">plain
          scalar</refterm> if followed by a non-space character (e.g.
          <uquote>-1</uquote>).
        </para>

        <productionset>
          <production id="l+block-sequence(n)">
            <lhs>l+block-sequence(n)</lhs>
            <rhs>
              ( <nonterminal def="#s-indent(n)"
                  >s-indent(n+m)</nonterminal>
                <nonterminal def="#c-l-block-seq-entry(n)"
                  >c-l-block-seq-entry(n+m)</nonterminal> )+<sbr/>
              /* For some fixed auto-detected <varname>m</varname> &gt; 0 */
            </rhs>
          </production>

          <production id="c-l-block-seq-entry(n)">
            <lhs>c-l-block-seq-entry(n)</lhs>
            <rhs>
              <nonterminal def="#c-sequence-entry"
                ><quote>-</quote></nonterminal> /* Not followed by an
                  <nonterminal def="#ns-char"/> */<sbr/>
              <nonterminal def="#s-l+block-indented(n,c)"
                >s-l+block-indented(n,block-in)</nonterminal>
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Block Sequence</title>

          <simplelist type="horiz" columns="2">
            <member>
<programlisting>block sequence:<sbr/>
&middot;&middot;<hl1>- one&darr;</hl1>
  <hl1>- two : three&darr;</hl1>
</programlisting>
<synopsis>Legend:
  <hl1><link linkend="c-l-block-seq-entry(n)">c-l-block-seq-entry(n)</link></hl1>
  <hl2>auto-detected <link linkend="s-indent(n)">s-indent(n)</link></hl2>
</synopsis>
            </member>
            <member>
<programlisting>%YAML 1.2<sbr/>
---
!!map {
  ? !!str "block sequence"
  : !!seq [
    !!str "one",
    !!map {
      ? !!str "two"
      : !!str "three"
    },
  ],
}
</programlisting>
            </member>
          </simplelist>
        </example>

        <para>
          The entry <refterm primary="node">node</refterm> may be either
          <refterm primary="node" secondary="completely empty">completely
          empty</refterm>, be a nested <refterm primary="style"
          secondary="block">block node</refterm>, or use a <defterm
          primary="style" secondary="compact block collection">compact in-line
          notation</defterm>. The compact notation may be used when the entry
          is itself a nested <refterm primary="style" secondary="block"
          tertiary="collection">block collection</refterm>. In this case, both
          the <uquote>-</uquote> indicator and the following <refterm
          primary="space">spaces</refterm> are considered to be part of the
          <refterm primary="space"
          secondary="indentation">indentation</refterm> of the nested <refterm
          primary="style" secondary="block"
          tertiary="collection">collection</refterm>. Note that it is not
          possible to specify <refterm primary="node" secondary="property">node
          properties</refterm> for such a <refterm primary="style"
          secondary="block" tertiary="collection">collection</refterm>.
        </para>

        <productionset>
          <production id="s-l+block-indented(n,c)">
            <lhs>s-l+block-indented(n,c)</lhs>
            <rhs>
              &nbsp;&nbsp;( <nonterminal
                def="#s-indent(n)">s-indent(m)</nonterminal><sbr/>
              &nbsp;&nbsp;&nbsp;&nbsp;(
                <nonterminal def="#ns-l-compact-sequence(n)"
                  >ns-l-compact-sequence(n+1+m)</nonterminal><sbr/>
              &nbsp;&nbsp;&nbsp;&nbsp;|
                <nonterminal def="#ns-l-compact-mapping(n)"
                  >ns-l-compact-mapping(n+1+m)</nonterminal> ) )<sbr/>
              | <nonterminal def="#s-l+block-node(n,c)"/><sbr/>
              | ( <nonterminal def="#e-node"/>
                  <nonterminal def="#s-l-comments"/> )
            </rhs>
          </production>

          <production id="ns-l-compact-sequence(n)">
            <lhs>ns-l-compact-sequence(n)</lhs>
            <rhs>
              <nonterminal def="#c-l-block-seq-entry(n)"/><sbr/>
              ( <nonterminal def="#s-indent(n)"/>
              <nonterminal def="#c-l-block-seq-entry(n)"/> )*
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Block Sequence Entry Types</title>

          <simplelist type="horiz" columns="2">
            <member>
<programlisting>-<hl1>&deg; # Empty</hl1><sbr/>
-<hl2> |
 block node</hl2>
-<hl3>&middot;- one # Compact
&middot;&middot;- two # sequence</hl3>
-<hl4> one: two # Compact mapping</hl4>
</programlisting>
<synopsis>Legend:
  <hl1>Empty</hl1>
  <hl2><link linkend="s-l+block-node(n,c)">s-l+block-node(n,c)</link></hl2>
  <hl3><link linkend="ns-l-compact-sequence(n)">ns-l-compact-sequence(n)</link></hl3>
  <hl4><link linkend="ns-l-compact-mapping(n)">ns-l-compact-mapping(n)</link></hl4>
</synopsis>
            </member>
            <member>
<programlisting>%YAML 1.2<sbr/>
---
!!seq [
  !!null "",
  !!str "block node\n",
  !!seq [
    !!str "one"
    !!str "two",
  ],
  !!map {
    ? !!str "one"
    : !!str "two",
  },
]
</programlisting>
            </member>
          </simplelist>
        </example>
      </sect2>

      <sect2>
        <title>Block Mappings</title>

        <para>
          A <defterm primary="style" secondary="block" tertiary="mapping">Block
          mapping</defterm> is a series of entries, each <refterm
          primary="present">presenting</refterm> a <refterm primary="key: value
          pair">key:&nbsp;value pair</refterm>.
        </para>

        <productionset>
          <production id="l+block-mapping(n)">
            <lhs>l+block-mapping(n)</lhs>
            <rhs>
              ( <nonterminal def="#s-indent(n)"
                  >s-indent(n+m)</nonterminal>
                <nonterminal def="#ns-l-block-map-entry(n)"
                  >ns-l-block-map-entry(n+m)</nonterminal> )+<sbr/>
              /* For some fixed auto-detected <varname>m</varname> &gt; 0 */
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Block Mappings</title>

          <simplelist type="horiz" columns="2">
            <member>
<programlisting>block mapping:<sbr/>
<hl2>&middot;</hl2><hl1>key: value&darr;</hl1>
</programlisting>
<synopsis>Legend:
  <hl1><link linkend="ns-l-block-map-entry(n)">ns-l-block-map-entry(n)</link></hl1>
  <hl2>auto-detected <link linkend="s-indent(n)">s-indent(n)</link></hl2>
</synopsis>
            </member>
            <member>
<programlisting>%YAML 1.2<sbr/>
---
!!map {
  ? !!str "block mapping"
  : !!map {
    ? !!str "key"
    : !!str "value",
  },
}
</programlisting>
            </member>
          </simplelist>
        </example>

        <para>
          If the <refterm primary="? mapping key"><uquote>?</uquote></refterm>
          indicator is specified, the optional value node must be specified on
          a separate line, denoted by the <refterm primary=": mapping
          value"><uquote>:</uquote></refterm> indicator. Note that YAML allows
          here the same <refterm primary="style" secondary="compact block
          collection">compact in-line notation</refterm> described above for
          <refterm primary="style" secondary="block" tertiary="sequence">block
          sequence</refterm> entries.
        </para>

        <productionset>
          <production id="ns-l-block-map-entry(n)">
            <lhs>ns-l-block-map-entry(n)</lhs>
            <rhs>
              &nbsp;&nbsp;<nonterminal
                def="#c-l-block-map-explicit-entry(n)"/><sbr/>
              | <nonterminal def="#ns-l-block-map-implicit-entry(n)"/>
            </rhs>
          </production>

          <production id="c-l-block-map-explicit-entry(n)">
            <lhs>c-l-block-map-explicit-entry(n)</lhs>
            <rhs>
              <nonterminal def="#c-l-block-map-explicit-key(n)"/><sbr/>
              ( <nonterminal def="#l-block-map-explicit-value(n)"/><sbr/>
              | <nonterminal def="#e-node"/> )
            </rhs>
          </production>

          <production id="c-l-block-map-explicit-key(n)">
            <lhs>c-l-block-map-explicit-key(n)</lhs>
            <rhs>
              <nonterminal
                def="#c-mapping-key"><quote>?</quote></nonterminal>
              <nonterminal def="#s-l+block-indented(n,c)"
                >s-l+block-indented(n,block-out)</nonterminal>
            </rhs>
          </production>

          <production id="l-block-map-explicit-value(n)">
            <lhs>l-block-map-explicit-value(n)</lhs>
            <rhs>
              <nonterminal def="#s-indent(n)"/><sbr/>
              <nonterminal
                def="#c-mapping-value"><quote>:</quote></nonterminal>
              <nonterminal def="#s-l+block-indented(n,c)"
                >s-l+block-indented(n,block-out)</nonterminal>
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Explicit Block Mapping Entries</title>

          <simplelist type="horiz" columns="2">
            <member>
<programlisting><hl1>? explicit key # Empty value&darr;</hl1><hl3>&deg;</hl3><sbr/>
<hl1>? |
  block key&darr;</hl1>
<hl2>:&middot;- one # Explicit compact
&middot;&middot;- two # block value&darr;</hl2>
</programlisting>
<synopsis>Legend:
  <hl1><link linkend="c-l-block-map-explicit-key(n)">c-l-block-map-explicit-key(n)</link></hl1>
  <hl2><link linkend="l-block-map-explicit-value(n)">l-block-map-explicit-value(n)</link></hl2>
  <hl3><link linkend="e-node">e-node</link></hl3>
</synopsis>
            </member>
            <member>
<programlisting>%YAML 1.2<sbr/>
---
!!map {
  ? !!str "explicit key"
  : !!str "",
  ? !!str "block key\n"
  : !!seq [
    !!str "one",
    !!str "two",
  ],
}
</programlisting>
            </member>
          </simplelist>
        </example>

        <para>
          If the <uquote>?</uquote> indicator is omitted, <refterm
          primary="parse">parsing</refterm> needs to see past the <refterm
          primary="key" secondary="implicit">implicit key</refterm>, in the
          same way as in the <refterm primary="style" secondary="single
          key:value pair mapping">single key:&nbsp;value pair</refterm>
          <refterm primary="style" secondary="flow" tertiary="mapping">flow
          mapping</refterm>. Hence, such <refterm primary="key">keys</refterm>
          are subject to the same restrictions; they are limited to a single
          line and must not span more than 1024 Unicode characters.
        </para>

        <productionset>
          <production id="ns-l-block-map-implicit-entry(n)">
            <lhs>ns-l-block-map-implicit-entry(n)</lhs>
            <rhs>
              ( <nonterminal def="#ns-s-block-map-implicit-key"/><sbr/>
              | <nonterminal def="#e-node"/> )<sbr/>
              <nonterminal def="#c-l-block-map-implicit-value(n)"/>
            </rhs>
          </production>

          <production id="ns-s-block-map-implicit-key">
            <lhs>ns-s-block-map-implicit-key</lhs>
            <rhs>
              &nbsp;&nbsp;<nonterminal def="#c-s-implicit-json-key(c)"
                >c-s-implicit-json-key(block-key)</nonterminal><sbr/>
              | <nonterminal def="#ns-s-implicit-yaml-key(c)"
                >ns-s-implicit-yaml-key(block-key)</nonterminal>
            </rhs>
          </production>
        </productionset>

        <para>
          In this case, the <refterm primary="value">value</refterm> may be
          specified on the same line as the <refterm primary="key"
          secondary="implicit">implicit key</refterm>. Note however that in
          block mappings the <refterm primary="value">value</refterm> must
          never be adjacent to the <uquote>:</uquote>, as this greatly reduces
          readability and is not required for <refterm primary="JSON
          compatibility">JSON compatibility</refterm> (unlike the case in
          <refterm primary="style" secondary="flow" tertiary="mapping">flow
          mappings</refterm>).
        </para>

        <para>
          There is no compact notation for in-line <refterm
          primary="value">values</refterm>. Also, while both the <refterm
          primary="key" secondary="implicit">implicit key</refterm> and the
          <refterm primary="value">value</refterm> following it may be empty,
          the <refterm primary=": mapping value"><uquote>:</uquote></refterm>
          indicator is mandatory. This prevents a potential ambiguity with
          multi-line <refterm primary="style" secondary="flow"
          tertiary="plain">plain scalars</refterm>.
        </para>

        <productionset>
          <production id="c-l-block-map-implicit-value(n)">
            <lhs>c-l-block-map-implicit-value(n)</lhs>
            <rhs>
              <nonterminal
                def="#c-mapping-value"><quote>:</quote></nonterminal>
              ( <nonterminal def="#s-l+block-node(n,c)"
                >s-l+block-node(n,block-out)</nonterminal><sbr/>
              &nbsp;&nbsp;&nbsp;&nbsp;| ( <nonterminal def="#e-node"/>
                <nonterminal def="#s-l-comments"/> ) )
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Implicit Block Mapping Entries</title>

          <simplelist type="horiz" columns="2">
            <member>
<programlisting><hl1>plain key</hl1><hl2>: in-line value</hl2><sbr/>
<hl1>&deg;</hl1><hl2>:&deg; # Both empty</hl2>
<hl1>"quoted key"</hl1><hl2>:
- entry</hl2>
</programlisting>
<synopsis>Legend:
  <hl1><link linkend="ns-s-block-map-implicit-key">ns-s-block-map-implicit-key</link></hl1>
  <hl2><link linkend="c-l-block-map-implicit-value(n)">c-l-block-map-implicit-value(n)</link></hl2>
</synopsis>
            </member>
            <member>
<programlisting>%YAML 1.2<sbr/>
---
!!map {
  ? !!str "plain key"
  : !!str "in-line value",
  ? !!null ""
  : !!null "",
  ? !!str "quoted key"
  : !!seq [ !!str "entry" ],
}
</programlisting>
            </member>
          </simplelist>
        </example>

        <para>
          A <refterm primary="style" secondary="compact block
          collection">compact in-line notation</refterm> is also available.
          This compact notation may be nested inside <refterm primary="style"
          secondary="block" tertiary="sequence">block sequences</refterm> and
          explicit block mapping entries. Note that it is not possible to
          specify <refterm primary="node" secondary="property">node
          properties</refterm> for such a nested mapping.
        </para>

        <productionset>
          <production id="ns-l-compact-mapping(n)">
            <lhs>ns-l-compact-mapping(n)</lhs>
            <rhs>
              <nonterminal def="#ns-l-block-map-entry(n)"/><sbr/>
              ( <nonterminal def="#s-indent(n)"/>
              <nonterminal def="#ns-l-block-map-entry(n)"/> )*
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Compact Block Mappings</title>

          <simplelist type="horiz" columns="2">
            <member>
<programlisting>- <hl1>sun: yellow&darr;</hl1><sbr/>
- <HL><hl1>? <hl1>earth: blue&darr;</hl1>
  : <hl1>moon: white&darr;</hl1></hl1></HL>
</programlisting>
<synopsis>Legend:
  <hl1><link linkend="ns-l-compact-mapping(n)">ns-l-compact-mapping(n)</link></hl1>
</synopsis>
            </member>
            <member>
<programlisting>%YAML 1.2<sbr/>
---
!!seq [
  !!map {
     !!str "sun" : !!str "yellow",
  },
  !!map {
    ? !!map {
      ? !!str "earth"
      : !!str "blue"
    },
    : !!map {
      ? !!str "moon"
      : !!str "white"
    },
  }
]
</programlisting>
            </member>
          </simplelist>
        </example>
      </sect2>

      <pagebreak/>

      <sect2>
        <title>Block Nodes</title>

        <para>
          YAML allows <refterm primary="style" secondary="flow">flow
          nodes</refterm> to be embedded inside <refterm primary="style"
          secondary="block" tertiary="collection">block collections</refterm>
          (but not vice-versa). <refterm primary="style" secondary="flow">Flow
          nodes</refterm> must be <refterm primary="space"
          secondary="indentation">indented</refterm> by at least one more
          <refterm primary="space">space</refterm> than the parent <refterm
          primary="style" secondary="block" tertiary="collection">block
          collection</refterm>. Note that <refterm primary="style"
          secondary="flow">flow nodes</refterm> may begin on a following line.
        </para>

        <para>
          It is at this point that <refterm primary="parse">parsing</refterm>
          needs to distinguish between a <refterm primary="style"
          secondary="flow" tertiary="plain">plain scalar</refterm> and an
          <refterm primary="key" secondary="implicit">implicit key</refterm>
          starting a nested <refterm primary="style" secondary="block"
          tertiary="mapping">block mapping</refterm>.
        </para>

        <productionset>
          <production id="s-l+block-node(n,c)">
            <lhs>s-l+block-node(n,c)</lhs>
            <rhs>
              <nonterminal def="#s-l+block-in-block(n,c)"/>
              | <nonterminal def="#s-l+flow-in-block(n)"/>
            </rhs>
          </production>

          <production id="s-l+flow-in-block(n)">
            <lhs>s-l+flow-in-block(n)</lhs>
            <rhs>
              <nonterminal def="#s-separate(n,c)"
                >s-separate(n+1,flow-out)</nonterminal><sbr/>
              <nonterminal def="#ns-flow-node(n,c)"
                >ns-flow-node(n+1,flow-out)</nonterminal>
              <nonterminal def="#s-l-comments"/>
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Block Node Types</title>

          <simplelist type="horiz" columns="2">
            <member>
<programlisting>-<hl1>&darr;<sbr/>
&middot;&middot;"flow in block"&darr;</hl1>
-&middot;<hl2>&gt;
 Block scalar&darr;</hl2>
-&middot;<hl2>!!map # Block collection
  foo : bar&darr;</hl2>
</programlisting>
<synopsis>Legend:
  <hl1><link linkend="s-l+flow-in-block(n)">s-l+flow-in-block(n)</link></hl1>
  <hl2><link linkend="s-l+block-in-block(n,c)">s-l+block-in-block(n,c)</link></hl2>
</synopsis>
            </member>
            <member>
<programlisting>%YAML 1.2<sbr/>
---
!!seq [
  !!str "flow in block",
  !!str "Block scalar\n",
  !!map {
    ? !!str "foo"
    : !!str "bar",
  },
]
</programlisting>
            </member>
          </simplelist>
        </example>

        <para>
          The block <refterm primary="node" secondary="property">node<q/>s
          properties</refterm> may span across several lines. In this case,
          they must be <refterm primary="space"
          secondary="indentation">indented</refterm> by at least one more
          <refterm primary="space">space</refterm> than the <refterm
          primary="style" secondary="block" tertiary="collection">block
          collection</refterm>, regardless of the <refterm primary="space"
          secondary="indentation">indentation</refterm> of the <refterm
          primary="style" secondary="block" tertiary="collection">block
          collection</refterm> entries.
        </para>

        <productionset>
          <production id="s-l+block-in-block(n,c)">
            <lhs>s-l+block-in-block(n,c)</lhs>
            <rhs>
              <nonterminal def="#s-l+block-scalar(n,c)"/>
              | <nonterminal def="#s-l+block-collection(n,c)"/>
            </rhs>
          </production>

          <production id="s-l+block-scalar(n,c)">
            <lhs>s-l+block-scalar(n,c)</lhs>
            <rhs>
              <nonterminal
                def="#s-separate(n,c)">s-separate(n+1,c)</nonterminal><sbr/>
              ( <nonterminal def="#c-ns-properties(n,c)"
                  >c-ns-properties(n+1,c)</nonterminal>
              <nonterminal def="#s-separate(n,c)"
                  >s-separate(n+1,c)</nonterminal> )?<sbr/>
              ( <nonterminal def="#c-l+literal(n)"/>
              | <nonterminal def="#c-l+folded(n)"/> )
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Block Scalar Nodes</title>

          <simplelist type="horiz" columns="2">
            <member>
<programlisting>literal: <hl1>|2<sbr/>
&middot;&middot;value</hl1>
folded:<hl2>&darr;
&middot;&middot;&middot;!foo
&middot;&middot;>1
&middot;value</hl2>
</programlisting>
<synopsis>Legend:
  <hl1><link linkend="c-l+literal(n)">c-l+literal(n)</link></hl1> <hl2><link linkend="c-l+folded(n)">c-l+folded(n)</link></hl2>
</synopsis>
            </member>
            <member>
<programlisting>%YAML 1.2<sbr/>
---
!!map {
  ? !!str "literal"
  : !!str "value\n",
  ? !!str "folded"
  : !&lt;!foo&gt; "value\n",
}
</programlisting>
            </member>
          </simplelist>
        </example>

        <pagebreak/>

        <para>
          Since people perceive the <refterm primary="- block sequence
          entry"><uquote>-</uquote> indicator</refterm> as <refterm
          primary="space" secondary="indentation">indentation</refterm>, nested
          <refterm primary="style" secondary="block" tertiary="sequence">block
          sequences</refterm> may be <refterm primary="space"
          secondary="indentation">indented</refterm> by one less <refterm
          primary="space">space</refterm> to compensate, except, of course, if
          nested inside another <refterm primary="style" secondary="block"
          tertiary="sequence">block sequence</refterm> (<refterm
          primary="context"
          secondary="block-out"><userinput>block-out</userinput>
          context</refterm> vs. <refterm primary="context"
          secondary="block-in"><userinput>block-in</userinput>
          context</refterm>).
        </para>

        <productionset>
          <production id="s-l+block-collection(n,c)">
            <lhs>s-l+block-collection(n,c)</lhs>
            <rhs>
              ( <nonterminal def="#s-separate(n,c)"
                  >s-separate(n+1,c)</nonterminal>
              <nonterminal def="#c-ns-properties(n,c)"
                  >c-ns-properties(n+1,c)</nonterminal> )?<sbr/>
              <nonterminal def="#s-l-comments"/><sbr/>
              ( <nonterminal def="#l+block-sequence(n)"
                  >l+block-sequence(</nonterminal><nonterminal
                    def="#seq-spaces(n,c)"
                    >seq-spaces(n,c)</nonterminal><nonterminal
                    def="#l+block-sequence(n)">)</nonterminal><sbr/>
              | <nonterminal def="#l+block-mapping(n)"/> )
            </rhs>
          </production>

          <production id="seq-spaces(n,c)">
            <lhs>seq-spaces(n,c)</lhs>
            <rhs>
              <varname>c</varname> = block-out &rArr; n-1<sbr/>
              <varname>c</varname> = block-in&nbsp; &rArr; n
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Block Collection Nodes</title>

          <simplelist type="horiz" columns="2">
            <member>
<programlisting>sequence:<HL><hl3> !!seq<sbr/>
<hl1>- entry
- !!seq
 - nested</hl1></hl3></HL>
mapping:<HL><hl3> !!map
<hl2> foo: bar</hl2></hl3></HL>
</programlisting>
<synopsis>Legend:
  <hl1><link linkend="l+block-sequence(n)">l+block-sequence(n)</link></hl1>
  <hl2><link linkend="l+block-mapping(n)">l+block-mapping(n)</link></hl2>
  <hl3><link linkend="s-l+block-collection(n,c)">s-l+block-collection(n,c)</link></hl3>
</synopsis>
            </member>
            <member>
<programlisting>%YAML 1.2<sbr/>
---
!!map {
  ? !!str "sequence"
  : !!seq [
    !!str "entry",
    !!seq [ !!str "nested" ],
  ],
  ? !!str "mapping"
  : !!map {
    ? !!str "foo" : !!str "bar",
  },
}
</programlisting>
            </member>
          </simplelist>
        </example>
      </sect2>
    </sect1>
  </chapter>

  <chapter id="YAML">
    <title>YAML Character Stream</title>

    <sect1>
      <title>Documents</title>

      <para>
        A YAML character <refterm primary="stream">stream</refterm> may contain
        several <defterm primary="document">documents</defterm>. Each document
        is completely independent from the rest.
      </para>

      <sect2>
        <title>Document Prefix</title>

        <para>
          A document may be preceded by a <defterm primary="document"
          secondary="prefix">prefix</defterm> specifying the <refterm
          primary="character encoding">character encoding</refterm>, and
          optional <refterm primary="comment">comment</refterm> lines. Note
          that all <refterm primary="document">documents</refterm> in a stream
          must use the same <refterm primary="character encoding">character
          encoding</refterm>. However it is valid to re-specify the <refterm
          primary="character encoding">encoding</refterm> using a <refterm
          primary="byte order mark">byte order mark</refterm> for each <refterm
          primary="document">document</refterm> in the stream. This makes it
          easier to concatenate streams.
        </para>

        <para>
          The existence of the optional prefix does not necessarily indicate
          the existence of an actual <refterm
          primary="document">document</refterm>.
        </para>

        <productionset>
          <production id="l-document-prefix">
            <lhs>l-document-prefix</lhs>
            <rhs>
              <nonterminal def="#c-byte-order-mark"/>?
              <nonterminal def="#l-comment"/>*
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Document Prefix</title>

          <simplelist type="horiz" columns="2">
            <member>
<programlisting><hl1>&hArr;# Comment<sbr/>
# lines</hl1>
Document
</programlisting>
<synopsis>Legend:
  <hl1><link linkend="l-document-prefix">l-document-prefix</link></hl1>
</synopsis>
            </member>
            <member>
<programlisting>%YAML 1.2<sbr/>
---
!!str "Document"
</programlisting>
            </member>
          </simplelist>
        </example>
      </sect2>

      <sect2>
        <title>Document Markers</title>

        <para>
          Using <refterm primary="directive">directives</refterm> creates a
          potential ambiguity. It is valid to have a <refterm primary="%
          directive"><uquote>%</uquote></refterm> character at the start of a
          line (e.g. as the first character of the second line of a <refterm
          primary="style" secondary="flow" tertiary="plain">plain
          scalar</refterm>). How, then, to distinguish between an actual
          <refterm primary="directive">directive</refterm> and a <refterm
          primary="content">content</refterm> line that happens to start with a
          <refterm primary="% directive"><uquote>%</uquote></refterm>
          character?
        </para>

        <para>
          The solution is the use of two special <defterm
          primary="marker">marker</defterm> lines to control the processing of
          <refterm primary="directive">directives</refterm>, one at the start
          of a <refterm primary="document">document</refterm> and one at the
          end.
        </para>

        <para>
          At the start of a <refterm primary="document">document</refterm>,
          lines beginning with a <refterm primary="%
          directive"><uquote>%</uquote></refterm> character are assumed to be
          <refterm primary="directive">directives</refterm>. The (possibly
          empty) list of <refterm primary="directive">directives</refterm> is
          terminated by a <defterm primary="marker" secondary="directives
          end">directives end marker</defterm> line. Lines following this
          marker can safely use <refterm primary="%
          directive"><uquote>%</uquote></refterm> as the first character.
        </para>

        <para>
          At the end of a <refterm primary="document">document</refterm>, a
          <defterm primary="marker" secondary="document end">document end
          marker</defterm> line is used to signal the <refterm
          primary="parse">parser</refterm> to begin scanning for <refterm
          primary="directive">directives</refterm> again.
        </para>

        <para>
          The existence of this optional <defterm primary="document"
          secondary="suffix">document suffix</defterm> does not necessarily
          indicate the existence of an actual following <refterm
          primary="document">document</refterm>.
        </para>

        <para>
          Obviously, the actual <refterm primary="content">content</refterm>
          lines are therefore forbidden to begin with either of these markers.
        </para>

        <productionset>
          <production id="c-directives-end">
            <lhs>c-directives-end</lhs>
            <rhs>
              <quote>-</quote> <quote>-</quote> <quote>-</quote>
            </rhs>
          </production>

          <production id="c-document-end">
            <lhs>c-document-end</lhs>
            <rhs>
              <quote>.</quote> <quote>.</quote> <quote>.</quote>
            </rhs>
          </production>

          <production id="l-document-suffix">
            <lhs>l-document-suffix</lhs>
            <rhs>
              <nonterminal def="#c-document-end"/>
              <nonterminal def="#s-l-comments"/>
            </rhs>
          </production>

          <production id="c-forbidden">
            <lhs>c-forbidden</lhs>
            <rhs>
              /* Start of line */<sbr/>
              ( <nonterminal def="#c-directives-end"/>
              | <nonterminal def="#c-document-end"/> )<sbr/>
              ( <nonterminal def="#b-char"/>
              | <nonterminal def="#s-white"/>
              | /* End of file */ )
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Document Markers</title>

          <simplelist type="horiz" columns="2">
            <member>
<programlisting>
%YAML 1.2
<hl1>---</hl1>
Document
<HL><hl3><hl2>...</hl2> # Suffix</hl3></HL>
</programlisting>
            </member>
            <member>
<programlisting>%YAML 1.2<sbr/>
---
!!str "Document"
</programlisting>
<synopsis>Legend:
  <hl1><link linkend="c-directives-end">c-directives-end</link></hl1> <hl2><link linkend="c-document-end">c-document-end</link></hl2>
  <hl3><link linkend="l-document-suffix">l-document-suffix</link></hl3>
</synopsis>
            </member>
          </simplelist>
        </example>
      </sect2>

      <sect2>
        <title>Bare Documents</title>

        <para>
          A <defterm primary="document" secondary="bare">bare
          document</defterm> does not begin with any <refterm
          primary="directive">directives</refterm> or <refterm
          primary="marker">marker</refterm> lines. Such documents are very
          <quote>clean</quote> as they contain nothing other than the <refterm
          primary="content">content</refterm>. In this case, the first
          non-comment line may not start with a <refterm primary="%
          directive"><uquote>%</uquote></refterm> first character.
        </para>

        <para>
          Document <refterm primary="node">nodes</refterm> are <refterm
          primary="space" secondary="indentation">indented</refterm> as if they
          have a parent <refterm primary="space"
          secondary="indentation">indented</refterm> at -1 <refterm
          primary="space">spaces</refterm>. Since a <refterm
          primary="node">node</refterm> must be more <refterm primary="space"
          secondary="indentation">indented</refterm> than its parent <refterm
          primary="node">node</refterm>, this allows the document<q/>s <refterm
          primary="node">node</refterm> to be <refterm primary="space"
          secondary="indentation">indented</refterm> at zero or more <refterm
          primary="space">spaces</refterm>.
        </para>

        <productionset>
          <production id="l-bare-document">
            <lhs>l-bare-document</lhs>
            <rhs>
              <nonterminal def="#s-l+block-node(n,c)"
                >s-l+block-node(-1,block-in)</nonterminal><sbr/>
              /* Excluding <nonterminal def="#c-forbidden"/> content */
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Bare Documents</title>

          <simplelist type="horiz" columns="2">
            <member>
<programlisting><hl1>Bare<sbr/>
document</hl1>
...
# No document
...
<hl1>|
%!PS-Adobe-2.0 # Not the first line</hl1>
</programlisting>
            </member>
            <member>
<programlisting>%YAML 1.2<sbr/>
---
!!str "Bare document"
...
%YAML 1.2
---
!!str "%!PS-Adobe-2.0 # Not the first line\n"
</programlisting>
<synopsis>&nbsp;Legend:
   <hl1><link linkend="l-bare-document">l-bare-document</link></hl1>
</synopsis>
            </member>
          </simplelist>
        </example>
      </sect2>

      <sect2>
        <title>Explicit Documents</title>

        <para>
          An <defterm primary="document" secondary="explicit">explicit
          document</defterm> begins with an explicit <refterm primary="marker"
          secondary="directives end">directives end marker</refterm> line but
          no <refterm primary="directive">directives</refterm>. Since the
          existence of the <refterm primary="document">document</refterm> is
          indicated by this <refterm primary="marker">marker</refterm>, the
          <refterm primary="document">document</refterm> itself may be <refterm
          primary="node" secondary="completely empty">completely
          empty</refterm>.
        </para>

        <productionset>
          <production id="l-explicit-document">
            <lhs>l-explicit-document</lhs>
            <rhs>
              <nonterminal def="#c-directives-end"/><sbr/>
              ( <nonterminal def="#l-bare-document"/><sbr/>
              | ( <nonterminal def="#e-node"/>
                <nonterminal def="#s-l-comments"/> ) )
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Explicit Documents</title>

          <simplelist type="horiz" columns="2">
            <member>
<programlisting><hl1>---<sbr/>
{ matches
% : 20 }</hl1>
...
<hl1>---
# Empty</hl1>
...
</programlisting>
<synopsis>&nbsp;Legend:
   <hl1><link linkend="l-explicit-document">l-explicit-document</link></hl1>
</synopsis>
            </member>
            <member>
<programlisting>%YAML 1.2<sbr/>
---
!!map {
  !!str "matches %": !!int "20"
}
...
%YAML 1.2
---
!!null ""
</programlisting>
            </member>
          </simplelist>
        </example>
      </sect2>

      <sect2>
        <title>Directives Documents</title>

        <para>
          A <defterm primary="document" secondary="directives">directives
          document</defterm> begins with some <refterm
          primary="directive">directives</refterm> followed by an explicit
          <refterm primary="marker" secondary="directives end">directives end
          marker</refterm> line.
        </para>

        <productionset>
          <production id="l-directive-document">
            <lhs>l-directive-document</lhs>
            <rhs>
              <nonterminal def="#l-directive"/>+<sbr/>
              <nonterminal def="#l-explicit-document"/>
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Directives Documents</title>

          <simplelist type="horiz" columns="2">
            <member>
<programlisting><hl1>%YAML 1.2<sbr/>
--- |
%!PS-Adobe-2.0</hl1>
...
<hl1>%YAML1.2
---
# Empty</hl1>
...
</programlisting>
<synopsis>&nbsp;Legend:
   <hl1><link linkend="l-explicit-document">l-explicit-document</link></hl1>
</synopsis>
            </member>
            <member>
<programlisting>%YAML 1.2<sbr/>
---
!!str "%!PS-Adobe-2.0\n"
...
%YAML 1.2
---
!!null ""
</programlisting>
            </member>
          </simplelist>
        </example>
      </sect2>
    </sect1>

    <sect1>
      <title>Streams</title>

      <para>
        A YAML <defterm primary="stream">stream</defterm> consists of zero or
        more <refterm primary="document">documents</refterm>. Subsequent
        <refterm primary="document">documents</refterm> require some sort of
        separation <refterm primary="marker">marker</refterm> line. If a
        <refterm primary="document">document</refterm> is not terminated by a
        <refterm primary="marker" secondary="document end">document end
        marker</refterm> line, then the following <refterm
        primary="document">document</refterm> must begin with a <refterm
        primary="marker" secondary="directives end">directives end
        marker</refterm> line.
      </para>

      <para>
        The stream format is intentionally <quote>sloppy</quote> to better
        support common use cases, such as stream concatenation.
      </para>

      <productionset>
        <production id="l-any-document">
          <lhs>l-any-document</lhs>
          <rhs>
            &nbsp;&nbsp;<nonterminal def="#l-directive-document"/><sbr/>
            | <nonterminal def="#l-explicit-document"/><sbr/>
            | <nonterminal def="#l-bare-document"/>
          </rhs>
        </production>

        <production id="l-yaml-stream">
          <lhs>l-yaml-stream</lhs>
          <rhs>
            <nonterminal def="#l-document-prefix"/>*
            <nonterminal def="#l-any-document"/>?<sbr/>
            ( <nonterminal def="#l-document-suffix"/>+
            <nonterminal def="#l-document-prefix"/>*
            <nonterminal def="#l-any-document"/>?<sbr/>
            | <nonterminal def="#l-document-prefix"/>*
            <nonterminal def="#l-explicit-document"/>? )*
          </rhs>
        </production>
      </productionset>

      <example>
        <title>Stream</title>

        <simplelist type="horiz" columns="2">
          <member>
<programlisting><hl1>Document</hl1><sbr/>
<hl1>---
# Empty</hl1>
...
<hl3>%YAML 1.2
---
matches %: 20</hl3>
</programlisting>
<synopsis>&nbsp;Legend:
   <hl1><link linkend="l-any-document">l-any-document</link></hl1>
   <hl2><link linkend="l-document-suffix">l-document-suffix</link></hl2>
   <hl3><link linkend="l-explicit-document">l-explicit-document</link></hl3>
</synopsis>
            </member>
            <member>
<programlisting>%YAML 1.2<sbr/>
---
!!str "Document"
...
%YAML 1.2
---
!!null ""
...
%YAML 1.2
---
!!map {
  !!str "matches %": !!int "20"
}
</programlisting>
            </member>
          </simplelist>
        </example>

      <para>
        A sequence of bytes is a <defterm primary="stream"
        secondary="well-formed">well-formed stream</defterm> if, taken as a
        whole, it complies with the above <userinput>l-yaml-stream</userinput>
        production.
      </para>

      <para>
        Some common use case that can take advantage of the YAML stream
        structure are:
      </para>

      <variablelist>
        <varlistentry>
          <term>Appending to Streams</term>

          <listitem>
            Allowing multiple <refterm primary="document">documents</refterm>
            in a single stream makes YAML suitable for log files and similar
            <refterm primary="application">applications</refterm>. Note that
            each <refterm primary="document">document</refterm> is independent
            of the rest, allowing for heterogeneous log file entries.
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Concatenating Streams</term>

          <listitem>
            <para>
              Concatenating two YAML streams requires both to use the same
              <refterm primary="character encoding">character
              encoding</refterm>. In addition, it is necessary to separate the
              last <refterm primary="document">document</refterm> of the first
              stream and the first <refterm
              primary="document">document</refterm> of the second stream. This
              is easily ensured by inserting a <refterm primary="marker"
              secondary="document end">document end marker</refterm> between
              the two streams. Note that this is safe regardless of the content
              of either stream. In particular, either or both may be empty, and
              the first stream may or may not already contain such a marker.
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Communication Streams</term>

          <listitem>
            <para>
              The <refterm primary="marker" secondary="document end">document
              end marker</refterm> allows signaling the end of a <refterm
              primary="document">document</refterm> without closing the stream
              or starting the next <refterm
              primary="document">document</refterm>. This allows the receiver
              to complete processing a <refterm
              primary="document">document</refterm> without having to wait for
              the next one to arrive. The sender may also transmit "keep-alive"
              messages in the form of <refterm
              primary="comment">comment</refterm> lines or repeated <refterm
              primary="marker" secondary="document end">document end
              markers</refterm> without signalling the start of the next
              <refterm primary="document">document</refterm>.
            </para>
          </listitem>
        </varlistentry>
      </variablelist>
    </sect1>
  </chapter>

  <chapter id="Schema">
    <title>Recommended Schemas</title>

    <para>
      A YAML <defterm primary="schema">schema</defterm> is a combination of a
      set of <refterm primary="tag">tags</refterm> and a mechanism for <refterm
      primary="tag" secondary="resolution">resolving</refterm> <refterm
      primary="tag" secondary="non-specific">non-specific tags</refterm>.
    </para>

    <sect1>
      <title>Failsafe Schema</title>

      <para>
        The <defterm primary="schema" secondary="failsafe">failsafe
        schema</defterm> is guaranteed to work with any YAML <refterm
        primary="document">document</refterm>. It is therefore the recommended
        <refterm primary="schema">schema</refterm> for generic YAML tools. A
        YAML <refterm primary="processor">processor</refterm> should therefore
        support this <refterm primary="schema">schema</refterm>, at least as an
        option.
      </para>

      <sect2>
        <title>Tags</title>

        <sect3>
          <title><defterm primary="tag" secondary="repository"
          tertiary="map"/>Generic Mapping</title>

          <variablelist>
            <varlistentry>
              <term>
                <para>
                  URI:
                </para>
              </term>

              <listitem>
                <para>
                  <userinput>tag:yaml.org,2002:map</userinput>
                </para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>
                <para>
                  Kind:
                </para>
              </term>

              <listitem>
                <para>
                  <refterm primary="mapping">Mapping</refterm>.
                </para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>
                <para>
                  Definition:
                </para>
              </term>

              <listitem>
                <para>
                  <refterm primary="represent">Represents</refterm> an
                  associative container, where each <refterm
                  primary="key">key</refterm> is <refterm
                  primary="equality">unique</refterm> in the association and
                  mapped to exactly one <refterm
                  primary="value">value</refterm>.  YAML places no restrictions
                  on the type of <refterm primary="key">keys</refterm>; in
                  particular, they are not restricted to being <refterm
                  primary="scalar">scalars</refterm>. Example <refterm
                  primary="construct">bindings</refterm> to <refterm
                  primary="native data structure">native</refterm> types
                  include Perl<q/>s hash, Python<q/>s dictionary, and Java<q/>s
                  Hashtable.
                </para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>
                <para>
                  Equality:
                </para>
              </term>

              <listitem>
                <para>
                  Two mappings are <refterm primary="equality">equal</refterm>
                  if and only if they are <refterm
                  primary="identity">identical</refterm>.
                </para>
              </listitem>
            </varlistentry>
          </variablelist>

          <example>
            <title><userinput>!!map</userinput> Examples</title>

            <simplelist type="horiz" columns="1">
              <member>
<programlisting>Block style: !!map<sbr/>
  Clark : Evans
  Ingy  : d&ouml;t Net
  Oren  : Ben-Kiki

Flow style: !!map { Clark: Evans, Ingy: d&ouml;t Net, Oren: Ben-Kiki }
</programlisting>
              </member>
            </simplelist>
          </example>
        </sect3>

        <sect3>
          <title><defterm primary="tag" secondary="repository"
          tertiary="seq"/>Generic Sequence</title>

          <variablelist>
            <varlistentry>
              <term>
                <para>
                  URI:
                </para>
              </term>

              <listitem>
                <para>
                  <userinput>tag:yaml.org,2002:seq</userinput>
                </para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>
                <para>
                  Kind:
                </para>
              </term>

              <listitem>
                <para>
                  <refterm primary="sequence">Sequence</refterm>.
                </para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>
                <para>
                  Definition:
                </para>
              </term>

              <listitem>
                <para>
                  <refterm primary="represent">Represents</refterm> a
                  collection indexed by sequential integers starting with zero.
                  Example <refterm primary="construct">bindings</refterm> to
                  <refterm primary="native data structure">native</refterm>
                  types include Perl<q/>s array, Python<q/>s list or tuple, and
                  Java<q/>s array or Vector.
                </para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>
                <para>
                  Equality:
                </para>
              </term>

              <listitem>
                <para>
                  Two sequences are <refterm primary="equality">equal</refterm>
                  if and only if they are <refterm
                  primary="identity">identical</refterm>.
                </para>
              </listitem>
            </varlistentry>
          </variablelist>

          <example>
            <title><userinput>!!seq</userinput> Examples</title>

            <simplelist type="horiz" columns="1">
              <member>
<programlisting>Block style: !!seq<sbr/>
- Clark Evans
- Ingy d&ouml;t Net
- Oren Ben-Kiki

Flow style: !!seq [ Clark Evans, Ingy d&ouml;t Net, Oren Ben-Kiki ]
</programlisting>
              </member>
            </simplelist>
          </example>
        </sect3>

        <pagebreak/>

        <sect3>
          <title><defterm primary="tag" secondary="repository"
          tertiary="str"/>Generic String</title>

          <variablelist>
            <varlistentry>
              <term>
                <para>
                  URI:
                </para>
              </term>

              <listitem>
                <para>
                  <userinput>tag:yaml.org,2002:str</userinput>
                </para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>
                <para>
                  Kind:
                </para>
              </term>

              <listitem>
                <para>
                  <refterm primary="scalar">Scalar</refterm>.
                </para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>
                <para>
                  Definition:
                </para>
              </term>

              <listitem>
                <para>
                  <refterm primary="represent">Represents</refterm> a Unicode
                  string, a sequence of zero or more Unicode characters. This
                  type is usually <refterm primary="construct">bound</refterm>
                  to the <refterm primary="native data
                  structure">native</refterm> language<q/>s string type, or,
                  for languages lacking one (such as C), to a character array.
                </para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>
                <para>
                  Equality:
                </para>
              </term>

              <listitem>
                <para>
                  Two strings are <refterm primary="equality">equal</refterm>
                  if and only if they have the same length and contain the same
                  characters in the same order.
                </para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>
                <para>
                  Canonical Form:
                </para>
              </term>

              <listitem>
                <para>
                  The obvious.
                </para>
              </listitem>
            </varlistentry>
          </variablelist>

          <example>
            <title><userinput>!!str</userinput> Examples</title>

            <simplelist type="horiz" columns="1">
              <member>
<programlisting>String: !!str "Just a theory."
</programlisting>
              </member>
            </simplelist>
          </example>
        </sect3>
      </sect2>

      <sect2>
        <title>Tag Resolution</title>

        <para>
          All <refterm primary="node">nodes</refterm> with the <refterm
          primary="! tag indicator" secondary="! non-specific
          tag"><uquote>!</uquote> non-specific tag</refterm> are <refterm
          primary="tag" secondary="resolution">resolved</refterm>, by the
          standard <refterm primary="tag" secondary="resolution"
          tertiary="convention">convention</refterm>, to
          <uquote>tag:yaml.org,2002:seq</uquote>,
          <uquote>tag:yaml.org,2002:map</uquote>, or
          <uquote>tag:yaml.org,2002:str</uquote>, according to their <refterm
          primary="kind">kind</refterm>.
        </para>

        <para>
          All <refterm primary="node">nodes</refterm> with the <refterm
          primary="? non-specific tag"><uquote>?</uquote> non-specific
          tag</refterm> are left <refterm primary="tag"
          secondary="resolution">unresolved</refterm>. This constrains the
          <refterm primary="application">application</refterm> to deal with  a
          <refterm primary="representation" secondary="partial">partial
          representation</refterm>.
        </para>
      </sect2>
    </sect1>

    <sect1>
      <title>JSON Schema</title>

      <para>
        The <defterm primary="schema" secondary="JSON">JSON schema</defterm> is
        the lowest common denominator of most modern computer languages, and
        allows <refterm primary="parse">parsing</refterm> JSON files. A YAML
        <refterm primary="processor">processor</refterm> should therefore
        support this <refterm primary="schema">schema</refterm>, at least as an
        option. It is also strongly recommended that other <refterm
        primary="schema">schemas</refterm> should be based on it.
      </para>

      <sect2>
        <title>Tags</title>

        <para>
          The JSON <refterm primary="schema">schema</refterm> uses the
          following <refterm primary="tag">tags</refterm> in addition to those
          defined by the <refterm primary="schema"
          secondary="failsafe">failsafe</refterm> schema:
        </para>

        <sect3>
          <title><defterm primary="tag" secondary="repository"
          tertiary="null"/>Null</title>

          <variablelist>
            <varlistentry>
              <term>
                <para>
                  URI:
                </para>
              </term>

              <listitem>
                <para>
                  <userinput>tag:yaml.org,2002:null</userinput>
                </para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>
                <para>
                  Kind:
                </para>
              </term>

              <listitem>
                <para>
                  <refterm primary="scalar">Scalar</refterm>.
                </para> </listitem>
            </varlistentry>

            <varlistentry>
              <term>
                <para>
                  Definition:
                </para>
              </term>

              <listitem>
                <para>
                  <refterm primary="represent">Represents</refterm> the lack
                  of a value. This is typically <refterm
                  primary="construct">bound</refterm> to a <refterm
                  primary="native data structure">native</refterm> null-like
                  value (e.g., <userinput>undef</userinput> in Perl,
                  <userinput>None</userinput> in Python). Note that a null is
                  different from an empty string. Also, a <refterm
                  primary="mapping">mapping</refterm> entry with some
                  <refterm primary="key">key</refterm> and a null <refterm
                  primary="value">value</refterm> is valid, and different
                  from not having that <refterm primary="key">key</refterm>
                  in the <refterm primary="mapping">mapping</refterm>.
                </para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>
                <para>
                  Equality:
                </para>
              </term>

              <listitem>
                <para>
                  All <userinput>null</userinput> values are <refterm
                  primary="equality">equal</refterm>.
                </para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>
                <para>
                  Canonical Form:
                </para>
              </term>

              <listitem>
                <userinput>null</userinput>.
              </listitem>
            </varlistentry>
          </variablelist>

          <example>
            <title><userinput>!!null</userinput> Examples</title>
            <simplelist type="horiz" columns="1">
              <member>
<programlisting>!!null null: value for null key<sbr/>
key with null value: !!null null
</programlisting>
              </member>
            </simplelist>
          </example>
        </sect3>

        <sect3>
          <title><defterm primary="tag" secondary="repository"
          tertiary="bool"/>Boolean</title>

          <variablelist>
            <varlistentry>
              <term>
                <para>
                  URI:
                </para>
              </term>

              <listitem>
                <para>
                  <userinput>tag:yaml.org,2002:bool</userinput>
                </para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>
                <para>
                  Kind:
                </para>
              </term>

              <listitem>
                <para>
                  <refterm primary="scalar">Scalar</refterm>.
                </para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>
                <para>
                  Definition:
                </para>
              </term>

              <listitem>
                <para>
                  <refterm primary="represent">Represents</refterm> a
                  true/false value. In languages without a <refterm
                  primary="native data structure">native</refterm> Boolean type
                  (such as C), is usually <refterm
                  primary="construct">bound</refterm> to a native integer
                  type, using one for true and zero for false.
                </para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>
                <para>
                  Equality:
                </para>
              </term>

              <listitem>
                <para>
                  All <userinput>true</userinput> values are <refterm
                  primary="equality">equal</refterm>. Similarly, all
                  <userinput>false</userinput> values are <refterm
                  primary="equality">equal</refterm>.
                </para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>
                <para>
                  Canonical Form:
                </para>
              </term>

              <listitem>
                Either <userinput>true</userinput> or
                <userinput>false</userinput>.
              </listitem>
            </varlistentry>
          </variablelist>

          <example>
            <title><userinput>!!bool</userinput> Examples</title>

            <simplelist type="horiz" columns="1">
              <member>
<programlisting>YAML is a superset of JSON: !!bool true<sbr/>
Pluto is a planet: !!bool false
</programlisting>
              </member>
            </simplelist>
          </example>
        </sect3>

        <sect3>
          <title><defterm primary="tag" secondary="repository"
          tertiary="int"/>Integer</title>

          <variablelist>
            <varlistentry>
              <term>
                <para>
                  URI:
                </para>
              </term>

              <listitem>
                <para>
                  <userinput>tag:yaml.org,2002:int</userinput>
                </para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>
                <para>
                  Kind:
                </para>
              </term>

              <listitem>
                <para>
                  <refterm primary="scalar">Scalar</refterm>.
                </para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>
                <para>
                  Definition:
                </para>
              </term>

              <listitem>
                <para>
                  <refterm primary="represent">Represents</refterm> arbitrary
                  sized finite mathematical integers. Scalars of this type
                  should be <refterm primary="construct">bound</refterm> to a
                  <refterm primary="native data structure">native</refterm>
                  integer data type, if possible.
                </para>

                <para>
                  Some languages (such as Perl) provide only a
                  <quote>number</quote> type that allows for both integer and
                  floating-point values. A YAML <refterm
                  primary="processor">processor</refterm> may use such a type
                  for integers, as long as they round-trip properly.
                </para>

                <para>
                  In some languages (such as C), an integer may overflow the
                  <refterm primary="native data structure">native</refterm>
                  type<q/>s storage capability. A YAML <refterm
                  primary="processor">processor</refterm> may reject such a
                  value as an error, truncate it with a warning, or find some
                  other manner to round-trip it. In general, integers
                  representable using 32 binary digits should safely round-trip
                  through most systems.
                </para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>
                <para>
                  Equality:
                </para>
              </term>

              <listitem>
                <para>
                  An integer value is <refterm
                  primary="equality">equal</refterm> to any other numeric
                  value that evaluates to the integer value. For example, the
                  integer <userinput>1</userinput> is equal to the
                  floating-point <userinput>1.0</userinput>.
                </para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>
                <para>
                  Canonical Form:
                </para>
              </term>

              <listitem>
                Decimal integer notation, with a leading <uquote>-</uquote>
                character for negative values, matching the regular expression
                <userinput>0&nbsp;|&nbsp;-?&nbsp;[1-9]&nbsp;[0-9]*</userinput>
              </listitem>
            </varlistentry>
          </variablelist>

          <example>
            <title><userinput>!!int</userinput> Examples</title>

            <simplelist type="horiz" columns="1">
              <member>
<programlisting>negative: !!int -12<sbr/>
zero: !!int 0
positive: !!int 34
</programlisting>
              </member>
            </simplelist>
          </example>
        </sect3>

        <pagebreak/>

        <sect3>
          <title><defterm primary="tag" secondary="repository"
          tertiary="float"/>Floating Point</title>

          <variablelist>
            <varlistentry>
              <term>
                <para>
                  URI:
                </para>
              </term>

              <listitem>
                <para>
                  <userinput>tag:yaml.org,2002:float</userinput>
                </para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>
                <para>
                  Kind:
                </para>
              </term>

              <listitem>
                <para>
                  <refterm primary="scalar">Scalar</refterm>.
                </para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>
                <para>
                  Definition:
                </para>
              </term>

              <listitem>
                <para>
                  <refterm primary="represent">Represents</refterm> an
                  approximation to real numbers, including three special values
                  (positive and negative infinity, and <quote>not a
                  number</quote>).
                </para>

                <para>
                  Some languages (such as Perl) provide only a
                  <quote>number</quote> type that allows for both integer and
                  floating-point values. A YAML <refterm
                  primary="processor">processor</refterm> may use such a type
                  for floating-point numbers, as long as they round-trip
                  properly.
                </para>

                <para>
                  Not all floating-point values can be stored exactly in any
                  given <refterm primary="native data
                  structure">native</refterm> type. Hence a float value may
                  change by <quote>a small amount</quote> when round-tripped.
                  The supported range and accuracy depends on the
                  implementation, though 32 bit IEEE floats should be safe.
                  Since YAML does not specify a particular accuracy, using
                  floating-point <refterm primary="key">mapping keys</refterm>
                  requires great care and is not recommended.
                </para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>
                <para>
                  Equality:
                </para>
              </term>

              <listitem>
                <para>
                  A floating-point value is <refterm
                  primary="equality">equal</refterm> to any other numeric value
                  that evaluates to the floating-point value. For example,
                  floating-point <userinput>1.0</userinput> is <refterm
                  primary="equality">equal</refterm> to the the integer
                  <userinput>1</userinput>. Note that for the purpose of
                  <refterm primary="key">key</refterm> <refterm
                  primary="equality">uniqueness</refterm>, all
                  <userinput>.nan</userinput> values are considered to be
                  <refterm primary="equality">equal</refterm>. Note that in
                  some languages (such as Ruby and Python) <quote>not a
                  number</quote> has <refterm
                  primary="identity">identity</refterm> semantics and therefore
                  is not properly <refterm
                  primary="representation">represented</refterm> in YAML as
                  <userinput>!!float .nan</userinput>.
                </para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>
                <para>
                  Canonical Form:
                </para>
              </term>

              <listitem>
                Either <userinput>0</userinput>, <userinput>.inf</userinput>,
                <userinput>-.inf</userinput>, <userinput>.nan</userinput>, or
                scientific notation matching the regular expression
                <userinput>-?&nbsp;[1-9]&nbsp;(&nbsp;\.&nbsp;[0-9]*&nbsp;[1-9]&nbsp;)?&nbsp;(&nbsp;e&nbsp;[-+]&nbsp;[1-9]&nbsp;[0-9]*&nbsp;)?</userinput>.
              </listitem>
            </varlistentry>
          </variablelist>

          <example>
            <title><userinput>!!float</userinput> Examples</title>

            <simplelist type="horiz" columns="1">
              <member>
<programlisting>negative: !!float -1<sbr/>
zero: !!float 0
positive: !!float 2.3e4
infinity: !!float .inf
not a number: !!float .nan
</programlisting>
              </member>
            </simplelist>
          </example>
        </sect3>
      </sect2>

      <sect2>
        <title>Tag Resolution</title>

        <para>
          The <refterm primary="schema" secondary="JSON">JSON schema</refterm>
          <refterm primary="tag" secondary="resolution">tag
          resolution</refterm> is an extension of the <refterm primary="schema"
          secondary="failsafe">failsafe schema</refterm> <refterm
          primary="tag" secondary="resolution">tag resolution</refterm>.
        </para>

        <para>
          All <refterm primary="node">nodes</refterm> with the <refterm
          primary="! tag indicator" secondary="! non-specific
          tag"><uquote>!</uquote> non-specific tag</refterm> are <refterm
          primary="tag" secondary="resolution">resolved</refterm>, by the
          standard <refterm primary="tag" secondary="resolution"
          tertiary="convention">convention</refterm>, to
          <uquote>tag:yaml.org,2002:seq</uquote>,
          <uquote>tag:yaml.org,2002:map</uquote>, or
          <uquote>tag:yaml.org,2002:str</uquote>, according to their <refterm
          primary="kind">kind</refterm>.
        </para>

        <para>
          <refterm primary="collection">Collections</refterm> with the <refterm
          primary="? non-specific tag"><uquote>?</uquote> non-specific
          tag</refterm> (that is, <refterm primary="tag"
          secondary="non-specific">untagged</refterm> <refterm
          primary="collection">collections</refterm>) are <refterm
          primary="tag" secondary="resolution">resolved</refterm> to
          <uquote>tag:yaml.org,2002:seq</uquote> or
          <uquote>tag:yaml.org,2002:map</uquote> according to their <refterm
          primary="kind">kind</refterm>.
        </para>

        <para> <refterm primary="scalar">Scalars</refterm> with the <refterm
          primary="? non-specific tag"><uquote>?</uquote> non-specific
          tag</refterm> (that is, <refterm primary="style" secondary="flow"
          tertiary="plain">plain scalars</refterm>) are matched with a list of
          regular expressions (first match wins, e.g. <userinput>0</userinput>
          is resolved as <userinput>!!int</userinput>). In principle, JSON
          files should not contain any <refterm
          primary="scalar">scalars</refterm> that do not match at least one of
          these. Hence the YAML <refterm
          primary="processor">processor</refterm> should consider them to be an
          error.
        </para>

        <informaltable>
          <tgroup cols="2">
            <colspec width="70%"/>
            <colspec width="30%"/>
            <tbody>
              <row>
                <entry>&nbsp;<emphasis
                  >Regular&nbsp;expression&nbsp;</emphasis></entry>
                <entry>&nbsp;<emphasis
                  >&nbsp;Resolved&nbsp;to&nbsp;tag</emphasis></entry>
              </row>

              <row>
                <entry>&nbsp;<userinput>null</userinput></entry>
                <entry>&nbsp;<userinput
                  >tag:yaml.org,2002:null</userinput></entry>
              </row>

              <row>
                <entry>&nbsp;<userinput
                  >true&nbsp;|&nbsp;false</userinput></entry>
                <entry>&nbsp;<userinput
                  >tag:yaml.org,2002:bool</userinput></entry>
              </row>

              <row>
                <entry>&nbsp;<userinput>-?&nbsp;(&nbsp;0&nbsp;|&nbsp;[1-9]&nbsp;[0-9]*&nbsp;)</userinput></entry>
                <entry>&nbsp;<userinput
                  >tag:yaml.org,2002:int</userinput></entry>
              </row>

              <row>
                <entry>&nbsp;<userinput>-?&nbsp;(&nbsp;0&nbsp;|&nbsp;[1-9]&nbsp;[0-9]*&nbsp;)&nbsp;(&nbsp;\.&nbsp;[0-9]*&nbsp;)?&nbsp;(&nbsp;[eE]&nbsp;[-+]?&nbsp;[0-9]+&nbsp;)?</userinput></entry>
                <entry>&nbsp;<userinput
                  >tag:yaml.org,2002:float</userinput></entry>
              </row>

              <row>
                <entry>&nbsp;<userinput>*</userinput></entry>
                <entry>&nbsp;Error</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <example>
          <title>JSON Tag Resolution</title>

          <simplelist type="horiz" columns="2">
            <member>
<programlisting>A null: null<sbr/>
Booleans: [ true, false ]
Integers: [ 0, -0, 3, -19 ]
Floats: [ 0., -0.0, 12e03, -2E+05 ]
Invalid: [ True, Null, 0o7, 0x3A, +12.3 ]
</programlisting>
            </member>
            <member>
<programlisting>%YAML 1.2<sbr/>
---
!!map {
  !!str "A null" : !!null "null",
  !!str "Booleans: !!seq [
    !!bool "true", !!bool "false"
  ],
  !!str "Integers": !!seq [
    !!int "0", !!int "-0",
    !!int "3", !!int "-19"
  ],
  !!str "Floats": !!seq [
    !!float "0.", !!float "-0.0",
    !!float "12e03", !!float "-2E+05"
  ],
  !!str "Invalid": !!seq [
    # Rejected by the schema
    True, Null, 0o7, 0x3A, +12.3,
  ],
}
...
</programlisting>
            </member>
          </simplelist>
        </example>
      </sect2>
    </sect1>

    <pagebreak/>

    <sect1>
      <title>Core Schema</title>

      <para>
        The <defterm primary="schema" secondary="core">Core schema</defterm> is
        an extension of the <refterm primary="schema" secondary="JSON">JSON
        schema</refterm>, allowing for more human-readable <refterm
        primary="present">presentation</refterm> of the same types. This is the
        recommended default <refterm primary="schema">schema</refterm> that
        YAML <refterm primary="processor">processor</refterm> should use unless
        instructed otherwise. It is also strongly recommended that other
        <refterm primary="schema">schemas</refterm> should be based on it.
      </para>

      <sect2>
        <title>Tags</title>

        <para>
          The core <refterm primary="schema">schema</refterm> uses the same
          <refterm primary="tag">tags</refterm> as the <refterm
          primary="schema" secondary="JSON">JSON schema</refterm>.
        </para>
      </sect2>

      <sect2>
        <title>Tag Resolution</title>

        <para>
          The <refterm primary="schema" secondary="core">core schema</refterm>
          <refterm primary="tag" secondary="resolution">tag
          resolution</refterm> is an extension of the <refterm primary="schema"
          secondary="JSON">JSON schema</refterm> <refterm
          primary="tag" secondary="resolution">tag resolution</refterm>.
        </para>

        <para>
          All <refterm primary="node">nodes</refterm> with the <refterm
          primary="! tag indicator" secondary="! non-specific
          tag"><uquote>!</uquote> non-specific tag</refterm> are <refterm
          primary="tag" secondary="resolution">resolved</refterm>, by the
          standard <refterm primary="tag" secondary="resolution"
          tertiary="convention">convention</refterm>, to
          <uquote>tag:yaml.org,2002:seq</uquote>,
          <uquote>tag:yaml.org,2002:map</uquote>, or
          <uquote>tag:yaml.org,2002:str</uquote>, according to their <refterm
          primary="kind">kind</refterm>.
        </para>

        <para>
          <refterm primary="collection">Collections</refterm> with the <refterm
          primary="? non-specific tag"><uquote>?</uquote> non-specific
          tag</refterm> (that is, <refterm primary="tag"
          secondary="non-specific">untagged</refterm> <refterm
          primary="collection">collections</refterm>) are <refterm
          primary="tag" secondary="resolution">resolved</refterm> to
          <uquote>tag:yaml.org,2002:seq</uquote> or
          <uquote>tag:yaml.org,2002:map</uquote> according to their <refterm
          primary="kind">kind</refterm>.
        </para>

        <para>
          <refterm primary="scalar">Scalars</refterm> with the <refterm
          primary="? non-specific tag"><uquote>?</uquote> non-specific
          tag</refterm> (that is, <refterm primary="style" secondary="flow"
          tertiary="plain">plain scalars</refterm>) are matched with an
          extended list of regular expressions. However, in this case, if none
          of the regular expressions matches, the <refterm
          primary="scalar">scalar</refterm> is <refterm primary="tag"
          secondary="resolution">resolved</refterm> to
          <userinput>tag:yaml.org,2002:str</userinput> (that is, considered to
          be a string).
        </para>

        <informaltable>
          <tgroup cols="2">
            <colspec width="70%"/>
            <colspec width="30%"/>
            <tbody>
              <row>
                <entry>&nbsp;<emphasis
                  >Regular&nbsp;expression&nbsp;</emphasis></entry>
                <entry>&nbsp;<emphasis
                  >&nbsp;Resolved&nbsp;to&nbsp;tag</emphasis></entry>
              </row>

              <row>
                <entry>&nbsp;<userinput>null&nbsp;|&nbsp;Null&nbsp;|&nbsp;NULL&nbsp;|&nbsp;~</userinput></entry>
                <entry>&nbsp;<userinput
                  >tag:yaml.org,2002:null</userinput></entry>
              </row>

              <row>
                <entry>&nbsp;<userinput
                  >/*&nbsp;Empty&nbsp;*/</userinput></entry>
                <entry>&nbsp;<userinput
                  >tag:yaml.org,2002:null</userinput></entry>
              </row>

              <row>
                <entry>&nbsp;<userinput>true&nbsp;|&nbsp;True&nbsp;|&nbsp;TRUE&nbsp;|&nbsp;false&nbsp;|&nbsp;False&nbsp;|&nbsp;FALSE</userinput></entry>
                <entry>&nbsp;<userinput
                  >tag:yaml.org,2002:bool</userinput></entry>
              </row>

              <row>
                <entry>&nbsp;<userinput>[-+]?&nbsp;[0-9]+</userinput></entry>
                <entry>&nbsp;<userinput
                  >tag:yaml.org,2002:int</userinput>&nbsp;<emphasis
                  >(Base&nbsp;10)</emphasis></entry>
              </row>

              <row>
                <entry>&nbsp;<userinput>0o&nbsp;[0-7]+</userinput></entry>
                <entry>&nbsp;<userinput
                  >tag:yaml.org,2002:int</userinput>&nbsp;<emphasis
                  >(Base&nbsp;8)</emphasis></entry>
              </row>

              <row>
                <entry>&nbsp;<userinput>0x&nbsp;[0-9a-fA-F]+</userinput></entry>
                <entry>&nbsp;<userinput
                  >tag:yaml.org,2002:int</userinput>&nbsp;<emphasis
                  >(Base&nbsp;16)</emphasis></entry>
              </row>

              <row>
                <entry>&nbsp;<userinput>[-+]?&nbsp;(&nbsp;\.&nbsp;[0-9]+&nbsp;|&nbsp;[0-9]+&nbsp;(&nbsp;\.&nbsp;[0-9]*&nbsp;)?&nbsp;)&nbsp;(&nbsp;[eE]&nbsp;[-+]?&nbsp;[0-9]+&nbsp;)?</userinput></entry>
                <entry>&nbsp;<userinput
                  >tag:yaml.org,2002:float</userinput>&nbsp;<emphasis
                  >(Number)</emphasis></entry>
              </row>

              <row>
                <entry>&nbsp;<userinput>[-+]?&nbsp;(&nbsp;\.inf&nbsp;|&nbsp;\.Inf&nbsp;|&nbsp;\.INF&nbsp;)</userinput></entry>
                <entry>&nbsp;<userinput
                  >tag:yaml.org,2002:float</userinput
                  >&nbsp;<emphasis>(Infinity)</emphasis></entry>
              </row>

              <row>
                <entry>&nbsp;<userinput>\.nan&nbsp;|&nbsp;\.NaN&nbsp;|&nbsp;\.NAN</userinput></entry>
                <entry>&nbsp;<userinput
                  >tag:yaml.org,2002:float</userinput
                  >&nbsp;<emphasis>(Not&nbsp;a&nbsp;number)</emphasis></entry>
              </row>

              <row>
                <entry>&nbsp;<userinput>*</userinput></entry>
                <entry>&nbsp;<userinput
                  >tag:yaml.org,2002:str</userinput
                  >&nbsp;<emphasis>(Default)</emphasis></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <example>
          <title>Core Tag Resolution</title>

          <simplelist type="horiz" columns="2">
            <member>
<programlisting>A null: null<sbr/>
Also a null: # Empty
Not a null: ""
Booleans: [ true, false ]
Integers: [ 0, 0o7, 0x3A, -19 ]
Floats: [ 0., -0.0, .5, +12e03, -2E+05 ]
Also floats: [ .inf, -.Inf, +.INF, .NAN ]
</programlisting>
            </member>
            <member>
<programlisting>%YAML 1.2<sbr/>
---
!!map {
  !!str "A null" : !!null "null",
  !!str "Also a null" : !!null "",
  !!str "Not a null" : !!str "",
  !!str "Booleans: !!seq [
    !!bool "true", !!bool "false"
  ],
  !!str "Integers": !!seq [
    !!int "0", !!int "0o7",
    !!int "0x3A", !!int "-19",
  ],
  !!str "Floats": !!seq [
    !!float "0.", !!float "-0.0", !!float ".5",
    !!float "+12e03", !!float "-2E+05"
  ],
  !!str "Also floats": !!seq [
    !!float ".inf", !!float "-.Inf",
    !!float "+.INF", !!float ".NAN",
  ],
}
...
</programlisting>
            </member>
          </simplelist>
        </example>
      </sect2>
    </sect1>

    <sect1>
      <title>Other Schemas</title>

      <para>
        None of the above recommended <refterm
        primary="schema">schemas</refterm> preclude the use of arbitrary
        explicit <refterm primary="tag">tags</refterm>. Hence YAML <refterm
        primary="processor">processors</refterm> for a particular programming
        language typically provide some form of <refterm primary="tag"
        secondary="local">local tags</refterm> that map directly to the
        language<q/>s <refterm primary="native data structure">native data
        structures</refterm> (e.g., <userinput>!ruby/object:Set</userinput>).
      </para>

      <para>
        While such <refterm primary="tag" secondary="local">local
        tags</refterm> are useful for ad-hoc <refterm
        primary="application">applications</refterm>, they do not suffice for
        stable, interoperable cross-<refterm
        primary="application">application</refterm> or cross-platform data
        exchange.
      </para>

      <para>
        Interoperable <refterm primary="schema">schemas</refterm> make use of
        <refterm primary="tag" secondary="global">global tags</refterm> (URIs)
        that <refterm primary="represent">represent</refterm> the same data
        across different programming languages. In addition, an interoperable
        <refterm primary="schema">schema</refterm> may provide additional
        <refterm primary="tag" secondary="resolution">tag resolution</refterm>
        rules. Such rules may provide additional regular expressions, as well
        as consider the path to the <refterm primary="node">node</refterm>.
        This allows interoperable <refterm primary="schema">schemas</refterm>
        to use <refterm primary="tag"
        secondary="non-specific">untagged</refterm> <refterm
        primary="node">nodes</refterm>.
      </para>

      <para>
        It is strongly recommended that such <refterm
        primary="schema">schemas</refterm> be based on the <refterm
        primary="schema" secondary="core">core schema</refterm> defined above.
        In addition, it is strongly recommended that such <refterm
        primary="schema">schemas</refterm> make as much use as possible of the
        the <defterm primary="tag" secondary="repository">YAML tag
        repository</defterm> at <ulink url="http://yaml.org/type/"/>. This
        repository provides recommended <refterm primary="tag"
        secondary="global">global tags</refterm> for increasing the portability
        of YAML <refterm primary="document">documents</refterm> between
        different <refterm primary="application">applications</refterm>.
      </para>

      <para>
        The tag repository is intentionally left out of the scope of this
        specification. This allows it to evolve to better support YAML <refterm
        primary="application">applications</refterm>. Hence, developers are
        encouraged to submit new <quote>universal</quote> types to the
        repository. The yaml-core mailing list at <ulink
        url="http://lists.sourceforge.net/lists/listinfo/yaml-core"/> is the
        preferred method for such submissions, as well as raising any questions
        regarding this draft.
      </para>
    </sect1>
  </chapter>

  <index/>
</book>
